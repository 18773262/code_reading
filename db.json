{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/k8s-001.md","hash":"ea96db9a3388d9580f417f01814c8856d8377855","modified":1613638616742},{"_id":"source/_posts/k8s-002.md","hash":"81061401f95b4505d1f019b6eec97e8a265071d2","modified":1613638680900},{"_id":"source/_posts/k8s-003.md","hash":"6a31f0a26973b218b6695c7599632917268ab3e6","modified":1613638710269},{"_id":"source/_posts/k8s-004.md","hash":"6cbbcb131ce14ed29dcb9adda7d79e9b860880f7","modified":1613638724111},{"_id":"source/_posts/k8s-005.md","hash":"a204f64ae7d4c29503afda832150a83971810eb7","modified":1613638743569},{"_id":"source/_posts/k8s-006.md","hash":"8822c0ca464bfadec7a7187aac7d1207c3d2578a","modified":1613638760009},{"_id":"source/_posts/k8s-007.md","hash":"bf75f61a706683cbde9313f148385f7ccbdbef0b","modified":1613638777773},{"_id":"source/_posts/k8s-008.md","hash":"8ca14c3746cfe21637f92bd320738e753c64e1b1","modified":1613638793822},{"_id":"source/_posts/k8s-009.md","hash":"7862553608865586a1909623ac5a397a73009d6a","modified":1613638807409},{"_id":"source/_posts/k8s-010.md","hash":"0a5455af4202cf4ff20998f1bb23eb58da75d3e5","modified":1613638819521},{"_id":"source/_posts/k8s-011.md","hash":"974e2da858b78437f75a964747af6257ac2ef63c","modified":1613638834687},{"_id":"source/_posts/k8s-012.md","hash":"5f6300a1e8945908faec8304ddf5ea333c4f9e92","modified":1613638851221},{"_id":"source/_posts/k8s-013.md","hash":"c719f32e4fc29075ff61e0fdad48c1e5f69103a4","modified":1613641771728},{"_id":"themes/next/_vendors.yml","hash":"199c9f4fcf70fc3952a2988bf62e539b68c53cf7","modified":1613641204666},{"_id":"themes/next/LICENSE.md","hash":"63ea7df5a8dc1b23cc92ca9de3ed16d53367f360","modified":1613641204665},{"_id":"themes/next/README.md","hash":"d5559b6910919a69bbde2e72e504a470d84afbe2","modified":1613641204665},{"_id":"themes/next/package.json","hash":"f2802846088cbe369b5b6fabb50631ced94b61c0","modified":1613641204684},{"_id":"themes/next/_config.yml","hash":"88aa55d42e4112600edcf631f13c437719284ff8","modified":1613642086667},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1613641204666},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1613641204684},{"_id":"themes/next/docs/LICENSE.txt","hash":"8ef5fc1147c196680b06e1accab80c8d236ab951","modified":1613641204667},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1613641204667},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1613641204666},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1613641204669},{"_id":"themes/next/languages/ar.yml","hash":"7a62243ec54196e3d1bea7364f05aded490bc234","modified":1613641204670},{"_id":"themes/next/languages/default.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1613641204670},{"_id":"themes/next/languages/es.yml","hash":"c3506dfaa771e827ae6adb322477c6e835cd0f09","modified":1613641204670},{"_id":"themes/next/languages/en.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1613641204670},{"_id":"themes/next/languages/de.yml","hash":"dc448f724c7d436233e9567711a09e0d56e60e3b","modified":1613641204670},{"_id":"themes/next/languages/fr.yml","hash":"8ddfe98e7847ee8f1eaba9119f9fbdc42d7ec120","modified":1613641204671},{"_id":"themes/next/languages/fa.yml","hash":"649823297167b902455c0aec8ddebb462df71c7d","modified":1613641204671},{"_id":"themes/next/languages/ja.yml","hash":"fec1e1c15ad2df7ed1249173cc719ccba6d3b842","modified":1613641204672},{"_id":"themes/next/languages/id.yml","hash":"ac018805190bc4bdc06091f5a6444e612fc700b0","modified":1613641204671},{"_id":"themes/next/languages/it.yml","hash":"82a93c32b3fcf6517441cdc73f75bc6173beb392","modified":1613641204672},{"_id":"themes/next/languages/ko.yml","hash":"8342df2f4190ba4ee004b70d1d6ccd341033dbe7","modified":1613641204672},{"_id":"themes/next/languages/nl.yml","hash":"0d3b56613197cb190900311507535db41daec7d4","modified":1613641204672},{"_id":"themes/next/languages/pt-BR.yml","hash":"47daeaa23c4db073e77761c9a6f62d3932af06ec","modified":1613641204672},{"_id":"themes/next/languages/pt.yml","hash":"e0e2675261e2e80f7ce7d19c945c08217b068d81","modified":1613641204673},{"_id":"themes/next/languages/ru.yml","hash":"fdf5c623890db24cb56ab5ffe0c49db3542477c8","modified":1613641204673},{"_id":"themes/next/languages/tr.yml","hash":"54de3d8d85e3c7b14b163c3d322411b7301a09b3","modified":1613641204673},{"_id":"themes/next/languages/uk.yml","hash":"1c9a0b8d8160c77cc62064207d57f460f365cae9","modified":1613641204673},{"_id":"themes/next/languages/vi.yml","hash":"1f9657b58e11db21f93eb895c90123b8f91751a7","modified":1613641204673},{"_id":"themes/next/languages/zh-CN.yml","hash":"6f7c742316c96d5b71da50fddfb060ff7ec1ea99","modified":1613641204673},{"_id":"themes/next/languages/zh-HK.yml","hash":"149fccd0afdbc8db76e372cbc73d7b5f07bb7515","modified":1613641204674},{"_id":"themes/next/layout/_layout.njk","hash":"bf7e6ca826b6c3f85e14da61d56d7b836d2414c4","modified":1613641204674},{"_id":"themes/next/languages/zh-TW.yml","hash":"d534f321ee0c235e1ebfea383eb1892bbd7d7e95","modified":1613641204674},{"_id":"themes/next/layout/archive.njk","hash":"08885f48d5878c92c910f8c41e3209eb07b9b80e","modified":1613641204683},{"_id":"themes/next/layout/category.njk","hash":"434fc2b27120ebae91522002eb40e16f2158bd4f","modified":1613641204684},{"_id":"themes/next/layout/index.njk","hash":"d8fa14549fa061e7bdba4ec1472cb45ecea96382","modified":1613641204684},{"_id":"themes/next/scripts/renderer.js","hash":"c53dbede2ad5f68d7349bc5ed8ac7157d723e987","modified":1613641204688},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1613641204684},{"_id":"themes/next/layout/page.njk","hash":"4f8f377e4f5511e27de1c2e4a1c13374b6a5d9bd","modified":1613641204684},{"_id":"themes/next/layout/tag.njk","hash":"09075c80b53b06826e7eb9ce838bca9dc363fac1","modified":1613641204684},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1613641204708},{"_id":"themes/next/docs/ru/README.md","hash":"f0255b119e28102aef403609c29a605f15b95b70","modified":1613641204667},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"0e204dde6d21f100cba6ca7751de71848490759e","modified":1613641204668},{"_id":"themes/next/docs/zh-CN/README.md","hash":"fc9df0ab84387f0468baa0f4a53c7dd9931dbc6d","modified":1613641204669},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"8ee5ca39ac4a372a5c0f16e344bbe578af4aeae4","modified":1613641204668},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1613641204674},{"_id":"themes/next/layout/_macro/post.njk","hash":"f381d4c485ae484a114040d5654db648e4ac7473","modified":1613641204674},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"3481594d36df9eb5e220a6b981d3e5630376a597","modified":1613641204675},{"_id":"themes/next/layout/_partials/comments.njk","hash":"334e8d8117a46c8c097788811322a62627952219","modified":1613641204675},{"_id":"themes/next/layout/_partials/footer.njk","hash":"9c69b85c9ad86ef5c11d2245f91d98f1be248c40","modified":1613641204675},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1613641204677},{"_id":"themes/next/layout/_partials/languages.njk","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1613641204676},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"24eb5b683310810f93c1d7f68f8f70f1a29fd217","modified":1613641204679},{"_id":"themes/next/layout/_scripts/index.njk","hash":"48cbbca0e4f97b8c25f2a5c408071603cd257a65","modified":1613641204679},{"_id":"themes/next/layout/_scripts/pjax.njk","hash":"28a3bcb1ce50924a5a48b0f3756ac3a8736867f1","modified":1613641204679},{"_id":"themes/next/layout/_scripts/noscript.njk","hash":"4f250d0bf80be06dd2c95c1d4c2ba2624b59cf2a","modified":1613641204679},{"_id":"themes/next/layout/_third-party/baidu-push.njk","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1613641204680},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"bada07da2a47ed6de6081796367b19dd9e906cfb","modified":1613641204679},{"_id":"themes/next/layout/_third-party/index.njk","hash":"dc4d2dec2f726b8c5c9f5ac7d6dd0eef0814a0d0","modified":1613641204681},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"294b7f6a4fa566e369d8be0ce7b28f35b6c14563","modified":1613641204682},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1613641204682},{"_id":"themes/next/scripts/events/index.js","hash":"89091bc943cd8b8c63b8af3d26fb0a027048e9ba","modified":1613641204684},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1613641204686},{"_id":"themes/next/scripts/filters/locals.js","hash":"fa1e558f058f93455acdd553ab1be30b26f137e4","modified":1613641204686},{"_id":"themes/next/scripts/filters/minify.js","hash":"be0574c64a38210e449c99d38a760452015060a3","modified":1613641204687},{"_id":"themes/next/scripts/filters/post.js","hash":"bac5646993153f9f6a630c9f0052bb17fa760a9c","modified":1613641204687},{"_id":"themes/next/scripts/helpers/engine.js","hash":"2861b738b6f03114b6f922e794fe2b20090d1438","modified":1613641204687},{"_id":"themes/next/scripts/helpers/font.js","hash":"9cf01a3cf62d9b5a1a0db8145088774bf94045c8","modified":1613641204687},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"3b2261da74c7b33cabfbc82cbb3ce9c8046314d4","modified":1613641204687},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"577c510374cf9bcfa8d3a1027e42411a9324805e","modified":1613641204687},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"2f4152bb450dc4ca8e802e78a21c1858fae298b9","modified":1613641204688},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1613641204688},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1613641204688},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1613641204688},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9836e3212f889e94ada4c354c7b83f7d7caa9aa7","modified":1613641204688},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1613641204689},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1613641204689},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"9e2c58d1a4d1dd84fa86144e5b4576b2fd10a37f","modified":1613641204689},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"464effc08e757ce8e1bb094707d06ad829af9d62","modified":1613641204689},{"_id":"themes/next/scripts/tags/note.js","hash":"05be417a17385a31e1a021e1a54b15046cfd8408","modified":1613641204689},{"_id":"themes/next/scripts/tags/pdf.js","hash":"27129fc4014d723ba93ac77b11342da2ee445d96","modified":1613641204689},{"_id":"themes/next/scripts/tags/tabs.js","hash":"2bf00d56b3b289a7dd27e9b5820430a2457a19f3","modified":1613641204689},{"_id":"themes/next/scripts/tags/video.js","hash":"911851fb3a56570b761d133a6e1531ebf864ea83","modified":1613641204689},{"_id":"themes/next/source/css/_colors.styl","hash":"b37f9847d2f95632e911df670b51921a7d748068","modified":1613641204690},{"_id":"themes/next/source/js/algolia-search.js","hash":"a6f78c4cfffa976e4b8043e3486ce99aaba02bda","modified":1613641204707},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1613641204705},{"_id":"themes/next/source/css/_mixins.styl","hash":"b9c3d3087a917c94cf34ffd6621528d377af8fc9","modified":1613641204701},{"_id":"themes/next/source/js/local-search.js","hash":"d57be5b0349610b5b0de303a9574117365d6d554","modified":1613641204707},{"_id":"themes/next/source/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1613641204707},{"_id":"themes/next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1613641204707},{"_id":"themes/next/source/js/next-boot.js","hash":"da67f3eed604dcdc4e89280c9db69fe1f62818e9","modified":1613641204707},{"_id":"themes/next/source/js/schedule.js","hash":"ababd67895ce49049271601c6928fce56a1c6bbb","modified":1613641204707},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1613641204705},{"_id":"themes/next/source/js/utils.js","hash":"eed4ec020dbf499b6479cbe4e1a90b0b4fe4d1e8","modified":1613641204708},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1613641204705},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1613641204705},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1613641204705},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1613641204705},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1613641204705},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1613641204706},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1613641204706},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1613641204706},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1613641204706},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1613641204706},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1613641204706},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1613641204706},{"_id":"themes/next/test/helpers/font.js","hash":"8930b1f16facc18dc6764bf6efd753ca50d3f1cb","modified":1613641204708},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1613641204708},{"_id":"themes/next/test/helpers/next-url.js","hash":"abc4ee5149df6172b2c36b6e85d1993ec748ddea","modified":1613641204708},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1613641204709},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1613641204709},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1613641204709},{"_id":"themes/next/test/tags/group-pictures.js","hash":"caf9f6b9a72e41fb30aa24468a54496fba1fcdd8","modified":1613641204709},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1613641204709},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1613641204709},{"_id":"themes/next/test/tags/link-grid.js","hash":"88ec69e4dc1d493d21254ed9296a2514e91f0f8b","modified":1613641204709},{"_id":"themes/next/test/tags/mermaid.js","hash":"ed5b5a70ee49842501c952c4d62483f1fc8eba6b","modified":1613641204709},{"_id":"themes/next/test/tags/note.js","hash":"1b6bac741212e7ca763ab7f92ed2d4e2868126f4","modified":1613641204710},{"_id":"themes/next/test/tags/pdf.js","hash":"bac003317e5bb5e046848522c5c4a7cf231e53f6","modified":1613641204710},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1613641204710},{"_id":"themes/next/test/tags/video.js","hash":"43aaebbc60f19aa69c03b212afff4c4a3fc3b862","modified":1613641204710},{"_id":"themes/next/test/validate/index.js","hash":"ef716c1db8e3c93c320f73b6da4010e03b4eb0ae","modified":1613641204710},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"37bdf020591feb0cf72327c9efd755bf78a0afd6","modified":1613641204675},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"c082a16163d1fb5d7cf858fb7522fca9d18f1ba6","modified":1613641204675},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"6b502f9e682d1e0083abe229a2f48523ff852c62","modified":1613641204675},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1613641204676},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1613641204676},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1613641204676},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1613641204676},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"1b6f08cd884081cc67f02c09ce4696c2df4a9d20","modified":1613641204676},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1613641204676},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"789915339a6234d6dd7c710cc1f8e728d9b81d35","modified":1613641204677},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1613641204677},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"9d650333160ad1977fe42d9770869ff1660a95fe","modified":1613641204677},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1613641204677},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"1d1eba50a28518dea5bba34b2737cfb9b0f2cf49","modified":1613641204677},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1613641204677},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"fbdb5cdbd80970f201f5c75369eaa00aea369235","modified":1613641204677},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1613641204678},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"a9bb52d0537d27cfe670d80e716da6780786ab8a","modified":1613641204678},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"c2ccaac9caeea1a43dc31f4f8368f8f548aab0af","modified":1613641204678},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"b7a66a465e897c27624f0c441375c95c4cb7a5aa","modified":1613641204678},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"90156f42d6e6e326ed38482d6623a0aac0352016","modified":1613641204678},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"a27b994ab99c684765895ffebf72ae30dcfa0703","modified":1613641204678},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1613641204679},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"ad197fd728dd7ac90f910fdf80ce848eab3ff187","modified":1613641204680},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1613641204680},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"d87df68dff14cfb4d91a77230cd1ac795c2a22d5","modified":1613641204680},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1613641204680},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1613641204680},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5c2cd9b6f02bcb6248d3f18638a58e329fe8c0d1","modified":1613641204680},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"cc1450d62d76e59968bdd25836694b8339207384","modified":1613641204681},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"54eab4840443262432ec7c47e56e9859ace2a902","modified":1613641204681},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"ec0474e23ca122b34858ffb0bb8c99f241749c61","modified":1613641204681},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"6252b0353c6a36d03c68ebec1073293442221bd1","modified":1613641204681},{"_id":"themes/next/layout/_third-party/comments/valine.njk","hash":"ae2cca696dba96dda7958f0d2b642257599dc11c","modified":1613641204681},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"b0efe26601037e621b5cb16f0fe2f347ee27acdb","modified":1613641204681},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"b6746dfad32cc8a46ff8f4194a7a16ca41744803","modified":1613641204682},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"a8239f99b316e6c060bad8173be3a25c67138697","modified":1613641204682},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"97035261aa85c7d39c6ce1211cdefc6248c0446d","modified":1613641204682},{"_id":"themes/next/layout/_third-party/search/swiftype.njk","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1613641204682},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1613641204682},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1613641204682},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.njk","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1613641204683},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"b70157965285a8c1e003c570cfd4b40bcc1fa719","modified":1613641204683},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"8b956fb56284e8fa4a4731b1efd1f25e1b2b4a78","modified":1613641204683},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"7f01be99413143c5158bda6d83d72bfae6ea5864","modified":1613641204683},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"007da98b913a62946c03a87f8fa25b3db856caa1","modified":1613641204683},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"67d80a57f6b2cf23d56276ca8f30f25e3e8707e9","modified":1613641204683},{"_id":"themes/next/scripts/events/lib/config.js","hash":"545ebbd9f5aeb9f7a8e23737664c1f7d701275e1","modified":1613641204685},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1613641204685},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"7b0ea8d28ced63977dc6539920eb044b1098adcb","modified":1613641204685},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"e227174a8ebab8d5b6e8e26faf4fd66c43f045ca","modified":1613641204685},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"f76c7e13fc4304f86260068c9d83d3477b64ee4b","modified":1613641204685},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"199fa9a70914d0019cf0e47f55491183d53d1533","modified":1613641204685},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1613641204686},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1613641204686},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"a9b18b7447cd5a56cb692c574463a27356eb7fa6","modified":1613641204686},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7b8ce8e9a71cf083f5337fb7c9586be8f7c316e8","modified":1613641204686},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"387e59cd396c62fe095b388c8ff8d4191cfbdeb9","modified":1613641204686},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"1198cb63375a53400431c2e65e3361416cdf8eb6","modified":1613641204686},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"c67984fc868d4799b3aa6d3b3cd060e5260b3a98","modified":1613641204686},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1613641204704},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f2bd7a213c35b37233c687bd4ce0fc1de37bc988","modified":1613641204704},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1613641204704},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1613641204704},{"_id":"themes/next/source/css/_variables/base.styl","hash":"0bda922162bca08b0191e5b54857772e4bdabe3a","modified":1613641204704},{"_id":"themes/next/source/js/schemes/muse.js","hash":"d7a6c12bb534810eb748d0ba28aff67cccf0bb3f","modified":1613641204708},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d4809783ded05625675b1b4bbd9e99d7f5f7d7f9","modified":1613641204690},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"92915560810c0311dada43ed629b8fc4ff0fc7a4","modified":1613641204690},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"1c75a837faae9aa2d0a5f30d2078aa8d2ccc2552","modified":1613641204690},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"ee8fb8348aa76a9b346927ba4cae5666d8d777f7","modified":1613641204694},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"28368ac06d04ccf0bbf3dc9e0dfcf341c200b28c","modified":1613641204697},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"0c9f72ad98807521cbdcee7b5bbe2e884311db39","modified":1613641204697},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"ea96e86b6bcb160351c18a7edc4a561918a820cb","modified":1613641204699},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1613641204699},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1613641204699},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1613641204699},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1613641204700},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"a472fb1afc6486266b85f773501a290e0a80c370","modified":1613641204699},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e1c85ab2831fd7d4bb84aea1850a0160be0023e8","modified":1613641204700},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1613641204701},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7ad04d5a02a7618ebb09c1d5a435d46c4df2c620","modified":1613641204701},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"06786e1ed8774f8f08cbfc711296cf189aaf1b8c","modified":1613641204702},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1613641204702},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f6d165dae928c12bde3f271d299a93b334116433","modified":1613641204702},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"0c4390d3a394c5ba96daec864b118fd0c4a934ff","modified":1613641204702},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1613641204702},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1613641204702},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1613641204702},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c706733f5196776fe2657a9bebe0a727cf8fe8e5","modified":1613641204703},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"e1550114d6f5e828d791831153ef0912a14b4d49","modified":1613641204703},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1613641204703},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1613641204703},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"be5c46b983df08b9dbac1b4749b1a101b54b6b50","modified":1613641204703},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1613641204703},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"c435cfd858bf82726fff2c85d384e2207bea0370","modified":1613641204703},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"826c7f523f1b3a95fedbae7ef3b13ae2f5d41231","modified":1613641204703},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"78f0b6edc296a9ed5144da9f9752c0b96bebfaa5","modified":1613641204704},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1613641204704},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1613641204691},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1613641204691},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1613641204691},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"19fc5ca0784f5d2befddb9d8bc463b916c5c2518","modified":1613641204691},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1613641204692},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"5d61dedb3bec1021d52894f9b379e4d0953f6a35","modified":1613641204692},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8998a07acf0dbd10811835c8dfc91d92e680bcae","modified":1613641204692},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"76d0dfb3a8b873a6180604ac6daecf38b6a963a2","modified":1613641204692},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"8a2e724df3d5cd14765eb951f0a9e1dba399fd35","modified":1613641204693},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1613641204693},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"d6ecc5dfd15c588782ba5e1df9f915b305622aef","modified":1613641204693},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cf6540e12c2de5befcfb7e92d915e3b75fd53dfa","modified":1613641204693},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"27001ad06f69ff035639210ab2f614861b21a4f4","modified":1613641204693},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1613641204694},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"b3fa752f72ca1413289b76c56fbd33a00e3d25d7","modified":1613641204694},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1613641204694},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"2c534d2b2dbc932ad65d335a720a7ba9612bac04","modified":1613641204695},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"48ee817d05ddc788423d7f10e9823e23fda81d04","modified":1613641204694},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"5d8fc91cdb7ee313eb367dcec7d5b2429f98242f","modified":1613641204695},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2896840ab8ac8ab2a7f76d18df893f290ac31625","modified":1613641204695},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"f11dca93e334b68a29e792f7abe682993fab7568","modified":1613641204695},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"8cb89864e8245a356d08ef0fee3133810f646fea","modified":1613641204696},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"254e781e7b25e31a1a589c8b38dc608802f1cc6e","modified":1613641204696},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"f1778d2c56974b96dae429456d5c55be325c4946","modified":1613641204696},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"6d8afd8e23c40bb2b2a2edbe4eb0d2671cd81188","modified":1613641204696},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"57e6b5d82a2d85cabfc7275eb0ac758f3c06991d","modified":1613641204696},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"9c8abc55c9d94d384a245013951aba5ecca2f4fe","modified":1613641204697},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"66782e68f1c74a7d0aecef20e2ca16bbe6b52592","modified":1613641204697},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1613641204697},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1613641204697},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1613641204698},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"521b36ea7bb3a843029cbfbb6b5e76e91c40a19f","modified":1613641204698},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"55060cade4547779ba5996643d93763373b5127c","modified":1613641204698},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"469855a72d2c2b63a21df8fbcb8cc41d32cb9bde","modified":1613641204698},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"432e73bc4f99322af6af1852e0ea6e674919c31a","modified":1613641204698},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"43f7d37948232553873ee346d625457bfe704e74","modified":1613641204698},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"77398b426f182823776f38071de3c839e401fbe0","modified":1613641204698},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1613641204699},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"920f21dc03b28f006aef7e9d0fd444c2cd283efc","modified":1613641204699},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"15a5e273a8137550c93c8d2a60f9fcf86e04a89e","modified":1613641204700},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1613641204700},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"f09bc97e3681d73c38d7d3c5c271486c2c6537e2","modified":1613641204700},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"acfdec45e56cdd6a5ea61e0154f8a6d1bc068214","modified":1613641204700},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"3c029a003e9bf747e1b9cc7c0c127f6028374876","modified":1613641204700},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"29bef220307d86b1eafbb3714381df32d48b5a60","modified":1613641204700},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1613641204701},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"dcf426c2a4836386c0c27235de3f9a95c5de67cc","modified":1613641204701},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"cef4e779473daa3761709958243c6b8a57bbd814","modified":1613641204701},{"_id":"source/tags/index.md","hash":"ef5ca3cd33a125c91109eadfa87dd51435805181","modified":1613641658149},{"_id":"source/categories/index.md","hash":"bd47dfa6f7c0dccea37d70373e9c35c21418f723","modified":1613641747686}],"Category":[{"name":"源码阅读","_id":"cklaonbqd000ja4qp83sb85hg"}],"Data":[],"Page":[{"title":"文章标签","date":"2021-02-18T09:47:04.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 文章标签\ndate: 2021-02-18 17:47:04\ntype: \"tags\"\n---\n","updated":"2021-02-18T09:47:38.149Z","path":"tags/index.html","_id":"cklaok5u7000ha4qp32w3c2md","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2021-02-18T09:48:43.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2021-02-18 17:48:43\ntype: \"categories\"\n---\n","updated":"2021-02-18T09:49:07.686Z","path":"categories/index.html","_id":"cklaomaaw000ia4qp9qs9dzf6","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"【K8s源码品读】001：Phase 1 - 掌握k8s创建pod的基本流程","date":"2021-02-18T08:55:48.000Z","_content":"\n部署Kubernetes集群的方法（建议用kubeadm），详细可参考[我的博客](http://www.junes.tech/?p=150)，或者可直接参考[官方文档](https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/)。\n\n本次分析的源码基于release-1.19。\n\n> 后续版本如果对某个模块有大改动的话，大家也可以提醒我进行更新\n\n## 确立目标\n\n1. 从`创建pod`的全流程入手，了解各组件的工作内容，组件主要包括\n   1. kubectl\n   2. kube-apiserver\n   3. etcd\n   4. kube-controller\n   5. kube-scheduler\n   6. kubelet\n2. 对`核心模块`与`引用的库`有基本的认识，为后续深入做好铺垫\n3. 结合源码，掌握kubernetes的`核心概念`\n\n\n\n## 写一个Yaml\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-pod\nspec:\n    containers:\n    - name: nginx\n      image: nginx:1.8\n```\n\n\n\n## 部署Pod\n\n```shell\nkubectl create -f nginx_pod.yaml\n\npod/nginx-pod created\n```\n\n提示创建成功\n\n\n\n## 查询Pod\n\n```shell\nkubectl get pods\n\nNAME                               READY   STATUS              RESTARTS   AGE\nnginx-pod                          1/1     Running             0          4m22s\n```\n\n打印出状态：\n\n- NAME - nginx-pod就是对应上面 `metadata.name`\n- READY - 就绪的个数\n- STATUS - 当前的状态，RUNNING表示运行中\n- RESTARTS - 重启的次数\n- AGE - 运行的次数\n\n\n\n## 完结撒花\n\n整个操作就这么结束了~\n\n后续的分析，都是基于这个nginx pod的创建示例来的。","source":"_posts/k8s-001.md","raw":"---\ntitle: 【K8s源码品读】001：Phase 1 - 掌握k8s创建pod的基本流程\ndate: 2021-02-18 16:55:48\ntags:\n---\n\n部署Kubernetes集群的方法（建议用kubeadm），详细可参考[我的博客](http://www.junes.tech/?p=150)，或者可直接参考[官方文档](https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/)。\n\n本次分析的源码基于release-1.19。\n\n> 后续版本如果对某个模块有大改动的话，大家也可以提醒我进行更新\n\n## 确立目标\n\n1. 从`创建pod`的全流程入手，了解各组件的工作内容，组件主要包括\n   1. kubectl\n   2. kube-apiserver\n   3. etcd\n   4. kube-controller\n   5. kube-scheduler\n   6. kubelet\n2. 对`核心模块`与`引用的库`有基本的认识，为后续深入做好铺垫\n3. 结合源码，掌握kubernetes的`核心概念`\n\n\n\n## 写一个Yaml\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-pod\nspec:\n    containers:\n    - name: nginx\n      image: nginx:1.8\n```\n\n\n\n## 部署Pod\n\n```shell\nkubectl create -f nginx_pod.yaml\n\npod/nginx-pod created\n```\n\n提示创建成功\n\n\n\n## 查询Pod\n\n```shell\nkubectl get pods\n\nNAME                               READY   STATUS              RESTARTS   AGE\nnginx-pod                          1/1     Running             0          4m22s\n```\n\n打印出状态：\n\n- NAME - nginx-pod就是对应上面 `metadata.name`\n- READY - 就绪的个数\n- STATUS - 当前的状态，RUNNING表示运行中\n- RESTARTS - 重启的次数\n- AGE - 运行的次数\n\n\n\n## 完结撒花\n\n整个操作就这么结束了~\n\n后续的分析，都是基于这个nginx pod的创建示例来的。","slug":"k8s-001","published":1,"updated":"2021-02-18T08:56:56.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaograc0000a4qp58319oky","content":"<p>部署Kubernetes集群的方法（建议用kubeadm），详细可参考<a href=\"http://www.junes.tech/?p=150\">我的博客</a>，或者可直接参考<a href=\"https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/\">官方文档</a>。</p>\n<p>本次分析的源码基于release-1.19。</p>\n<blockquote>\n<p>后续版本如果对某个模块有大改动的话，大家也可以提醒我进行更新</p>\n</blockquote>\n<h2 id=\"确立目标\"><a href=\"#确立目标\" class=\"headerlink\" title=\"确立目标\"></a>确立目标</h2><ol>\n<li>从<code>创建pod</code>的全流程入手，了解各组件的工作内容，组件主要包括<ol>\n<li>kubectl</li>\n<li>kube-apiserver</li>\n<li>etcd</li>\n<li>kube-controller</li>\n<li>kube-scheduler</li>\n<li>kubelet</li>\n</ol>\n</li>\n<li>对<code>核心模块</code>与<code>引用的库</code>有基本的认识，为后续深入做好铺垫</li>\n<li>结合源码，掌握kubernetes的<code>核心概念</code></li>\n</ol>\n<h2 id=\"写一个Yaml\"><a href=\"#写一个Yaml\" class=\"headerlink\" title=\"写一个Yaml\"></a>写一个Yaml</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.8</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"部署Pod\"><a href=\"#部署Pod\" class=\"headerlink\" title=\"部署Pod\"></a>部署Pod</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f nginx_pod.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">pod/nginx-pod created</span><br></pre></td></tr></table></figure>\n<p>提示创建成功</p>\n<h2 id=\"查询Pod\"><a href=\"#查询Pod\" class=\"headerlink\" title=\"查询Pod\"></a>查询Pod</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pods</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                               READY   STATUS              RESTARTS   AGE</span><br><span class=\"line\">nginx-pod                          1/1     Running             0          4m22s</span><br></pre></td></tr></table></figure>\n<p>打印出状态：</p>\n<ul>\n<li>NAME - nginx-pod就是对应上面 <code>metadata.name</code></li>\n<li>READY - 就绪的个数</li>\n<li>STATUS - 当前的状态，RUNNING表示运行中</li>\n<li>RESTARTS - 重启的次数</li>\n<li>AGE - 运行的次数</li>\n</ul>\n<h2 id=\"完结撒花\"><a href=\"#完结撒花\" class=\"headerlink\" title=\"完结撒花\"></a>完结撒花</h2><p>整个操作就这么结束了~</p>\n<p>后续的分析，都是基于这个nginx pod的创建示例来的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>部署Kubernetes集群的方法（建议用kubeadm），详细可参考<a href=\"http://www.junes.tech/?p=150\">我的博客</a>，或者可直接参考<a href=\"https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/\">官方文档</a>。</p>\n<p>本次分析的源码基于release-1.19。</p>\n<blockquote>\n<p>后续版本如果对某个模块有大改动的话，大家也可以提醒我进行更新</p>\n</blockquote>\n<h2 id=\"确立目标\"><a href=\"#确立目标\" class=\"headerlink\" title=\"确立目标\"></a>确立目标</h2><ol>\n<li>从<code>创建pod</code>的全流程入手，了解各组件的工作内容，组件主要包括<ol>\n<li>kubectl</li>\n<li>kube-apiserver</li>\n<li>etcd</li>\n<li>kube-controller</li>\n<li>kube-scheduler</li>\n<li>kubelet</li>\n</ol>\n</li>\n<li>对<code>核心模块</code>与<code>引用的库</code>有基本的认识，为后续深入做好铺垫</li>\n<li>结合源码，掌握kubernetes的<code>核心概念</code></li>\n</ol>\n<h2 id=\"写一个Yaml\"><a href=\"#写一个Yaml\" class=\"headerlink\" title=\"写一个Yaml\"></a>写一个Yaml</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.8</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"部署Pod\"><a href=\"#部署Pod\" class=\"headerlink\" title=\"部署Pod\"></a>部署Pod</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f nginx_pod.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">pod/nginx-pod created</span><br></pre></td></tr></table></figure>\n<p>提示创建成功</p>\n<h2 id=\"查询Pod\"><a href=\"#查询Pod\" class=\"headerlink\" title=\"查询Pod\"></a>查询Pod</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pods</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                               READY   STATUS              RESTARTS   AGE</span><br><span class=\"line\">nginx-pod                          1/1     Running             0          4m22s</span><br></pre></td></tr></table></figure>\n<p>打印出状态：</p>\n<ul>\n<li>NAME - nginx-pod就是对应上面 <code>metadata.name</code></li>\n<li>READY - 就绪的个数</li>\n<li>STATUS - 当前的状态，RUNNING表示运行中</li>\n<li>RESTARTS - 重启的次数</li>\n<li>AGE - 运行的次数</li>\n</ul>\n<h2 id=\"完结撒花\"><a href=\"#完结撒花\" class=\"headerlink\" title=\"完结撒花\"></a>完结撒花</h2><p>整个操作就这么结束了~</p>\n<p>后续的分析，都是基于这个nginx pod的创建示例来的。</p>\n"},{"title":"【K8s源码品读】002：Phase 1 - kubectl - create的调用逻辑","date":"2021-02-18T08:55:49.000Z","_content":"\n## 聚焦目标\n\n我们的目标是查看`kubectl create -f nginx_pod.yaml` 这个命令是怎么运行的。\n\n\n\n## 目录\n\n1. [main函数入口](#main)\n\n2. [传入参数与子命令的匹配](#match)\n\n3. [kubectl命令的初始化](#command)\n\n4. [查看create子命令](#create)\n\n5. [runCreate的创建逻辑](#runCreate)\n\n\n\n## main\n\n\n\n```go\nfunc main() {\n \t// 如果不调用rand.Seed，每次重新运行这个main函数，rand下的函数返回值始终一致\n\t// Seed即随机的种子，每次用时间戳作为种子，就能保证随机性\n\trand.Seed(time.Now().UnixNano())\n\n  // 创建了kubectl命令的默认参数\n\tcommand := cmd.NewDefaultKubectlCommand()\n\n\t// TODO: once we switch everything over to Cobra commands, we can go back to calling\n\t// cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the\n\t// normalize func and add the go flag set by hand.\n\tpflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)\n\tpflag.CommandLine.AddGoFlagSet(goflag.CommandLine)\n\t// cliflag.InitFlags()\n  \n  // 日志的初始化与退出\n\tlogs.InitLogs()\n\tdefer logs.FlushLogs()\n\n  // 运行command\n\tif err := command.Execute(); err != nil {\n\t\tos.Exit(1)\n\t}\n}\n```\n\n\n\n## match\n\n```go\n// k8s的命令行工具采用了 cobra 库，具有命令提示等强大功能，比go语言自带的flag强大很多，可参考 github.com/spf13/cobra\nfunc NewDefaultKubectlCommand() *cobra.Command {\n\treturn NewDefaultKubectlCommandWithArgs(NewDefaultPluginHandler(plugin.ValidPluginFilenamePrefixes), os.Args, os.Stdin, os.Stdout, os.Stderr)\n}\n\nfunc NewDefaultKubectlCommandWithArgs(pluginHandler PluginHandler, args []string, in io.Reader, out, errout io.Writer) *cobra.Command {\n  // 初始化NewKubectlCommand，采用标准输入、输出、错误输出\n\tcmd := NewKubectlCommand(in, out, errout)\n\n\tif pluginHandler == nil {\n\t\treturn cmd\n\t}\n\n\tif len(args) > 1 {\n    // 这里为传入的参数，即 create -f nginx_pod.yaml 部分\n\t\tcmdPathPieces := args[1:]\n\n\t\t// 调用cobra的Find去匹配args\n\t\tif _, _, err := cmd.Find(cmdPathPieces); err != nil {\n\t\t\tif err := HandlePluginCommand(pluginHandler, cmdPathPieces); err != nil {\n\t\t\t\tfmt.Fprintf(errout, \"%v\\n\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cmd\n}\n```\n\n\n\n## command\n\n代码较长，我选择关键性的内容进行讲解\n\n```go\nfunc NewKubectlCommand(in io.Reader, out, err io.Writer) *cobra.Command {\n\twarningHandler := rest.NewWarningWriter(err, rest.WarningWriterOptions{Deduplicate: true, Color: term.AllowsColorOutput(err)})\n\twarningsAsErrors := false\n\n\t// 创建主命令\n\tcmds := &cobra.Command{\n\t\tUse:   \"kubectl\",\n\t\tShort: i18n.T(\"kubectl controls the Kubernetes cluster manager\"),\n\t\tLong: templates.LongDesc(`\n      kubectl controls the Kubernetes cluster manager.\n\n      Find more information at:\n            https://kubernetes.io/docs/reference/kubectl/overview/`),\n\t\tRun: runHelp,\n\t\t// 初始化后，在运行指令前的钩子\n\t\tPersistentPreRunE: func(*cobra.Command, []string) error {\n\t\t\trest.SetDefaultWarningHandler(warningHandler)\n      // 这里是做pprof性能分析，跳转到对应代码可以看到，我们可以用参数 --profile xxx 来采集性能指标，默认保存在当前目录下的profile.pprof中\n\t\t\treturn initProfiling()\n\t\t},\n    // 运行指令后的钩子\n\t\tPersistentPostRunE: func(*cobra.Command, []string) error {\n      // 保存pprof性能分析指标\n\t\t\tif err := flushProfiling(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n      // 打印warning条数\n\t\t\tif warningsAsErrors {\n\t\t\t\tcount := warningHandler.WarningCount()\n\t\t\t\tswitch count {\n\t\t\t\tcase 0:\n\t\t\t\t\t// no warnings\n\t\t\t\tcase 1:\n\t\t\t\t\treturn fmt.Errorf(\"%d warning received\", count)\n\t\t\t\tdefault:\n\t\t\t\t\treturn fmt.Errorf(\"%d warnings received\", count)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n    // bash自动补齐功能，可通过 kubectl completion bash 命令查看\n    // 具体安装可参考 https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion\n\t\tBashCompletionFunction: bashCompletionFunc,\n\t}\n\n  // 实例化Factory接口，工厂模式\n\tf := cmdutil.NewFactory(matchVersionKubeConfigFlags)\n\n\t// 省略实例化的过程代码\n\n  // kubectl定义了7类命令，结合Message和各个子命令的package名来看\n\tgroups := templates.CommandGroups{\n\t\t{\n      // 1. 初级命令，包括 create/expose/run/set\n\t\t\tMessage: \"Basic Commands (Beginner):\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tcreate.NewCmdCreate(f, ioStreams),\n\t\t\t\texpose.NewCmdExposeService(f, ioStreams),\n\t\t\t\trun.NewCmdRun(f, ioStreams),\n\t\t\t\tset.NewCmdSet(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 2. 中级命令，包括explain/get/edit/delete\n\t\t\tMessage: \"Basic Commands (Intermediate):\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\texplain.NewCmdExplain(\"kubectl\", f, ioStreams),\n\t\t\t\tget.NewCmdGet(\"kubectl\", f, ioStreams),\n\t\t\t\tedit.NewCmdEdit(f, ioStreams),\n\t\t\t\tdelete.NewCmdDelete(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 3. 部署命令，包括 rollout/scale/autoscale\n\t\t\tMessage: \"Deploy Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\trollout.NewCmdRollout(f, ioStreams),\n\t\t\t\tscale.NewCmdScale(f, ioStreams),\n\t\t\t\tautoscale.NewCmdAutoscale(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 4. 集群管理命令，包括 cerfificate/cluster-info/top/cordon/drain/taint\n\t\t\tMessage: \"Cluster Management Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tcertificates.NewCmdCertificate(f, ioStreams),\n\t\t\t\tclusterinfo.NewCmdClusterInfo(f, ioStreams),\n\t\t\t\ttop.NewCmdTop(f, ioStreams),\n\t\t\t\tdrain.NewCmdCordon(f, ioStreams),\n\t\t\t\tdrain.NewCmdUncordon(f, ioStreams),\n\t\t\t\tdrain.NewCmdDrain(f, ioStreams),\n\t\t\t\ttaint.NewCmdTaint(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 5. 故障排查和调试，包括 describe/logs/attach/exec/port-forward/proxy/cp/auth\n\t\t\tMessage: \"Troubleshooting and Debugging Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tdescribe.NewCmdDescribe(\"kubectl\", f, ioStreams),\n\t\t\t\tlogs.NewCmdLogs(f, ioStreams),\n\t\t\t\tattach.NewCmdAttach(f, ioStreams),\n\t\t\t\tcmdexec.NewCmdExec(f, ioStreams),\n\t\t\t\tportforward.NewCmdPortForward(f, ioStreams),\n\t\t\t\tproxy.NewCmdProxy(f, ioStreams),\n\t\t\t\tcp.NewCmdCp(f, ioStreams),\n\t\t\t\tauth.NewCmdAuth(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 6. 高级命令，包括diff/apply/patch/replace/wait/convert/kustomize\n\t\t\tMessage: \"Advanced Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tdiff.NewCmdDiff(f, ioStreams),\n\t\t\t\tapply.NewCmdApply(\"kubectl\", f, ioStreams),\n\t\t\t\tpatch.NewCmdPatch(f, ioStreams),\n\t\t\t\treplace.NewCmdReplace(f, ioStreams),\n\t\t\t\twait.NewCmdWait(f, ioStreams),\n\t\t\t\tconvert.NewCmdConvert(f, ioStreams),\n\t\t\t\tkustomize.NewCmdKustomize(ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 7. 设置命令，包括label，annotate，completion\n\t\t\tMessage: \"Settings Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tlabel.NewCmdLabel(f, ioStreams),\n\t\t\t\tannotate.NewCmdAnnotate(\"kubectl\", f, ioStreams),\n\t\t\t\tcompletion.NewCmdCompletion(ioStreams.Out, \"\"),\n\t\t\t},\n\t\t},\n\t}\n\tgroups.Add(cmds)\n\n\tfilters := []string{\"options\"}\n\n\t// alpha相关的子命令\n\talpha := cmdpkg.NewCmdAlpha(f, ioStreams)\n\tif !alpha.HasSubCommands() {\n\t\tfilters = append(filters, alpha.Name())\n\t}\n\n\ttemplates.ActsAsRootCommand(cmds, filters, groups...)\n\n  // 代码补全相关\n\tfor name, completion := range bashCompletionFlags {\n\t\tif cmds.Flag(name) != nil {\n\t\t\tif cmds.Flag(name).Annotations == nil {\n\t\t\t\tcmds.Flag(name).Annotations = map[string][]string{}\n\t\t\t}\n\t\t\tcmds.Flag(name).Annotations[cobra.BashCompCustom] = append(\n\t\t\t\tcmds.Flag(name).Annotations[cobra.BashCompCustom],\n\t\t\t\tcompletion,\n\t\t\t)\n\t\t}\n\t}\n\n  // 添加其余子命令，包括 alpha/config/plugin/version/api-versions/api-resources/options\n\tcmds.AddCommand(alpha)\n\tcmds.AddCommand(cmdconfig.NewCmdConfig(f, clientcmd.NewDefaultPathOptions(), ioStreams))\n\tcmds.AddCommand(plugin.NewCmdPlugin(f, ioStreams))\n\tcmds.AddCommand(version.NewCmdVersion(f, ioStreams))\n\tcmds.AddCommand(apiresources.NewCmdAPIVersions(f, ioStreams))\n\tcmds.AddCommand(apiresources.NewCmdAPIResources(f, ioStreams))\n\tcmds.AddCommand(options.NewCmdOptions(ioStreams.Out))\n\n\treturn cmds\n}\n```\n\n\n\n## create\n\n```go\nfunc NewCmdCreate(f cmdutil.Factory, ioStreams genericclioptions.IOStreams) *cobra.Command {\n  // create子命令的相关选项\n\to := NewCreateOptions(ioStreams)\n\n  // create子命令的相关说明\n\tcmd := &cobra.Command{\n\t\tUse:                   \"create -f FILENAME\",\n\t\tDisableFlagsInUseLine: true,\n\t\tShort:                 i18n.T(\"Create a resource from a file or from stdin.\"),\n\t\tLong:                  createLong,\n\t\tExample:               createExample,\n    // 验证参数并运行\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tif cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames, o.FilenameOptions.Kustomize) {\n\t\t\t\tioStreams.ErrOut.Write([]byte(\"Error: must specify one of -f and -k\\n\\n\"))\n\t\t\t\tdefaultRunFunc := cmdutil.DefaultSubCommandRun(ioStreams.ErrOut)\n\t\t\t\tdefaultRunFunc(cmd, args)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcmdutil.CheckErr(o.Complete(f, cmd))\n\t\t\tcmdutil.CheckErr(o.ValidateArgs(cmd, args))\n      // 核心的运行代码逻辑是在这里的RunCreate\n\t\t\tcmdutil.CheckErr(o.RunCreate(f, cmd))\n\t\t},\n\t}\n\n\to.RecordFlags.AddFlags(cmd)\n\n\tusage := \"to use to create the resource\"\n  // 加入文件名选项的flag -f，保存到o.FilenameOptions.Filenames中，对应上面\n\tcmdutil.AddFilenameOptionFlags(cmd, &o.FilenameOptions, usage)\n\tcmdutil.AddValidateFlags(cmd)\n\tcmd.Flags().BoolVar(&o.EditBeforeCreate, \"edit\", o.EditBeforeCreate, \"Edit the API resource before creating\")\n\tcmd.Flags().Bool(\"windows-line-endings\", runtime.GOOS == \"windows\",\n\t\t\"Only relevant if --edit=true. Defaults to the line ending native to your platform.\")\n\tcmdutil.AddApplyAnnotationFlags(cmd)\n\tcmdutil.AddDryRunFlag(cmd)\n\tcmd.Flags().StringVarP(&o.Selector, \"selector\", \"l\", o.Selector, \"Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2)\")\n\tcmd.Flags().StringVar(&o.Raw, \"raw\", o.Raw, \"Raw URI to POST to the server.  Uses the transport specified by the kubeconfig file.\")\n\tcmdutil.AddFieldManagerFlagVar(cmd, &o.fieldManager, \"kubectl-create\")\n\n\to.PrintFlags.AddFlags(cmd)\n\n\t// create的子命令，指定create对象\n\tcmd.AddCommand(NewCmdCreateNamespace(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateQuota(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateSecret(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateConfigMap(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateServiceAccount(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateService(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateDeployment(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateClusterRole(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateClusterRoleBinding(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateRole(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateRoleBinding(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreatePodDisruptionBudget(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreatePriorityClass(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateJob(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateCronJob(f, ioStreams))\n\treturn cmd\n}\n```\n\n\n\n## runCreate\n\n```go\nfunc (o *CreateOptions) RunCreate(f cmdutil.Factory, cmd *cobra.Command) error {\n\t// f为传入的Factory，主要是封装了与kube-apiserver交互客户端\n  \n\tschema, err := f.Validator(cmdutil.GetFlagBool(cmd, \"validate\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmdNamespace, enforceNamespace, err := f.ToRawKubeConfigLoader().Namespace()\n\tif err != nil {\n\t\treturn err\n\t}\n\n  // 实例化Builder，这块的逻辑比较复杂，我们先关注文件部分\n\tr := f.NewBuilder().\n\t\tUnstructured().\n\t\tSchema(schema).\n\t\tContinueOnError().\n\t\tNamespaceParam(cmdNamespace).DefaultNamespace().\n  \t// 读取文件信息，发现除了支持简单的本地文件，也支持标准输入和http/https协议访问的文件，保存为Visitor\n\t\tFilenameParam(enforceNamespace, &o.FilenameOptions).\n\t\tLabelSelectorParam(o.Selector).\n\t\tFlatten().\n\t\tDo()\n\terr = r.Err()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcount := 0\n  // 调用visit函数，创建资源\n\terr = r.Visit(func(info *resource.Info, err error) error {\n\t\t// 打印结果 xxxx created\n\t\treturn o.PrintObj(info.Object)\n\t})\n\treturn nil\n}\n```\n\n","source":"_posts/k8s-002.md","raw":"---\ntitle: 【K8s源码品读】002：Phase 1 - kubectl - create的调用逻辑\ndate: 2021-02-18 16:55:49\ntags:\n---\n\n## 聚焦目标\n\n我们的目标是查看`kubectl create -f nginx_pod.yaml` 这个命令是怎么运行的。\n\n\n\n## 目录\n\n1. [main函数入口](#main)\n\n2. [传入参数与子命令的匹配](#match)\n\n3. [kubectl命令的初始化](#command)\n\n4. [查看create子命令](#create)\n\n5. [runCreate的创建逻辑](#runCreate)\n\n\n\n## main\n\n\n\n```go\nfunc main() {\n \t// 如果不调用rand.Seed，每次重新运行这个main函数，rand下的函数返回值始终一致\n\t// Seed即随机的种子，每次用时间戳作为种子，就能保证随机性\n\trand.Seed(time.Now().UnixNano())\n\n  // 创建了kubectl命令的默认参数\n\tcommand := cmd.NewDefaultKubectlCommand()\n\n\t// TODO: once we switch everything over to Cobra commands, we can go back to calling\n\t// cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the\n\t// normalize func and add the go flag set by hand.\n\tpflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)\n\tpflag.CommandLine.AddGoFlagSet(goflag.CommandLine)\n\t// cliflag.InitFlags()\n  \n  // 日志的初始化与退出\n\tlogs.InitLogs()\n\tdefer logs.FlushLogs()\n\n  // 运行command\n\tif err := command.Execute(); err != nil {\n\t\tos.Exit(1)\n\t}\n}\n```\n\n\n\n## match\n\n```go\n// k8s的命令行工具采用了 cobra 库，具有命令提示等强大功能，比go语言自带的flag强大很多，可参考 github.com/spf13/cobra\nfunc NewDefaultKubectlCommand() *cobra.Command {\n\treturn NewDefaultKubectlCommandWithArgs(NewDefaultPluginHandler(plugin.ValidPluginFilenamePrefixes), os.Args, os.Stdin, os.Stdout, os.Stderr)\n}\n\nfunc NewDefaultKubectlCommandWithArgs(pluginHandler PluginHandler, args []string, in io.Reader, out, errout io.Writer) *cobra.Command {\n  // 初始化NewKubectlCommand，采用标准输入、输出、错误输出\n\tcmd := NewKubectlCommand(in, out, errout)\n\n\tif pluginHandler == nil {\n\t\treturn cmd\n\t}\n\n\tif len(args) > 1 {\n    // 这里为传入的参数，即 create -f nginx_pod.yaml 部分\n\t\tcmdPathPieces := args[1:]\n\n\t\t// 调用cobra的Find去匹配args\n\t\tif _, _, err := cmd.Find(cmdPathPieces); err != nil {\n\t\t\tif err := HandlePluginCommand(pluginHandler, cmdPathPieces); err != nil {\n\t\t\t\tfmt.Fprintf(errout, \"%v\\n\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cmd\n}\n```\n\n\n\n## command\n\n代码较长，我选择关键性的内容进行讲解\n\n```go\nfunc NewKubectlCommand(in io.Reader, out, err io.Writer) *cobra.Command {\n\twarningHandler := rest.NewWarningWriter(err, rest.WarningWriterOptions{Deduplicate: true, Color: term.AllowsColorOutput(err)})\n\twarningsAsErrors := false\n\n\t// 创建主命令\n\tcmds := &cobra.Command{\n\t\tUse:   \"kubectl\",\n\t\tShort: i18n.T(\"kubectl controls the Kubernetes cluster manager\"),\n\t\tLong: templates.LongDesc(`\n      kubectl controls the Kubernetes cluster manager.\n\n      Find more information at:\n            https://kubernetes.io/docs/reference/kubectl/overview/`),\n\t\tRun: runHelp,\n\t\t// 初始化后，在运行指令前的钩子\n\t\tPersistentPreRunE: func(*cobra.Command, []string) error {\n\t\t\trest.SetDefaultWarningHandler(warningHandler)\n      // 这里是做pprof性能分析，跳转到对应代码可以看到，我们可以用参数 --profile xxx 来采集性能指标，默认保存在当前目录下的profile.pprof中\n\t\t\treturn initProfiling()\n\t\t},\n    // 运行指令后的钩子\n\t\tPersistentPostRunE: func(*cobra.Command, []string) error {\n      // 保存pprof性能分析指标\n\t\t\tif err := flushProfiling(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n      // 打印warning条数\n\t\t\tif warningsAsErrors {\n\t\t\t\tcount := warningHandler.WarningCount()\n\t\t\t\tswitch count {\n\t\t\t\tcase 0:\n\t\t\t\t\t// no warnings\n\t\t\t\tcase 1:\n\t\t\t\t\treturn fmt.Errorf(\"%d warning received\", count)\n\t\t\t\tdefault:\n\t\t\t\t\treturn fmt.Errorf(\"%d warnings received\", count)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n    // bash自动补齐功能，可通过 kubectl completion bash 命令查看\n    // 具体安装可参考 https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion\n\t\tBashCompletionFunction: bashCompletionFunc,\n\t}\n\n  // 实例化Factory接口，工厂模式\n\tf := cmdutil.NewFactory(matchVersionKubeConfigFlags)\n\n\t// 省略实例化的过程代码\n\n  // kubectl定义了7类命令，结合Message和各个子命令的package名来看\n\tgroups := templates.CommandGroups{\n\t\t{\n      // 1. 初级命令，包括 create/expose/run/set\n\t\t\tMessage: \"Basic Commands (Beginner):\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tcreate.NewCmdCreate(f, ioStreams),\n\t\t\t\texpose.NewCmdExposeService(f, ioStreams),\n\t\t\t\trun.NewCmdRun(f, ioStreams),\n\t\t\t\tset.NewCmdSet(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 2. 中级命令，包括explain/get/edit/delete\n\t\t\tMessage: \"Basic Commands (Intermediate):\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\texplain.NewCmdExplain(\"kubectl\", f, ioStreams),\n\t\t\t\tget.NewCmdGet(\"kubectl\", f, ioStreams),\n\t\t\t\tedit.NewCmdEdit(f, ioStreams),\n\t\t\t\tdelete.NewCmdDelete(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 3. 部署命令，包括 rollout/scale/autoscale\n\t\t\tMessage: \"Deploy Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\trollout.NewCmdRollout(f, ioStreams),\n\t\t\t\tscale.NewCmdScale(f, ioStreams),\n\t\t\t\tautoscale.NewCmdAutoscale(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 4. 集群管理命令，包括 cerfificate/cluster-info/top/cordon/drain/taint\n\t\t\tMessage: \"Cluster Management Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tcertificates.NewCmdCertificate(f, ioStreams),\n\t\t\t\tclusterinfo.NewCmdClusterInfo(f, ioStreams),\n\t\t\t\ttop.NewCmdTop(f, ioStreams),\n\t\t\t\tdrain.NewCmdCordon(f, ioStreams),\n\t\t\t\tdrain.NewCmdUncordon(f, ioStreams),\n\t\t\t\tdrain.NewCmdDrain(f, ioStreams),\n\t\t\t\ttaint.NewCmdTaint(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 5. 故障排查和调试，包括 describe/logs/attach/exec/port-forward/proxy/cp/auth\n\t\t\tMessage: \"Troubleshooting and Debugging Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tdescribe.NewCmdDescribe(\"kubectl\", f, ioStreams),\n\t\t\t\tlogs.NewCmdLogs(f, ioStreams),\n\t\t\t\tattach.NewCmdAttach(f, ioStreams),\n\t\t\t\tcmdexec.NewCmdExec(f, ioStreams),\n\t\t\t\tportforward.NewCmdPortForward(f, ioStreams),\n\t\t\t\tproxy.NewCmdProxy(f, ioStreams),\n\t\t\t\tcp.NewCmdCp(f, ioStreams),\n\t\t\t\tauth.NewCmdAuth(f, ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 6. 高级命令，包括diff/apply/patch/replace/wait/convert/kustomize\n\t\t\tMessage: \"Advanced Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tdiff.NewCmdDiff(f, ioStreams),\n\t\t\t\tapply.NewCmdApply(\"kubectl\", f, ioStreams),\n\t\t\t\tpatch.NewCmdPatch(f, ioStreams),\n\t\t\t\treplace.NewCmdReplace(f, ioStreams),\n\t\t\t\twait.NewCmdWait(f, ioStreams),\n\t\t\t\tconvert.NewCmdConvert(f, ioStreams),\n\t\t\t\tkustomize.NewCmdKustomize(ioStreams),\n\t\t\t},\n\t\t},\n\t\t{\n      // 7. 设置命令，包括label，annotate，completion\n\t\t\tMessage: \"Settings Commands:\",\n\t\t\tCommands: []*cobra.Command{\n\t\t\t\tlabel.NewCmdLabel(f, ioStreams),\n\t\t\t\tannotate.NewCmdAnnotate(\"kubectl\", f, ioStreams),\n\t\t\t\tcompletion.NewCmdCompletion(ioStreams.Out, \"\"),\n\t\t\t},\n\t\t},\n\t}\n\tgroups.Add(cmds)\n\n\tfilters := []string{\"options\"}\n\n\t// alpha相关的子命令\n\talpha := cmdpkg.NewCmdAlpha(f, ioStreams)\n\tif !alpha.HasSubCommands() {\n\t\tfilters = append(filters, alpha.Name())\n\t}\n\n\ttemplates.ActsAsRootCommand(cmds, filters, groups...)\n\n  // 代码补全相关\n\tfor name, completion := range bashCompletionFlags {\n\t\tif cmds.Flag(name) != nil {\n\t\t\tif cmds.Flag(name).Annotations == nil {\n\t\t\t\tcmds.Flag(name).Annotations = map[string][]string{}\n\t\t\t}\n\t\t\tcmds.Flag(name).Annotations[cobra.BashCompCustom] = append(\n\t\t\t\tcmds.Flag(name).Annotations[cobra.BashCompCustom],\n\t\t\t\tcompletion,\n\t\t\t)\n\t\t}\n\t}\n\n  // 添加其余子命令，包括 alpha/config/plugin/version/api-versions/api-resources/options\n\tcmds.AddCommand(alpha)\n\tcmds.AddCommand(cmdconfig.NewCmdConfig(f, clientcmd.NewDefaultPathOptions(), ioStreams))\n\tcmds.AddCommand(plugin.NewCmdPlugin(f, ioStreams))\n\tcmds.AddCommand(version.NewCmdVersion(f, ioStreams))\n\tcmds.AddCommand(apiresources.NewCmdAPIVersions(f, ioStreams))\n\tcmds.AddCommand(apiresources.NewCmdAPIResources(f, ioStreams))\n\tcmds.AddCommand(options.NewCmdOptions(ioStreams.Out))\n\n\treturn cmds\n}\n```\n\n\n\n## create\n\n```go\nfunc NewCmdCreate(f cmdutil.Factory, ioStreams genericclioptions.IOStreams) *cobra.Command {\n  // create子命令的相关选项\n\to := NewCreateOptions(ioStreams)\n\n  // create子命令的相关说明\n\tcmd := &cobra.Command{\n\t\tUse:                   \"create -f FILENAME\",\n\t\tDisableFlagsInUseLine: true,\n\t\tShort:                 i18n.T(\"Create a resource from a file or from stdin.\"),\n\t\tLong:                  createLong,\n\t\tExample:               createExample,\n    // 验证参数并运行\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tif cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames, o.FilenameOptions.Kustomize) {\n\t\t\t\tioStreams.ErrOut.Write([]byte(\"Error: must specify one of -f and -k\\n\\n\"))\n\t\t\t\tdefaultRunFunc := cmdutil.DefaultSubCommandRun(ioStreams.ErrOut)\n\t\t\t\tdefaultRunFunc(cmd, args)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcmdutil.CheckErr(o.Complete(f, cmd))\n\t\t\tcmdutil.CheckErr(o.ValidateArgs(cmd, args))\n      // 核心的运行代码逻辑是在这里的RunCreate\n\t\t\tcmdutil.CheckErr(o.RunCreate(f, cmd))\n\t\t},\n\t}\n\n\to.RecordFlags.AddFlags(cmd)\n\n\tusage := \"to use to create the resource\"\n  // 加入文件名选项的flag -f，保存到o.FilenameOptions.Filenames中，对应上面\n\tcmdutil.AddFilenameOptionFlags(cmd, &o.FilenameOptions, usage)\n\tcmdutil.AddValidateFlags(cmd)\n\tcmd.Flags().BoolVar(&o.EditBeforeCreate, \"edit\", o.EditBeforeCreate, \"Edit the API resource before creating\")\n\tcmd.Flags().Bool(\"windows-line-endings\", runtime.GOOS == \"windows\",\n\t\t\"Only relevant if --edit=true. Defaults to the line ending native to your platform.\")\n\tcmdutil.AddApplyAnnotationFlags(cmd)\n\tcmdutil.AddDryRunFlag(cmd)\n\tcmd.Flags().StringVarP(&o.Selector, \"selector\", \"l\", o.Selector, \"Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2)\")\n\tcmd.Flags().StringVar(&o.Raw, \"raw\", o.Raw, \"Raw URI to POST to the server.  Uses the transport specified by the kubeconfig file.\")\n\tcmdutil.AddFieldManagerFlagVar(cmd, &o.fieldManager, \"kubectl-create\")\n\n\to.PrintFlags.AddFlags(cmd)\n\n\t// create的子命令，指定create对象\n\tcmd.AddCommand(NewCmdCreateNamespace(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateQuota(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateSecret(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateConfigMap(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateServiceAccount(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateService(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateDeployment(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateClusterRole(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateClusterRoleBinding(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateRole(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateRoleBinding(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreatePodDisruptionBudget(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreatePriorityClass(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateJob(f, ioStreams))\n\tcmd.AddCommand(NewCmdCreateCronJob(f, ioStreams))\n\treturn cmd\n}\n```\n\n\n\n## runCreate\n\n```go\nfunc (o *CreateOptions) RunCreate(f cmdutil.Factory, cmd *cobra.Command) error {\n\t// f为传入的Factory，主要是封装了与kube-apiserver交互客户端\n  \n\tschema, err := f.Validator(cmdutil.GetFlagBool(cmd, \"validate\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmdNamespace, enforceNamespace, err := f.ToRawKubeConfigLoader().Namespace()\n\tif err != nil {\n\t\treturn err\n\t}\n\n  // 实例化Builder，这块的逻辑比较复杂，我们先关注文件部分\n\tr := f.NewBuilder().\n\t\tUnstructured().\n\t\tSchema(schema).\n\t\tContinueOnError().\n\t\tNamespaceParam(cmdNamespace).DefaultNamespace().\n  \t// 读取文件信息，发现除了支持简单的本地文件，也支持标准输入和http/https协议访问的文件，保存为Visitor\n\t\tFilenameParam(enforceNamespace, &o.FilenameOptions).\n\t\tLabelSelectorParam(o.Selector).\n\t\tFlatten().\n\t\tDo()\n\terr = r.Err()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcount := 0\n  // 调用visit函数，创建资源\n\terr = r.Visit(func(info *resource.Info, err error) error {\n\t\t// 打印结果 xxxx created\n\t\treturn o.PrintObj(info.Object)\n\t})\n\treturn nil\n}\n```\n\n","slug":"k8s-002","published":1,"updated":"2021-02-18T08:58:00.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaograh0001a4qpe6n0f11b","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>我们的目标是查看<code>kubectl create -f nginx_pod.yaml</code> 这个命令是怎么运行的。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><p><a href=\"#main\">main函数入口</a></p>\n</li>\n<li><p><a href=\"#match\">传入参数与子命令的匹配</a></p>\n</li>\n<li><p><a href=\"#command\">kubectl命令的初始化</a></p>\n</li>\n<li><p><a href=\"#create\">查看create子命令</a></p>\n</li>\n<li><p><a href=\"#runCreate\">runCreate的创建逻辑</a></p>\n</li>\n</ol>\n<h2 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"> \t<span class=\"comment\">// 如果不调用rand.Seed，每次重新运行这个main函数，rand下的函数返回值始终一致</span></span><br><span class=\"line\">\t<span class=\"comment\">// Seed即随机的种子，每次用时间戳作为种子，就能保证随机性</span></span><br><span class=\"line\">\trand.Seed(time.Now().UnixNano())</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 创建了kubectl命令的默认参数</span></span><br><span class=\"line\">\tcommand := cmd.NewDefaultKubectlCommand()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class=\"line\">\t<span class=\"comment\">// cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class=\"line\">\t<span class=\"comment\">// normalize func and add the go flag set by hand.</span></span><br><span class=\"line\">\tpflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span><br><span class=\"line\">\tpflag.CommandLine.AddGoFlagSet(goflag.CommandLine)</span><br><span class=\"line\">\t<span class=\"comment\">// cliflag.InitFlags()</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 日志的初始化与退出</span></span><br><span class=\"line\">\tlogs.InitLogs()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> logs.FlushLogs()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 运行command</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := command.Execute(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tos.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// k8s的命令行工具采用了 cobra 库，具有命令提示等强大功能，比go语言自带的flag强大很多，可参考 github.com/spf13/cobra</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewDefaultKubectlCommand</span><span class=\"params\">()</span> *<span class=\"title\">cobra</span>.<span class=\"title\">Command</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewDefaultKubectlCommandWithArgs(NewDefaultPluginHandler(plugin.ValidPluginFilenamePrefixes), os.Args, os.Stdin, os.Stdout, os.Stderr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewDefaultKubectlCommandWithArgs</span><span class=\"params\">(pluginHandler PluginHandler, args []<span class=\"keyword\">string</span>, in io.Reader, out, errout io.Writer)</span> *<span class=\"title\">cobra</span>.<span class=\"title\">Command</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化NewKubectlCommand，采用标准输入、输出、错误输出</span></span><br><span class=\"line\">\tcmd := NewKubectlCommand(in, out, errout)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> pluginHandler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cmd</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里为传入的参数，即 create -f nginx_pod.yaml 部分</span></span><br><span class=\"line\">\t\tcmdPathPieces := args[<span class=\"number\">1</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 调用cobra的Find去匹配args</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, _, err := cmd.Find(cmdPathPieces); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := HandlePluginCommand(pluginHandler, cmdPathPieces); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Fprintf(errout, <span class=\"string\">&quot;%v\\n&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\tos.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cmd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h2><p>代码较长，我选择关键性的内容进行讲解</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewKubectlCommand</span><span class=\"params\">(in io.Reader, out, err io.Writer)</span> *<span class=\"title\">cobra</span>.<span class=\"title\">Command</span></span> &#123;</span><br><span class=\"line\">\twarningHandler := rest.NewWarningWriter(err, rest.WarningWriterOptions&#123;Deduplicate: <span class=\"literal\">true</span>, Color: term.AllowsColorOutput(err)&#125;)</span><br><span class=\"line\">\twarningsAsErrors := <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建主命令</span></span><br><span class=\"line\">\tcmds := &amp;cobra.Command&#123;</span><br><span class=\"line\">\t\tUse:   <span class=\"string\">&quot;kubectl&quot;</span>,</span><br><span class=\"line\">\t\tShort: i18n.T(<span class=\"string\">&quot;kubectl controls the Kubernetes cluster manager&quot;</span>),</span><br><span class=\"line\">\t\tLong: templates.LongDesc(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      kubectl controls the Kubernetes cluster manager.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">      Find more information at:</span></span><br><span class=\"line\"><span class=\"string\">            https://kubernetes.io/docs/reference/kubectl/overview/`</span>),</span><br><span class=\"line\">\t\tRun: runHelp,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化后，在运行指令前的钩子</span></span><br><span class=\"line\">\t\tPersistentPreRunE: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*cobra.Command, []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t\trest.SetDefaultWarningHandler(warningHandler)</span><br><span class=\"line\">      <span class=\"comment\">// 这里是做pprof性能分析，跳转到对应代码可以看到，我们可以用参数 --profile xxx 来采集性能指标，默认保存在当前目录下的profile.pprof中</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> initProfiling()</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 运行指令后的钩子</span></span><br><span class=\"line\">\t\tPersistentPostRunE: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*cobra.Command, []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 保存pprof性能分析指标</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := flushProfiling(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 打印warning条数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> warningsAsErrors &#123;</span><br><span class=\"line\">\t\t\t\tcount := warningHandler.WarningCount()</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> count &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// no warnings</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%d warning received&quot;</span>, count)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%d warnings received&quot;</span>, count)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// bash自动补齐功能，可通过 kubectl completion bash 命令查看</span></span><br><span class=\"line\">    <span class=\"comment\">// 具体安装可参考 https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion</span></span><br><span class=\"line\">\t\tBashCompletionFunction: bashCompletionFunc,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实例化Factory接口，工厂模式</span></span><br><span class=\"line\">\tf := cmdutil.NewFactory(matchVersionKubeConfigFlags)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 省略实例化的过程代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// kubectl定义了7类命令，结合Message和各个子命令的package名来看</span></span><br><span class=\"line\">\tgroups := templates.CommandGroups&#123;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1. 初级命令，包括 create/expose/run/set</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Basic Commands (Beginner):&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tcreate.NewCmdCreate(f, ioStreams),</span><br><span class=\"line\">\t\t\t\texpose.NewCmdExposeService(f, ioStreams),</span><br><span class=\"line\">\t\t\t\trun.NewCmdRun(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tset.NewCmdSet(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 2. 中级命令，包括explain/get/edit/delete</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Basic Commands (Intermediate):&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\texplain.NewCmdExplain(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tget.NewCmdGet(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tedit.NewCmdEdit(f, ioStreams),</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">delete</span>.NewCmdDelete(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 3. 部署命令，包括 rollout/scale/autoscale</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Deploy Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\trollout.NewCmdRollout(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tscale.NewCmdScale(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tautoscale.NewCmdAutoscale(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 4. 集群管理命令，包括 cerfificate/cluster-info/top/cordon/drain/taint</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Cluster Management Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tcertificates.NewCmdCertificate(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tclusterinfo.NewCmdClusterInfo(f, ioStreams),</span><br><span class=\"line\">\t\t\t\ttop.NewCmdTop(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tdrain.NewCmdCordon(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tdrain.NewCmdUncordon(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tdrain.NewCmdDrain(f, ioStreams),</span><br><span class=\"line\">\t\t\t\ttaint.NewCmdTaint(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 5. 故障排查和调试，包括 describe/logs/attach/exec/port-forward/proxy/cp/auth</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Troubleshooting and Debugging Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tdescribe.NewCmdDescribe(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tlogs.NewCmdLogs(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tattach.NewCmdAttach(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tcmdexec.NewCmdExec(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tportforward.NewCmdPortForward(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tproxy.NewCmdProxy(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tcp.NewCmdCp(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tauth.NewCmdAuth(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 6. 高级命令，包括diff/apply/patch/replace/wait/convert/kustomize</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Advanced Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tdiff.NewCmdDiff(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tapply.NewCmdApply(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tpatch.NewCmdPatch(f, ioStreams),</span><br><span class=\"line\">\t\t\t\treplace.NewCmdReplace(f, ioStreams),</span><br><span class=\"line\">\t\t\t\twait.NewCmdWait(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tconvert.NewCmdConvert(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tkustomize.NewCmdKustomize(ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 7. 设置命令，包括label，annotate，completion</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Settings Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tlabel.NewCmdLabel(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tannotate.NewCmdAnnotate(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tcompletion.NewCmdCompletion(ioStreams.Out, <span class=\"string\">&quot;&quot;</span>),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgroups.Add(cmds)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfilters := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;options&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// alpha相关的子命令</span></span><br><span class=\"line\">\talpha := cmdpkg.NewCmdAlpha(f, ioStreams)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !alpha.HasSubCommands() &#123;</span><br><span class=\"line\">\t\tfilters = <span class=\"built_in\">append</span>(filters, alpha.Name())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplates.ActsAsRootCommand(cmds, filters, groups...)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 代码补全相关</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> name, completion := <span class=\"keyword\">range</span> bashCompletionFlags &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> cmds.Flag(name) != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> cmds.Flag(name).Annotations == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tcmds.Flag(name).Annotations = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcmds.Flag(name).Annotations[cobra.BashCompCustom] = <span class=\"built_in\">append</span>(</span><br><span class=\"line\">\t\t\t\tcmds.Flag(name).Annotations[cobra.BashCompCustom],</span><br><span class=\"line\">\t\t\t\tcompletion,</span><br><span class=\"line\">\t\t\t)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 添加其余子命令，包括 alpha/config/plugin/version/api-versions/api-resources/options</span></span><br><span class=\"line\">\tcmds.AddCommand(alpha)</span><br><span class=\"line\">\tcmds.AddCommand(cmdconfig.NewCmdConfig(f, clientcmd.NewDefaultPathOptions(), ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(plugin.NewCmdPlugin(f, ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(version.NewCmdVersion(f, ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(apiresources.NewCmdAPIVersions(f, ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(apiresources.NewCmdAPIResources(f, ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(options.NewCmdOptions(ioStreams.Out))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cmds</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewCmdCreate</span><span class=\"params\">(f cmdutil.Factory, ioStreams genericclioptions.IOStreams)</span> *<span class=\"title\">cobra</span>.<span class=\"title\">Command</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// create子命令的相关选项</span></span><br><span class=\"line\">\to := NewCreateOptions(ioStreams)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// create子命令的相关说明</span></span><br><span class=\"line\">\tcmd := &amp;cobra.Command&#123;</span><br><span class=\"line\">\t\tUse:                   <span class=\"string\">&quot;create -f FILENAME&quot;</span>,</span><br><span class=\"line\">\t\tDisableFlagsInUseLine: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tShort:                 i18n.T(<span class=\"string\">&quot;Create a resource from a file or from stdin.&quot;</span>),</span><br><span class=\"line\">\t\tLong:                  createLong,</span><br><span class=\"line\">\t\tExample:               createExample,</span><br><span class=\"line\">    <span class=\"comment\">// 验证参数并运行</span></span><br><span class=\"line\">\t\tRun: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames, o.FilenameOptions.Kustomize) &#123;</span><br><span class=\"line\">\t\t\t\tioStreams.ErrOut.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;Error: must specify one of -f and -k\\n\\n&quot;</span>))</span><br><span class=\"line\">\t\t\t\tdefaultRunFunc := cmdutil.DefaultSubCommandRun(ioStreams.ErrOut)</span><br><span class=\"line\">\t\t\t\tdefaultRunFunc(cmd, args)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcmdutil.CheckErr(o.Complete(f, cmd))</span><br><span class=\"line\">\t\t\tcmdutil.CheckErr(o.ValidateArgs(cmd, args))</span><br><span class=\"line\">      <span class=\"comment\">// 核心的运行代码逻辑是在这里的RunCreate</span></span><br><span class=\"line\">\t\t\tcmdutil.CheckErr(o.RunCreate(f, cmd))</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\to.RecordFlags.AddFlags(cmd)</span><br><span class=\"line\"></span><br><span class=\"line\">\tusage := <span class=\"string\">&quot;to use to create the resource&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">// 加入文件名选项的flag -f，保存到o.FilenameOptions.Filenames中，对应上面</span></span><br><span class=\"line\">\tcmdutil.AddFilenameOptionFlags(cmd, &amp;o.FilenameOptions, usage)</span><br><span class=\"line\">\tcmdutil.AddValidateFlags(cmd)</span><br><span class=\"line\">\tcmd.Flags().BoolVar(&amp;o.EditBeforeCreate, <span class=\"string\">&quot;edit&quot;</span>, o.EditBeforeCreate, <span class=\"string\">&quot;Edit the API resource before creating&quot;</span>)</span><br><span class=\"line\">\tcmd.Flags().Bool(<span class=\"string\">&quot;windows-line-endings&quot;</span>, runtime.GOOS == <span class=\"string\">&quot;windows&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Only relevant if --edit=true. Defaults to the line ending native to your platform.&quot;</span>)</span><br><span class=\"line\">\tcmdutil.AddApplyAnnotationFlags(cmd)</span><br><span class=\"line\">\tcmdutil.AddDryRunFlag(cmd)</span><br><span class=\"line\">\tcmd.Flags().StringVarP(&amp;o.Selector, <span class=\"string\">&quot;selector&quot;</span>, <span class=\"string\">&quot;l&quot;</span>, o.Selector, <span class=\"string\">&quot;Selector (label query) to filter on, supports &#x27;=&#x27;, &#x27;==&#x27;, and &#x27;!=&#x27;.(e.g. -l key1=value1,key2=value2)&quot;</span>)</span><br><span class=\"line\">\tcmd.Flags().StringVar(&amp;o.Raw, <span class=\"string\">&quot;raw&quot;</span>, o.Raw, <span class=\"string\">&quot;Raw URI to POST to the server.  Uses the transport specified by the kubeconfig file.&quot;</span>)</span><br><span class=\"line\">\tcmdutil.AddFieldManagerFlagVar(cmd, &amp;o.fieldManager, <span class=\"string\">&quot;kubectl-create&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\to.PrintFlags.AddFlags(cmd)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// create的子命令，指定create对象</span></span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateNamespace(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateQuota(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateSecret(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateConfigMap(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateServiceAccount(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateService(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateDeployment(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateClusterRole(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateClusterRoleBinding(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateRole(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateRoleBinding(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreatePodDisruptionBudget(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreatePriorityClass(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateJob(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateCronJob(f, ioStreams))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cmd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"runCreate\"><a href=\"#runCreate\" class=\"headerlink\" title=\"runCreate\"></a>runCreate</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(o *CreateOptions)</span> <span class=\"title\">RunCreate</span><span class=\"params\">(f cmdutil.Factory, cmd *cobra.Command)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// f为传入的Factory，主要是封装了与kube-apiserver交互客户端</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\tschema, err := f.Validator(cmdutil.GetFlagBool(cmd, <span class=\"string\">&quot;validate&quot;</span>))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcmdNamespace, enforceNamespace, err := f.ToRawKubeConfigLoader().Namespace()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实例化Builder，这块的逻辑比较复杂，我们先关注文件部分</span></span><br><span class=\"line\">\tr := f.NewBuilder().</span><br><span class=\"line\">\t\tUnstructured().</span><br><span class=\"line\">\t\tSchema(schema).</span><br><span class=\"line\">\t\tContinueOnError().</span><br><span class=\"line\">\t\tNamespaceParam(cmdNamespace).DefaultNamespace().</span><br><span class=\"line\">  \t<span class=\"comment\">// 读取文件信息，发现除了支持简单的本地文件，也支持标准输入和http/https协议访问的文件，保存为Visitor</span></span><br><span class=\"line\">\t\tFilenameParam(enforceNamespace, &amp;o.FilenameOptions).</span><br><span class=\"line\">\t\tLabelSelectorParam(o.Selector).</span><br><span class=\"line\">\t\tFlatten().</span><br><span class=\"line\">\t\tDo()</span><br><span class=\"line\">\terr = r.Err()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcount := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"comment\">// 调用visit函数，创建资源</span></span><br><span class=\"line\">\terr = r.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *resource.Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 打印结果 xxxx created</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o.PrintObj(info.Object)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>我们的目标是查看<code>kubectl create -f nginx_pod.yaml</code> 这个命令是怎么运行的。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><p><a href=\"#main\">main函数入口</a></p>\n</li>\n<li><p><a href=\"#match\">传入参数与子命令的匹配</a></p>\n</li>\n<li><p><a href=\"#command\">kubectl命令的初始化</a></p>\n</li>\n<li><p><a href=\"#create\">查看create子命令</a></p>\n</li>\n<li><p><a href=\"#runCreate\">runCreate的创建逻辑</a></p>\n</li>\n</ol>\n<h2 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"> \t<span class=\"comment\">// 如果不调用rand.Seed，每次重新运行这个main函数，rand下的函数返回值始终一致</span></span><br><span class=\"line\">\t<span class=\"comment\">// Seed即随机的种子，每次用时间戳作为种子，就能保证随机性</span></span><br><span class=\"line\">\trand.Seed(time.Now().UnixNano())</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 创建了kubectl命令的默认参数</span></span><br><span class=\"line\">\tcommand := cmd.NewDefaultKubectlCommand()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class=\"line\">\t<span class=\"comment\">// cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class=\"line\">\t<span class=\"comment\">// normalize func and add the go flag set by hand.</span></span><br><span class=\"line\">\tpflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span><br><span class=\"line\">\tpflag.CommandLine.AddGoFlagSet(goflag.CommandLine)</span><br><span class=\"line\">\t<span class=\"comment\">// cliflag.InitFlags()</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 日志的初始化与退出</span></span><br><span class=\"line\">\tlogs.InitLogs()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> logs.FlushLogs()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 运行command</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := command.Execute(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tos.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// k8s的命令行工具采用了 cobra 库，具有命令提示等强大功能，比go语言自带的flag强大很多，可参考 github.com/spf13/cobra</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewDefaultKubectlCommand</span><span class=\"params\">()</span> *<span class=\"title\">cobra</span>.<span class=\"title\">Command</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewDefaultKubectlCommandWithArgs(NewDefaultPluginHandler(plugin.ValidPluginFilenamePrefixes), os.Args, os.Stdin, os.Stdout, os.Stderr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewDefaultKubectlCommandWithArgs</span><span class=\"params\">(pluginHandler PluginHandler, args []<span class=\"keyword\">string</span>, in io.Reader, out, errout io.Writer)</span> *<span class=\"title\">cobra</span>.<span class=\"title\">Command</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化NewKubectlCommand，采用标准输入、输出、错误输出</span></span><br><span class=\"line\">\tcmd := NewKubectlCommand(in, out, errout)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> pluginHandler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cmd</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里为传入的参数，即 create -f nginx_pod.yaml 部分</span></span><br><span class=\"line\">\t\tcmdPathPieces := args[<span class=\"number\">1</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 调用cobra的Find去匹配args</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, _, err := cmd.Find(cmdPathPieces); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := HandlePluginCommand(pluginHandler, cmdPathPieces); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Fprintf(errout, <span class=\"string\">&quot;%v\\n&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\tos.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cmd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h2><p>代码较长，我选择关键性的内容进行讲解</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewKubectlCommand</span><span class=\"params\">(in io.Reader, out, err io.Writer)</span> *<span class=\"title\">cobra</span>.<span class=\"title\">Command</span></span> &#123;</span><br><span class=\"line\">\twarningHandler := rest.NewWarningWriter(err, rest.WarningWriterOptions&#123;Deduplicate: <span class=\"literal\">true</span>, Color: term.AllowsColorOutput(err)&#125;)</span><br><span class=\"line\">\twarningsAsErrors := <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建主命令</span></span><br><span class=\"line\">\tcmds := &amp;cobra.Command&#123;</span><br><span class=\"line\">\t\tUse:   <span class=\"string\">&quot;kubectl&quot;</span>,</span><br><span class=\"line\">\t\tShort: i18n.T(<span class=\"string\">&quot;kubectl controls the Kubernetes cluster manager&quot;</span>),</span><br><span class=\"line\">\t\tLong: templates.LongDesc(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      kubectl controls the Kubernetes cluster manager.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">      Find more information at:</span></span><br><span class=\"line\"><span class=\"string\">            https://kubernetes.io/docs/reference/kubectl/overview/`</span>),</span><br><span class=\"line\">\t\tRun: runHelp,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化后，在运行指令前的钩子</span></span><br><span class=\"line\">\t\tPersistentPreRunE: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*cobra.Command, []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t\trest.SetDefaultWarningHandler(warningHandler)</span><br><span class=\"line\">      <span class=\"comment\">// 这里是做pprof性能分析，跳转到对应代码可以看到，我们可以用参数 --profile xxx 来采集性能指标，默认保存在当前目录下的profile.pprof中</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> initProfiling()</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 运行指令后的钩子</span></span><br><span class=\"line\">\t\tPersistentPostRunE: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*cobra.Command, []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 保存pprof性能分析指标</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := flushProfiling(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 打印warning条数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> warningsAsErrors &#123;</span><br><span class=\"line\">\t\t\t\tcount := warningHandler.WarningCount()</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> count &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// no warnings</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%d warning received&quot;</span>, count)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%d warnings received&quot;</span>, count)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// bash自动补齐功能，可通过 kubectl completion bash 命令查看</span></span><br><span class=\"line\">    <span class=\"comment\">// 具体安装可参考 https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion</span></span><br><span class=\"line\">\t\tBashCompletionFunction: bashCompletionFunc,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实例化Factory接口，工厂模式</span></span><br><span class=\"line\">\tf := cmdutil.NewFactory(matchVersionKubeConfigFlags)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 省略实例化的过程代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// kubectl定义了7类命令，结合Message和各个子命令的package名来看</span></span><br><span class=\"line\">\tgroups := templates.CommandGroups&#123;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1. 初级命令，包括 create/expose/run/set</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Basic Commands (Beginner):&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tcreate.NewCmdCreate(f, ioStreams),</span><br><span class=\"line\">\t\t\t\texpose.NewCmdExposeService(f, ioStreams),</span><br><span class=\"line\">\t\t\t\trun.NewCmdRun(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tset.NewCmdSet(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 2. 中级命令，包括explain/get/edit/delete</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Basic Commands (Intermediate):&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\texplain.NewCmdExplain(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tget.NewCmdGet(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tedit.NewCmdEdit(f, ioStreams),</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">delete</span>.NewCmdDelete(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 3. 部署命令，包括 rollout/scale/autoscale</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Deploy Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\trollout.NewCmdRollout(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tscale.NewCmdScale(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tautoscale.NewCmdAutoscale(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 4. 集群管理命令，包括 cerfificate/cluster-info/top/cordon/drain/taint</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Cluster Management Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tcertificates.NewCmdCertificate(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tclusterinfo.NewCmdClusterInfo(f, ioStreams),</span><br><span class=\"line\">\t\t\t\ttop.NewCmdTop(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tdrain.NewCmdCordon(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tdrain.NewCmdUncordon(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tdrain.NewCmdDrain(f, ioStreams),</span><br><span class=\"line\">\t\t\t\ttaint.NewCmdTaint(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 5. 故障排查和调试，包括 describe/logs/attach/exec/port-forward/proxy/cp/auth</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Troubleshooting and Debugging Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tdescribe.NewCmdDescribe(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tlogs.NewCmdLogs(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tattach.NewCmdAttach(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tcmdexec.NewCmdExec(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tportforward.NewCmdPortForward(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tproxy.NewCmdProxy(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tcp.NewCmdCp(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tauth.NewCmdAuth(f, ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 6. 高级命令，包括diff/apply/patch/replace/wait/convert/kustomize</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Advanced Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tdiff.NewCmdDiff(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tapply.NewCmdApply(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tpatch.NewCmdPatch(f, ioStreams),</span><br><span class=\"line\">\t\t\t\treplace.NewCmdReplace(f, ioStreams),</span><br><span class=\"line\">\t\t\t\twait.NewCmdWait(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tconvert.NewCmdConvert(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tkustomize.NewCmdKustomize(ioStreams),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 7. 设置命令，包括label，annotate，completion</span></span><br><span class=\"line\">\t\t\tMessage: <span class=\"string\">&quot;Settings Commands:&quot;</span>,</span><br><span class=\"line\">\t\t\tCommands: []*cobra.Command&#123;</span><br><span class=\"line\">\t\t\t\tlabel.NewCmdLabel(f, ioStreams),</span><br><span class=\"line\">\t\t\t\tannotate.NewCmdAnnotate(<span class=\"string\">&quot;kubectl&quot;</span>, f, ioStreams),</span><br><span class=\"line\">\t\t\t\tcompletion.NewCmdCompletion(ioStreams.Out, <span class=\"string\">&quot;&quot;</span>),</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgroups.Add(cmds)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfilters := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;options&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// alpha相关的子命令</span></span><br><span class=\"line\">\talpha := cmdpkg.NewCmdAlpha(f, ioStreams)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !alpha.HasSubCommands() &#123;</span><br><span class=\"line\">\t\tfilters = <span class=\"built_in\">append</span>(filters, alpha.Name())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplates.ActsAsRootCommand(cmds, filters, groups...)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 代码补全相关</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> name, completion := <span class=\"keyword\">range</span> bashCompletionFlags &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> cmds.Flag(name) != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> cmds.Flag(name).Annotations == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tcmds.Flag(name).Annotations = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcmds.Flag(name).Annotations[cobra.BashCompCustom] = <span class=\"built_in\">append</span>(</span><br><span class=\"line\">\t\t\t\tcmds.Flag(name).Annotations[cobra.BashCompCustom],</span><br><span class=\"line\">\t\t\t\tcompletion,</span><br><span class=\"line\">\t\t\t)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 添加其余子命令，包括 alpha/config/plugin/version/api-versions/api-resources/options</span></span><br><span class=\"line\">\tcmds.AddCommand(alpha)</span><br><span class=\"line\">\tcmds.AddCommand(cmdconfig.NewCmdConfig(f, clientcmd.NewDefaultPathOptions(), ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(plugin.NewCmdPlugin(f, ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(version.NewCmdVersion(f, ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(apiresources.NewCmdAPIVersions(f, ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(apiresources.NewCmdAPIResources(f, ioStreams))</span><br><span class=\"line\">\tcmds.AddCommand(options.NewCmdOptions(ioStreams.Out))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cmds</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewCmdCreate</span><span class=\"params\">(f cmdutil.Factory, ioStreams genericclioptions.IOStreams)</span> *<span class=\"title\">cobra</span>.<span class=\"title\">Command</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// create子命令的相关选项</span></span><br><span class=\"line\">\to := NewCreateOptions(ioStreams)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// create子命令的相关说明</span></span><br><span class=\"line\">\tcmd := &amp;cobra.Command&#123;</span><br><span class=\"line\">\t\tUse:                   <span class=\"string\">&quot;create -f FILENAME&quot;</span>,</span><br><span class=\"line\">\t\tDisableFlagsInUseLine: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tShort:                 i18n.T(<span class=\"string\">&quot;Create a resource from a file or from stdin.&quot;</span>),</span><br><span class=\"line\">\t\tLong:                  createLong,</span><br><span class=\"line\">\t\tExample:               createExample,</span><br><span class=\"line\">    <span class=\"comment\">// 验证参数并运行</span></span><br><span class=\"line\">\t\tRun: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames, o.FilenameOptions.Kustomize) &#123;</span><br><span class=\"line\">\t\t\t\tioStreams.ErrOut.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;Error: must specify one of -f and -k\\n\\n&quot;</span>))</span><br><span class=\"line\">\t\t\t\tdefaultRunFunc := cmdutil.DefaultSubCommandRun(ioStreams.ErrOut)</span><br><span class=\"line\">\t\t\t\tdefaultRunFunc(cmd, args)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcmdutil.CheckErr(o.Complete(f, cmd))</span><br><span class=\"line\">\t\t\tcmdutil.CheckErr(o.ValidateArgs(cmd, args))</span><br><span class=\"line\">      <span class=\"comment\">// 核心的运行代码逻辑是在这里的RunCreate</span></span><br><span class=\"line\">\t\t\tcmdutil.CheckErr(o.RunCreate(f, cmd))</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\to.RecordFlags.AddFlags(cmd)</span><br><span class=\"line\"></span><br><span class=\"line\">\tusage := <span class=\"string\">&quot;to use to create the resource&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">// 加入文件名选项的flag -f，保存到o.FilenameOptions.Filenames中，对应上面</span></span><br><span class=\"line\">\tcmdutil.AddFilenameOptionFlags(cmd, &amp;o.FilenameOptions, usage)</span><br><span class=\"line\">\tcmdutil.AddValidateFlags(cmd)</span><br><span class=\"line\">\tcmd.Flags().BoolVar(&amp;o.EditBeforeCreate, <span class=\"string\">&quot;edit&quot;</span>, o.EditBeforeCreate, <span class=\"string\">&quot;Edit the API resource before creating&quot;</span>)</span><br><span class=\"line\">\tcmd.Flags().Bool(<span class=\"string\">&quot;windows-line-endings&quot;</span>, runtime.GOOS == <span class=\"string\">&quot;windows&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Only relevant if --edit=true. Defaults to the line ending native to your platform.&quot;</span>)</span><br><span class=\"line\">\tcmdutil.AddApplyAnnotationFlags(cmd)</span><br><span class=\"line\">\tcmdutil.AddDryRunFlag(cmd)</span><br><span class=\"line\">\tcmd.Flags().StringVarP(&amp;o.Selector, <span class=\"string\">&quot;selector&quot;</span>, <span class=\"string\">&quot;l&quot;</span>, o.Selector, <span class=\"string\">&quot;Selector (label query) to filter on, supports &#x27;=&#x27;, &#x27;==&#x27;, and &#x27;!=&#x27;.(e.g. -l key1=value1,key2=value2)&quot;</span>)</span><br><span class=\"line\">\tcmd.Flags().StringVar(&amp;o.Raw, <span class=\"string\">&quot;raw&quot;</span>, o.Raw, <span class=\"string\">&quot;Raw URI to POST to the server.  Uses the transport specified by the kubeconfig file.&quot;</span>)</span><br><span class=\"line\">\tcmdutil.AddFieldManagerFlagVar(cmd, &amp;o.fieldManager, <span class=\"string\">&quot;kubectl-create&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\to.PrintFlags.AddFlags(cmd)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// create的子命令，指定create对象</span></span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateNamespace(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateQuota(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateSecret(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateConfigMap(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateServiceAccount(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateService(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateDeployment(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateClusterRole(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateClusterRoleBinding(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateRole(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateRoleBinding(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreatePodDisruptionBudget(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreatePriorityClass(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateJob(f, ioStreams))</span><br><span class=\"line\">\tcmd.AddCommand(NewCmdCreateCronJob(f, ioStreams))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cmd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"runCreate\"><a href=\"#runCreate\" class=\"headerlink\" title=\"runCreate\"></a>runCreate</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(o *CreateOptions)</span> <span class=\"title\">RunCreate</span><span class=\"params\">(f cmdutil.Factory, cmd *cobra.Command)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// f为传入的Factory，主要是封装了与kube-apiserver交互客户端</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\tschema, err := f.Validator(cmdutil.GetFlagBool(cmd, <span class=\"string\">&quot;validate&quot;</span>))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcmdNamespace, enforceNamespace, err := f.ToRawKubeConfigLoader().Namespace()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实例化Builder，这块的逻辑比较复杂，我们先关注文件部分</span></span><br><span class=\"line\">\tr := f.NewBuilder().</span><br><span class=\"line\">\t\tUnstructured().</span><br><span class=\"line\">\t\tSchema(schema).</span><br><span class=\"line\">\t\tContinueOnError().</span><br><span class=\"line\">\t\tNamespaceParam(cmdNamespace).DefaultNamespace().</span><br><span class=\"line\">  \t<span class=\"comment\">// 读取文件信息，发现除了支持简单的本地文件，也支持标准输入和http/https协议访问的文件，保存为Visitor</span></span><br><span class=\"line\">\t\tFilenameParam(enforceNamespace, &amp;o.FilenameOptions).</span><br><span class=\"line\">\t\tLabelSelectorParam(o.Selector).</span><br><span class=\"line\">\t\tFlatten().</span><br><span class=\"line\">\t\tDo()</span><br><span class=\"line\">\terr = r.Err()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcount := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"comment\">// 调用visit函数，创建资源</span></span><br><span class=\"line\">\terr = r.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *resource.Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 打印结果 xxxx created</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o.PrintObj(info.Object)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"【K8s源码品读】003：Phase 1 - kubectl - 设计模式中Visitor的实现","date":"2021-02-18T08:55:50.000Z","_content":"\n## 聚焦目标\n\n理解kubectl的核心实现之一：`Visitor Design Pattern` 访问者模式\n\n\n\n## 目录\n\n1. [什么是访问者模式](#visitor-design-pattern)\n\n2. [kubectl中的Visitor](#visitor)\n\n3. [Visitor的链式处理](#chained)\n   1. 多个对象聚合为一个对象\n      1. [VisitorList](#VisitorList)\n      2. [EagerVisitorList ](#EagerVisitorList)\n   2. 多个方法聚合为一个方法\n      1. [DecoratedVisitor](#DecoratedVisitor)\n      2. [ContinueOnErrorVisitor](#ContinueOnErrorVisitor)\n   3. 将对象抽象为多个底层对象，逐个调用方法\n      1. [FlattenListVisitor](#FlattenListVisitor)\n      2. [FilteredVisitor](#FilteredVisitor)\n\n4. [Visitor的各类实现](#implements)\n   1. [StreamVisitor](#StreamVisitor)\n   2. [FileVisitor](#FileVisitor)\n   3. [URLVisitor](#URLVisitor)\n   4. [KustomizeVisitor](#KustomizeVisitor)\n\n\n\n## visitor design pattern\n\n在设计模式中，访问者模式的定义为：\n\n> 允许一个或者多个操作应用到对象上，解耦操作和对象本身\n\n那么，对一个程序来说，具体的表现就是：\n\n1. 表面：某个对象执行了一个方法\n2. 内部：对象内部调用了多个方法，最后统一返回结果\n\n举个例子，\n\n1. 表面：调用一个查询订单的接口\n2. 内部：先从`缓存`中查询，没查到再去`热点数据库`查询，还没查到则去`归档数据库`里查询\n\n\n\n## Visitor \n\n我们来看看kubeadm中的`访问者模式`的定义：\n\n```go\n// Visitor 即为访问者这个对象\ntype Visitor interface {\n\tVisit(VisitorFunc) error\n}\n// VisitorFunc对应这个对象的方法，也就是定义中的“操作”\ntype VisitorFunc func(*Info, error) error\n```\n\n基本的数据结构很简单，但从当前的数据结构来看，有两个问题：\n\n1. `单个操作` 可以直接调用`Visit`方法，那`多个操作`如何实现呢？\n2. 在应用`多个操作`时，如果出现了error，该退出还是继续应用`下一个操作`呢？\n\n\n\n## Chained\n\n### VisitorList\n\n封装多个Visitor为一个，出现错误就立刻中止并返回\n\n```go\n// VisitorList定义为[]Visitor，又实现了Visit方法，也就是将多个[]Visitor封装为一个Visitor\ntype VisitorList []Visitor\n\n// 发生error就立刻返回，不继续遍历\nfunc (l VisitorList) Visit(fn VisitorFunc) error {\n\tfor i := range l {\n\t\tif err := l[i].Visit(fn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n\n\n### EagerVisitorList\n\n封装多个Visitor为一个，出现错误暂存下来，全部遍历完再聚合所有的错误并返回\n\n```go\n// EagerVisitorList 也是将多个[]Visitor封装为一个Visitor\ntype EagerVisitorList []Visitor\n\n// 返回的错误暂存到[]error中，统一聚合\nfunc (l EagerVisitorList) Visit(fn VisitorFunc) error {\n\terrs := []error(nil)\n\tfor i := range l {\n\t\tif err := l[i].Visit(func(info *Info, err error) error {\n\t\t\tif err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err := fn(info, nil); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\terrs = append(errs, err)\n\t\t}\n\t}\n\treturn utilerrors.NewAggregate(errs)\n}\n```\n\n\n\n### DecoratedVisitor\n\n这里借鉴了装饰器的设计模式，将一个Visitor调用多个VisitorFunc方法，封装为调用一个VisitorFunc\n\n```go\n// 装饰器Visitor\ntype DecoratedVisitor struct {\n\tvisitor    Visitor\n\tdecorators []VisitorFunc\n}\n\n// visitor遍历调用decorators中所有函数，有失败立即返回\nfunc (v DecoratedVisitor) Visit(fn VisitorFunc) error {\n\treturn v.visitor.Visit(func(info *Info, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := range v.decorators {\n\t\t\tif err := v.decorators[i](info, nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn fn(info, nil)\n\t})\n}\n```\n\n\n\n### ContinueOnErrorVisitor\n\n```go\n// 报错依旧继续\ntype ContinueOnErrorVisitor struct {\n\tVisitor\n}\n\n// 报错不立即返回，聚合所有错误后返回\nfunc (v ContinueOnErrorVisitor) Visit(fn VisitorFunc) error {\n\terrs := []error{}\n\terr := v.Visitor.Visit(func(info *Info, err error) error {\n\t\tif err != nil {\n\t\t\terrs = append(errs, err)\n\t\t\treturn nil\n\t\t}\n\t\tif err := fn(info, nil); err != nil {\n\t\t\terrs = append(errs, err)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\terrs = append(errs, err)\n\t}\n\tif len(errs) == 1 {\n\t\treturn errs[0]\n\t}\n\treturn utilerrors.NewAggregate(errs)\n}\n```\n\n\n\n## FlattenListVisitor\n\n将runtime.ObjectTyper解析成多个runtime.Object，再转换为多个Info，逐个调用VisitorFunc\n\n```go\ntype FlattenListVisitor struct {\n\tvisitor Visitor\n\ttyper   runtime.ObjectTyper\n\tmapper  *mapper\n}\n```\n\n\n\n### FilteredVisitor\n\n对Info资源的检验\n\n```go\n// 过滤的Info\ntype FilteredVisitor struct {\n\tvisitor Visitor\n\tfilters []FilterFunc\n}\n\nfunc (v FilteredVisitor) Visit(fn VisitorFunc) error {\n\treturn v.visitor.Visit(func(info *Info, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, filter := range v.filters {\n      // 检验Info是否满足条件，出错则退出\n\t\t\tok, err := filter(info, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn fn(info, nil)\n\t})\n}\n```\n\n\n\n## Implements\n\n### StreamVisitor\n\n最基础的Visitor\n\n```go\ntype StreamVisitor struct {\n  // 读取信息的来源，实现了Read这个接口，这个\"流式\"的概念，包括了常见的HTTP、文件、标准输入等各类输入\n\tio.Reader\n\t*mapper\n\n\tSource string\n\tSchema ContentValidator\n}\n```\n\n\n\n### FileVisitor\n\n文件的访问，包括标准输入，底层调用StreamVisitor来访问\n\n```go\ntype FileVisitor struct {\n  // 表示文件路径或者STDIN\n\tPath string\n\t*StreamVisitor\n}\n```\n\n\n\n### URLVisitor\n\nHTTP用GET方法获取数据，底层也是复用StreamVisitor\n\n```go\ntype URLVisitor struct {\n\tURL *url.URL\n\t*StreamVisitor\n  // 提供错误重试次数\n\tHttpAttemptCount int\n}\n```\n\n\n\n### KustomizeVisitor\n\n自定义的Visitor，针对自定义的文件系统\n\n```go\ntype KustomizeVisitor struct {\n\tPath string\n\t*StreamVisitor\n}\n```\n\n","source":"_posts/k8s-003.md","raw":"---\ntitle: 【K8s源码品读】003：Phase 1 - kubectl - 设计模式中Visitor的实现\ndate: 2021-02-18 16:55:50\ntags:\n---\n\n## 聚焦目标\n\n理解kubectl的核心实现之一：`Visitor Design Pattern` 访问者模式\n\n\n\n## 目录\n\n1. [什么是访问者模式](#visitor-design-pattern)\n\n2. [kubectl中的Visitor](#visitor)\n\n3. [Visitor的链式处理](#chained)\n   1. 多个对象聚合为一个对象\n      1. [VisitorList](#VisitorList)\n      2. [EagerVisitorList ](#EagerVisitorList)\n   2. 多个方法聚合为一个方法\n      1. [DecoratedVisitor](#DecoratedVisitor)\n      2. [ContinueOnErrorVisitor](#ContinueOnErrorVisitor)\n   3. 将对象抽象为多个底层对象，逐个调用方法\n      1. [FlattenListVisitor](#FlattenListVisitor)\n      2. [FilteredVisitor](#FilteredVisitor)\n\n4. [Visitor的各类实现](#implements)\n   1. [StreamVisitor](#StreamVisitor)\n   2. [FileVisitor](#FileVisitor)\n   3. [URLVisitor](#URLVisitor)\n   4. [KustomizeVisitor](#KustomizeVisitor)\n\n\n\n## visitor design pattern\n\n在设计模式中，访问者模式的定义为：\n\n> 允许一个或者多个操作应用到对象上，解耦操作和对象本身\n\n那么，对一个程序来说，具体的表现就是：\n\n1. 表面：某个对象执行了一个方法\n2. 内部：对象内部调用了多个方法，最后统一返回结果\n\n举个例子，\n\n1. 表面：调用一个查询订单的接口\n2. 内部：先从`缓存`中查询，没查到再去`热点数据库`查询，还没查到则去`归档数据库`里查询\n\n\n\n## Visitor \n\n我们来看看kubeadm中的`访问者模式`的定义：\n\n```go\n// Visitor 即为访问者这个对象\ntype Visitor interface {\n\tVisit(VisitorFunc) error\n}\n// VisitorFunc对应这个对象的方法，也就是定义中的“操作”\ntype VisitorFunc func(*Info, error) error\n```\n\n基本的数据结构很简单，但从当前的数据结构来看，有两个问题：\n\n1. `单个操作` 可以直接调用`Visit`方法，那`多个操作`如何实现呢？\n2. 在应用`多个操作`时，如果出现了error，该退出还是继续应用`下一个操作`呢？\n\n\n\n## Chained\n\n### VisitorList\n\n封装多个Visitor为一个，出现错误就立刻中止并返回\n\n```go\n// VisitorList定义为[]Visitor，又实现了Visit方法，也就是将多个[]Visitor封装为一个Visitor\ntype VisitorList []Visitor\n\n// 发生error就立刻返回，不继续遍历\nfunc (l VisitorList) Visit(fn VisitorFunc) error {\n\tfor i := range l {\n\t\tif err := l[i].Visit(fn); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n\n\n### EagerVisitorList\n\n封装多个Visitor为一个，出现错误暂存下来，全部遍历完再聚合所有的错误并返回\n\n```go\n// EagerVisitorList 也是将多个[]Visitor封装为一个Visitor\ntype EagerVisitorList []Visitor\n\n// 返回的错误暂存到[]error中，统一聚合\nfunc (l EagerVisitorList) Visit(fn VisitorFunc) error {\n\terrs := []error(nil)\n\tfor i := range l {\n\t\tif err := l[i].Visit(func(info *Info, err error) error {\n\t\t\tif err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err := fn(info, nil); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\terrs = append(errs, err)\n\t\t}\n\t}\n\treturn utilerrors.NewAggregate(errs)\n}\n```\n\n\n\n### DecoratedVisitor\n\n这里借鉴了装饰器的设计模式，将一个Visitor调用多个VisitorFunc方法，封装为调用一个VisitorFunc\n\n```go\n// 装饰器Visitor\ntype DecoratedVisitor struct {\n\tvisitor    Visitor\n\tdecorators []VisitorFunc\n}\n\n// visitor遍历调用decorators中所有函数，有失败立即返回\nfunc (v DecoratedVisitor) Visit(fn VisitorFunc) error {\n\treturn v.visitor.Visit(func(info *Info, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := range v.decorators {\n\t\t\tif err := v.decorators[i](info, nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn fn(info, nil)\n\t})\n}\n```\n\n\n\n### ContinueOnErrorVisitor\n\n```go\n// 报错依旧继续\ntype ContinueOnErrorVisitor struct {\n\tVisitor\n}\n\n// 报错不立即返回，聚合所有错误后返回\nfunc (v ContinueOnErrorVisitor) Visit(fn VisitorFunc) error {\n\terrs := []error{}\n\terr := v.Visitor.Visit(func(info *Info, err error) error {\n\t\tif err != nil {\n\t\t\terrs = append(errs, err)\n\t\t\treturn nil\n\t\t}\n\t\tif err := fn(info, nil); err != nil {\n\t\t\terrs = append(errs, err)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\terrs = append(errs, err)\n\t}\n\tif len(errs) == 1 {\n\t\treturn errs[0]\n\t}\n\treturn utilerrors.NewAggregate(errs)\n}\n```\n\n\n\n## FlattenListVisitor\n\n将runtime.ObjectTyper解析成多个runtime.Object，再转换为多个Info，逐个调用VisitorFunc\n\n```go\ntype FlattenListVisitor struct {\n\tvisitor Visitor\n\ttyper   runtime.ObjectTyper\n\tmapper  *mapper\n}\n```\n\n\n\n### FilteredVisitor\n\n对Info资源的检验\n\n```go\n// 过滤的Info\ntype FilteredVisitor struct {\n\tvisitor Visitor\n\tfilters []FilterFunc\n}\n\nfunc (v FilteredVisitor) Visit(fn VisitorFunc) error {\n\treturn v.visitor.Visit(func(info *Info, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, filter := range v.filters {\n      // 检验Info是否满足条件，出错则退出\n\t\t\tok, err := filter(info, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn fn(info, nil)\n\t})\n}\n```\n\n\n\n## Implements\n\n### StreamVisitor\n\n最基础的Visitor\n\n```go\ntype StreamVisitor struct {\n  // 读取信息的来源，实现了Read这个接口，这个\"流式\"的概念，包括了常见的HTTP、文件、标准输入等各类输入\n\tio.Reader\n\t*mapper\n\n\tSource string\n\tSchema ContentValidator\n}\n```\n\n\n\n### FileVisitor\n\n文件的访问，包括标准输入，底层调用StreamVisitor来访问\n\n```go\ntype FileVisitor struct {\n  // 表示文件路径或者STDIN\n\tPath string\n\t*StreamVisitor\n}\n```\n\n\n\n### URLVisitor\n\nHTTP用GET方法获取数据，底层也是复用StreamVisitor\n\n```go\ntype URLVisitor struct {\n\tURL *url.URL\n\t*StreamVisitor\n  // 提供错误重试次数\n\tHttpAttemptCount int\n}\n```\n\n\n\n### KustomizeVisitor\n\n自定义的Visitor，针对自定义的文件系统\n\n```go\ntype KustomizeVisitor struct {\n\tPath string\n\t*StreamVisitor\n}\n```\n\n","slug":"k8s-003","published":1,"updated":"2021-02-18T08:58:30.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaograi0002a4qpe5u78ksj","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解kubectl的核心实现之一：<code>Visitor Design Pattern</code> 访问者模式</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><p><a href=\"#visitor-design-pattern\">什么是访问者模式</a></p>\n</li>\n<li><p><a href=\"#visitor\">kubectl中的Visitor</a></p>\n</li>\n<li><p><a href=\"#chained\">Visitor的链式处理</a></p>\n<ol>\n<li>多个对象聚合为一个对象<ol>\n<li><a href=\"#VisitorList\">VisitorList</a></li>\n<li><a href=\"#EagerVisitorList\">EagerVisitorList </a></li>\n</ol>\n</li>\n<li>多个方法聚合为一个方法<ol>\n<li><a href=\"#DecoratedVisitor\">DecoratedVisitor</a></li>\n<li><a href=\"#ContinueOnErrorVisitor\">ContinueOnErrorVisitor</a></li>\n</ol>\n</li>\n<li>将对象抽象为多个底层对象，逐个调用方法<ol>\n<li><a href=\"#FlattenListVisitor\">FlattenListVisitor</a></li>\n<li><a href=\"#FilteredVisitor\">FilteredVisitor</a></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><a href=\"#implements\">Visitor的各类实现</a></p>\n<ol>\n<li><a href=\"#StreamVisitor\">StreamVisitor</a></li>\n<li><a href=\"#FileVisitor\">FileVisitor</a></li>\n<li><a href=\"#URLVisitor\">URLVisitor</a></li>\n<li><a href=\"#KustomizeVisitor\">KustomizeVisitor</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"visitor-design-pattern\"><a href=\"#visitor-design-pattern\" class=\"headerlink\" title=\"visitor design pattern\"></a>visitor design pattern</h2><p>在设计模式中，访问者模式的定义为：</p>\n<blockquote>\n<p>允许一个或者多个操作应用到对象上，解耦操作和对象本身</p>\n</blockquote>\n<p>那么，对一个程序来说，具体的表现就是：</p>\n<ol>\n<li>表面：某个对象执行了一个方法</li>\n<li>内部：对象内部调用了多个方法，最后统一返回结果</li>\n</ol>\n<p>举个例子，</p>\n<ol>\n<li>表面：调用一个查询订单的接口</li>\n<li>内部：先从<code>缓存</code>中查询，没查到再去<code>热点数据库</code>查询，还没查到则去<code>归档数据库</code>里查询</li>\n</ol>\n<h2 id=\"Visitor\"><a href=\"#Visitor\" class=\"headerlink\" title=\"Visitor\"></a>Visitor</h2><p>我们来看看kubeadm中的<code>访问者模式</code>的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Visitor 即为访问者这个对象</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Visitor <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tVisit(VisitorFunc) error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// VisitorFunc对应这个对象的方法，也就是定义中的“操作”</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> VisitorFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*Info, error)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>基本的数据结构很简单，但从当前的数据结构来看，有两个问题：</p>\n<ol>\n<li><code>单个操作</code> 可以直接调用<code>Visit</code>方法，那<code>多个操作</code>如何实现呢？</li>\n<li>在应用<code>多个操作</code>时，如果出现了error，该退出还是继续应用<code>下一个操作</code>呢？</li>\n</ol>\n<h2 id=\"Chained\"><a href=\"#Chained\" class=\"headerlink\" title=\"Chained\"></a>Chained</h2><h3 id=\"VisitorList\"><a href=\"#VisitorList\" class=\"headerlink\" title=\"VisitorList\"></a>VisitorList</h3><p>封装多个Visitor为一个，出现错误就立刻中止并返回</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VisitorList定义为[]Visitor，又实现了Visit方法，也就是将多个[]Visitor封装为一个Visitor</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> VisitorList []Visitor</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发生error就立刻返回，不继续遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l VisitorList)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := l[i].Visit(fn); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EagerVisitorList\"><a href=\"#EagerVisitorList\" class=\"headerlink\" title=\"EagerVisitorList\"></a>EagerVisitorList</h3><p>封装多个Visitor为一个，出现错误暂存下来，全部遍历完再聚合所有的错误并返回</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EagerVisitorList 也是将多个[]Visitor封装为一个Visitor</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> EagerVisitorList []Visitor</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回的错误暂存到[]error中，统一聚合</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l EagerVisitorList)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\terrs := []error(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := l[i].Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := fn(info, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> utilerrors.NewAggregate(errs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"DecoratedVisitor\"><a href=\"#DecoratedVisitor\" class=\"headerlink\" title=\"DecoratedVisitor\"></a>DecoratedVisitor</h3><p>这里借鉴了装饰器的设计模式，将一个Visitor调用多个VisitorFunc方法，封装为调用一个VisitorFunc</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 装饰器Visitor</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> DecoratedVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvisitor    Visitor</span><br><span class=\"line\">\tdecorators []VisitorFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// visitor遍历调用decorators中所有函数，有失败立即返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v DecoratedVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v.visitor.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> v.decorators &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := v.decorators[i](info, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fn(info, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ContinueOnErrorVisitor\"><a href=\"#ContinueOnErrorVisitor\" class=\"headerlink\" title=\"ContinueOnErrorVisitor\"></a>ContinueOnErrorVisitor</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错依旧继续</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ContinueOnErrorVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tVisitor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错不立即返回，聚合所有错误后返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v ContinueOnErrorVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\terrs := []error&#123;&#125;</span><br><span class=\"line\">\terr := v.Visitor.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := fn(info, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(errs) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> errs[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> utilerrors.NewAggregate(errs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"FlattenListVisitor\"><a href=\"#FlattenListVisitor\" class=\"headerlink\" title=\"FlattenListVisitor\"></a>FlattenListVisitor</h2><p>将runtime.ObjectTyper解析成多个runtime.Object，再转换为多个Info，逐个调用VisitorFunc</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FlattenListVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvisitor Visitor</span><br><span class=\"line\">\ttyper   runtime.ObjectTyper</span><br><span class=\"line\">\tmapper  *mapper</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FilteredVisitor\"><a href=\"#FilteredVisitor\" class=\"headerlink\" title=\"FilteredVisitor\"></a>FilteredVisitor</h3><p>对Info资源的检验</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 过滤的Info</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> FilteredVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvisitor Visitor</span><br><span class=\"line\">\tfilters []FilterFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v FilteredVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v.visitor.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, filter := <span class=\"keyword\">range</span> v.filters &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 检验Info是否满足条件，出错则退出</span></span><br><span class=\"line\">\t\t\tok, err := filter(info, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fn(info, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Implements\"><a href=\"#Implements\" class=\"headerlink\" title=\"Implements\"></a>Implements</h2><h3 id=\"StreamVisitor\"><a href=\"#StreamVisitor\" class=\"headerlink\" title=\"StreamVisitor\"></a>StreamVisitor</h3><p>最基础的Visitor</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> StreamVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 读取信息的来源，实现了Read这个接口，这个&quot;流式&quot;的概念，包括了常见的HTTP、文件、标准输入等各类输入</span></span><br><span class=\"line\">\tio.Reader</span><br><span class=\"line\">\t*mapper</span><br><span class=\"line\"></span><br><span class=\"line\">\tSource <span class=\"keyword\">string</span></span><br><span class=\"line\">\tSchema ContentValidator</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FileVisitor\"><a href=\"#FileVisitor\" class=\"headerlink\" title=\"FileVisitor\"></a>FileVisitor</h3><p>文件的访问，包括标准输入，底层调用StreamVisitor来访问</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FileVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 表示文件路径或者STDIN</span></span><br><span class=\"line\">\tPath <span class=\"keyword\">string</span></span><br><span class=\"line\">\t*StreamVisitor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"URLVisitor\"><a href=\"#URLVisitor\" class=\"headerlink\" title=\"URLVisitor\"></a>URLVisitor</h3><p>HTTP用GET方法获取数据，底层也是复用StreamVisitor</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> URLVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tURL *url.URL</span><br><span class=\"line\">\t*StreamVisitor</span><br><span class=\"line\">  <span class=\"comment\">// 提供错误重试次数</span></span><br><span class=\"line\">\tHttpAttemptCount <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"KustomizeVisitor\"><a href=\"#KustomizeVisitor\" class=\"headerlink\" title=\"KustomizeVisitor\"></a>KustomizeVisitor</h3><p>自定义的Visitor，针对自定义的文件系统</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> KustomizeVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tPath <span class=\"keyword\">string</span></span><br><span class=\"line\">\t*StreamVisitor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解kubectl的核心实现之一：<code>Visitor Design Pattern</code> 访问者模式</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><p><a href=\"#visitor-design-pattern\">什么是访问者模式</a></p>\n</li>\n<li><p><a href=\"#visitor\">kubectl中的Visitor</a></p>\n</li>\n<li><p><a href=\"#chained\">Visitor的链式处理</a></p>\n<ol>\n<li>多个对象聚合为一个对象<ol>\n<li><a href=\"#VisitorList\">VisitorList</a></li>\n<li><a href=\"#EagerVisitorList\">EagerVisitorList </a></li>\n</ol>\n</li>\n<li>多个方法聚合为一个方法<ol>\n<li><a href=\"#DecoratedVisitor\">DecoratedVisitor</a></li>\n<li><a href=\"#ContinueOnErrorVisitor\">ContinueOnErrorVisitor</a></li>\n</ol>\n</li>\n<li>将对象抽象为多个底层对象，逐个调用方法<ol>\n<li><a href=\"#FlattenListVisitor\">FlattenListVisitor</a></li>\n<li><a href=\"#FilteredVisitor\">FilteredVisitor</a></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><a href=\"#implements\">Visitor的各类实现</a></p>\n<ol>\n<li><a href=\"#StreamVisitor\">StreamVisitor</a></li>\n<li><a href=\"#FileVisitor\">FileVisitor</a></li>\n<li><a href=\"#URLVisitor\">URLVisitor</a></li>\n<li><a href=\"#KustomizeVisitor\">KustomizeVisitor</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"visitor-design-pattern\"><a href=\"#visitor-design-pattern\" class=\"headerlink\" title=\"visitor design pattern\"></a>visitor design pattern</h2><p>在设计模式中，访问者模式的定义为：</p>\n<blockquote>\n<p>允许一个或者多个操作应用到对象上，解耦操作和对象本身</p>\n</blockquote>\n<p>那么，对一个程序来说，具体的表现就是：</p>\n<ol>\n<li>表面：某个对象执行了一个方法</li>\n<li>内部：对象内部调用了多个方法，最后统一返回结果</li>\n</ol>\n<p>举个例子，</p>\n<ol>\n<li>表面：调用一个查询订单的接口</li>\n<li>内部：先从<code>缓存</code>中查询，没查到再去<code>热点数据库</code>查询，还没查到则去<code>归档数据库</code>里查询</li>\n</ol>\n<h2 id=\"Visitor\"><a href=\"#Visitor\" class=\"headerlink\" title=\"Visitor\"></a>Visitor</h2><p>我们来看看kubeadm中的<code>访问者模式</code>的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Visitor 即为访问者这个对象</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Visitor <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tVisit(VisitorFunc) error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// VisitorFunc对应这个对象的方法，也就是定义中的“操作”</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> VisitorFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*Info, error)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>基本的数据结构很简单，但从当前的数据结构来看，有两个问题：</p>\n<ol>\n<li><code>单个操作</code> 可以直接调用<code>Visit</code>方法，那<code>多个操作</code>如何实现呢？</li>\n<li>在应用<code>多个操作</code>时，如果出现了error，该退出还是继续应用<code>下一个操作</code>呢？</li>\n</ol>\n<h2 id=\"Chained\"><a href=\"#Chained\" class=\"headerlink\" title=\"Chained\"></a>Chained</h2><h3 id=\"VisitorList\"><a href=\"#VisitorList\" class=\"headerlink\" title=\"VisitorList\"></a>VisitorList</h3><p>封装多个Visitor为一个，出现错误就立刻中止并返回</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VisitorList定义为[]Visitor，又实现了Visit方法，也就是将多个[]Visitor封装为一个Visitor</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> VisitorList []Visitor</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发生error就立刻返回，不继续遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l VisitorList)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := l[i].Visit(fn); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EagerVisitorList\"><a href=\"#EagerVisitorList\" class=\"headerlink\" title=\"EagerVisitorList\"></a>EagerVisitorList</h3><p>封装多个Visitor为一个，出现错误暂存下来，全部遍历完再聚合所有的错误并返回</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EagerVisitorList 也是将多个[]Visitor封装为一个Visitor</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> EagerVisitorList []Visitor</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回的错误暂存到[]error中，统一聚合</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l EagerVisitorList)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\terrs := []error(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := l[i].Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := fn(info, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> utilerrors.NewAggregate(errs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"DecoratedVisitor\"><a href=\"#DecoratedVisitor\" class=\"headerlink\" title=\"DecoratedVisitor\"></a>DecoratedVisitor</h3><p>这里借鉴了装饰器的设计模式，将一个Visitor调用多个VisitorFunc方法，封装为调用一个VisitorFunc</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 装饰器Visitor</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> DecoratedVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvisitor    Visitor</span><br><span class=\"line\">\tdecorators []VisitorFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// visitor遍历调用decorators中所有函数，有失败立即返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v DecoratedVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v.visitor.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> v.decorators &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := v.decorators[i](info, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fn(info, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ContinueOnErrorVisitor\"><a href=\"#ContinueOnErrorVisitor\" class=\"headerlink\" title=\"ContinueOnErrorVisitor\"></a>ContinueOnErrorVisitor</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错依旧继续</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ContinueOnErrorVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tVisitor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错不立即返回，聚合所有错误后返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v ContinueOnErrorVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\terrs := []error&#123;&#125;</span><br><span class=\"line\">\terr := v.Visitor.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := fn(info, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terrs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(errs) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> errs[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> utilerrors.NewAggregate(errs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"FlattenListVisitor\"><a href=\"#FlattenListVisitor\" class=\"headerlink\" title=\"FlattenListVisitor\"></a>FlattenListVisitor</h2><p>将runtime.ObjectTyper解析成多个runtime.Object，再转换为多个Info，逐个调用VisitorFunc</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FlattenListVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvisitor Visitor</span><br><span class=\"line\">\ttyper   runtime.ObjectTyper</span><br><span class=\"line\">\tmapper  *mapper</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FilteredVisitor\"><a href=\"#FilteredVisitor\" class=\"headerlink\" title=\"FilteredVisitor\"></a>FilteredVisitor</h3><p>对Info资源的检验</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 过滤的Info</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> FilteredVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvisitor Visitor</span><br><span class=\"line\">\tfilters []FilterFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v FilteredVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v.visitor.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *Info, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, filter := <span class=\"keyword\">range</span> v.filters &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 检验Info是否满足条件，出错则退出</span></span><br><span class=\"line\">\t\t\tok, err := filter(info, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fn(info, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Implements\"><a href=\"#Implements\" class=\"headerlink\" title=\"Implements\"></a>Implements</h2><h3 id=\"StreamVisitor\"><a href=\"#StreamVisitor\" class=\"headerlink\" title=\"StreamVisitor\"></a>StreamVisitor</h3><p>最基础的Visitor</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> StreamVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 读取信息的来源，实现了Read这个接口，这个&quot;流式&quot;的概念，包括了常见的HTTP、文件、标准输入等各类输入</span></span><br><span class=\"line\">\tio.Reader</span><br><span class=\"line\">\t*mapper</span><br><span class=\"line\"></span><br><span class=\"line\">\tSource <span class=\"keyword\">string</span></span><br><span class=\"line\">\tSchema ContentValidator</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FileVisitor\"><a href=\"#FileVisitor\" class=\"headerlink\" title=\"FileVisitor\"></a>FileVisitor</h3><p>文件的访问，包括标准输入，底层调用StreamVisitor来访问</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FileVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 表示文件路径或者STDIN</span></span><br><span class=\"line\">\tPath <span class=\"keyword\">string</span></span><br><span class=\"line\">\t*StreamVisitor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"URLVisitor\"><a href=\"#URLVisitor\" class=\"headerlink\" title=\"URLVisitor\"></a>URLVisitor</h3><p>HTTP用GET方法获取数据，底层也是复用StreamVisitor</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> URLVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tURL *url.URL</span><br><span class=\"line\">\t*StreamVisitor</span><br><span class=\"line\">  <span class=\"comment\">// 提供错误重试次数</span></span><br><span class=\"line\">\tHttpAttemptCount <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"KustomizeVisitor\"><a href=\"#KustomizeVisitor\" class=\"headerlink\" title=\"KustomizeVisitor\"></a>KustomizeVisitor</h3><p>自定义的Visitor，针对自定义的文件系统</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> KustomizeVisitor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tPath <span class=\"keyword\">string</span></span><br><span class=\"line\">\t*StreamVisitor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"【K8s源码品读】004：Phase 1 - kubectl - 发送创建Pod请求的实现细节","date":"2021-02-18T08:55:51.000Z","_content":"\n## 聚焦目标\n\n理解kubectl是怎么向kube-apiserver发送请求的\n\n\n\n## 目录\n\n1. [向kube-apiserver发送请求](#send-request)\n2. [RESTful客户端是怎么创建的](#RESTful-client)\n3. [Object是怎么生成的](#object)\n4. [发送post请求](#post)\n5. [kubectl第一阶段源码阅读总结](#summary)\n\n\n\n## send request\n\n```go\n// 在RunCreate函数中，关键的发送函数\nobj, err := resource.\n\t\t\t\tNewHelper(info.Client, info.Mapping).\n\t\t\t\tDryRun(o.DryRunStrategy == cmdutil.DryRunServer).\n\t\t\t\tWithFieldManager(o.fieldManager).\n\t\t\t\tCreate(info.Namespace, true, info.Object)\n\n// 进入create函数，查看到\nm.createResource(m.RESTClient, m.Resource, namespace, obj, options)\n\n// 对应的实现为\nfunc (m *Helper) createResource(c RESTClient, resource, namespace string, obj runtime.Object, options *metav1.CreateOptions) (runtime.Object, error) {\n\treturn c.Post().\n\t\tNamespaceIfScoped(namespace, m.NamespaceScoped).\n\t\tResource(resource).\n\t\tVersionedParams(options, metav1.ParameterCodec).\n\t\tBody(obj).\n\t\tDo(context.TODO()).\n\t\tGet()\n}\n\n/*\n\n到这里，我们发现了2个关键性的定义:\n1. RESTClient 与kube-apiserver交互的RESTful风格的客户端\n2. runtime.Object 资源对象的抽象，包括Pod/Deployment/Service等各类资源\n\n*/\n```\n\n\n\n## RESTful Client\n\n我们先来看看，与kube-apiserver交互的Client是怎么创建的\n\n```go\n// 从传入参数来看，数据来源于Info这个结构\nr.Visit(func(info *resource.Info, err error) error{})\n\n// 而info来源于前面的Builder，前面部分都是将Builder参数化，核心的生成为Do函数\nr := f.NewBuilder().\n\t\tUnstructured().\n\t\tSchema(schema).\n\t\tContinueOnError().\n\t\tNamespaceParam(cmdNamespace).DefaultNamespace().\n\t\tFilenameParam(enforceNamespace, &o.FilenameOptions).\n\t\tLabelSelectorParam(o.Selector).\n\t\tFlatten().\n\t\tDo()\n\n// 大致看一下这些函数，我们可以在Unstructured()中看到getClient函数，其实这就是我们要找的函数\nfunc (b *Builder) getClient(gv schema.GroupVersion) (RESTClient, error) \n\n// 从返回值来看，client包括默认的REST client和配置选项\nNewClientWithOptions(client, b.requestTransforms...)\n\n// 这个Client会在kubernetes项目中大量出现，它是与kube-apiserver交互的核心组件，以后再深入。\n```\n\n\n\n## Object\n\n`Object`这个对象是怎么获取到的呢？因为我们的数据源是来自文件的，那么我们最直观的想法就是`FileVisitor`\n\n```go\nfunc (v *FileVisitor) Visit(fn VisitorFunc) error {\n\t// 省略读取这块的代码，底层调用的是StreamVisitor的逻辑\n\treturn v.StreamVisitor.Visit(fn)\n}\n\nfunc (v *StreamVisitor) Visit(fn VisitorFunc) error {\n\td := yaml.NewYAMLOrJSONDecoder(v.Reader, 4096)\n\tfor {\n\t\t// 这里就是返回info的地方\n\t\tinfo, err := v.infoForData(ext.Raw, v.Source)\n  }\n}\n\n// 再往下一层看，来到mapper层，也就是kubernetes的资源对象映射关系\nfunc (m *mapper) infoForData(data []byte, source string) (*Info, error){\n  // 这里就是我们返回Object的地方，其中GVK是Group/Version/Kind的缩写，后续我们会涉及\n  obj, gvk, err := m.decoder.Decode(data, nil, nil)\n}\n```\n\n\n\n这时，我们想回头去看，这个mapper是在什么时候被定义的？\n\n```go\n// 在Builder初始化中，我们就找到了\nfunc (b *Builder) Unstructured() *Builder {\n\tb.mapper = &mapper{\n\t\tlocalFn:      b.isLocal,\n\t\trestMapperFn: b.restMapperFn,\n\t\tclientFn:     b.getClient,\n    // 我们查找资源用到的是这个decoder\n\t\tdecoder:      &metadataValidatingDecoder{unstructured.UnstructuredJSONScheme},\n\t}\n\treturn b\n}\n\n// 逐层往下找，对应的Decode方法的实现，就是对应的数据解析成data：\nfunc (s unstructuredJSONScheme) decode(data []byte) (runtime.Object, error) {\n\t// 细节暂时忽略\n}\n```\n\n\n\n## Post\n\n了解了`REST Client`和`Object`的大致产生逻辑后，我们再回过头来看发送的方法\n\n```go\n// RESTful接口风格中，POST请求对应的就是CREATE方法\nc.Post().\n\t\tNamespaceIfScoped(namespace, m.NamespaceScoped).\n\t\tResource(resource).\n\t\tVersionedParams(options, metav1.ParameterCodec).\n\t\tBody(obj).\n\t\tDo(context.TODO()). \n\t\tGet() \n\n// Do方法，发送请求\nerr := r.request(ctx, func(req *http.Request, resp *http.Response) {\n\t\tresult = r.transformResponse(resp, req)\n\t})\n\n// Get方法，获取请求的返回结果，用来打印状态\nswitch t := out.(type) {\n\tcase *metav1.Status:\n\t\tif t.Status != metav1.StatusSuccess {\n\t\t\treturn nil, errors.FromObject(t)\n\t\t}\n\t}\n```\n\n\n\n## Summary\n\n到这里我们对kubectl的功能有了初步的了解，希望大家对以下的关键内容有所掌握：\n\n1. 命令行采用了`cobra`库，主要支持7个大类的命令；\n2. 掌握Visitor设计模式，这个是kubectl实现各类资源对象的解析和校验的核心；\n3. 初步了解`RESTClient`和`Object`这两个对象，它们是贯穿kubernetes的核心概念；\n4. 调用逻辑\n   1. cobra匹配子命令\n   2. 用Visitor模式构建Builder\n   3. 用RESTClient将Object发送到kube-apiserver","source":"_posts/k8s-004.md","raw":"---\ntitle: 【K8s源码品读】004：Phase 1 - kubectl - 发送创建Pod请求的实现细节\ndate: 2021-02-18 16:55:51\ntags:\n---\n\n## 聚焦目标\n\n理解kubectl是怎么向kube-apiserver发送请求的\n\n\n\n## 目录\n\n1. [向kube-apiserver发送请求](#send-request)\n2. [RESTful客户端是怎么创建的](#RESTful-client)\n3. [Object是怎么生成的](#object)\n4. [发送post请求](#post)\n5. [kubectl第一阶段源码阅读总结](#summary)\n\n\n\n## send request\n\n```go\n// 在RunCreate函数中，关键的发送函数\nobj, err := resource.\n\t\t\t\tNewHelper(info.Client, info.Mapping).\n\t\t\t\tDryRun(o.DryRunStrategy == cmdutil.DryRunServer).\n\t\t\t\tWithFieldManager(o.fieldManager).\n\t\t\t\tCreate(info.Namespace, true, info.Object)\n\n// 进入create函数，查看到\nm.createResource(m.RESTClient, m.Resource, namespace, obj, options)\n\n// 对应的实现为\nfunc (m *Helper) createResource(c RESTClient, resource, namespace string, obj runtime.Object, options *metav1.CreateOptions) (runtime.Object, error) {\n\treturn c.Post().\n\t\tNamespaceIfScoped(namespace, m.NamespaceScoped).\n\t\tResource(resource).\n\t\tVersionedParams(options, metav1.ParameterCodec).\n\t\tBody(obj).\n\t\tDo(context.TODO()).\n\t\tGet()\n}\n\n/*\n\n到这里，我们发现了2个关键性的定义:\n1. RESTClient 与kube-apiserver交互的RESTful风格的客户端\n2. runtime.Object 资源对象的抽象，包括Pod/Deployment/Service等各类资源\n\n*/\n```\n\n\n\n## RESTful Client\n\n我们先来看看，与kube-apiserver交互的Client是怎么创建的\n\n```go\n// 从传入参数来看，数据来源于Info这个结构\nr.Visit(func(info *resource.Info, err error) error{})\n\n// 而info来源于前面的Builder，前面部分都是将Builder参数化，核心的生成为Do函数\nr := f.NewBuilder().\n\t\tUnstructured().\n\t\tSchema(schema).\n\t\tContinueOnError().\n\t\tNamespaceParam(cmdNamespace).DefaultNamespace().\n\t\tFilenameParam(enforceNamespace, &o.FilenameOptions).\n\t\tLabelSelectorParam(o.Selector).\n\t\tFlatten().\n\t\tDo()\n\n// 大致看一下这些函数，我们可以在Unstructured()中看到getClient函数，其实这就是我们要找的函数\nfunc (b *Builder) getClient(gv schema.GroupVersion) (RESTClient, error) \n\n// 从返回值来看，client包括默认的REST client和配置选项\nNewClientWithOptions(client, b.requestTransforms...)\n\n// 这个Client会在kubernetes项目中大量出现，它是与kube-apiserver交互的核心组件，以后再深入。\n```\n\n\n\n## Object\n\n`Object`这个对象是怎么获取到的呢？因为我们的数据源是来自文件的，那么我们最直观的想法就是`FileVisitor`\n\n```go\nfunc (v *FileVisitor) Visit(fn VisitorFunc) error {\n\t// 省略读取这块的代码，底层调用的是StreamVisitor的逻辑\n\treturn v.StreamVisitor.Visit(fn)\n}\n\nfunc (v *StreamVisitor) Visit(fn VisitorFunc) error {\n\td := yaml.NewYAMLOrJSONDecoder(v.Reader, 4096)\n\tfor {\n\t\t// 这里就是返回info的地方\n\t\tinfo, err := v.infoForData(ext.Raw, v.Source)\n  }\n}\n\n// 再往下一层看，来到mapper层，也就是kubernetes的资源对象映射关系\nfunc (m *mapper) infoForData(data []byte, source string) (*Info, error){\n  // 这里就是我们返回Object的地方，其中GVK是Group/Version/Kind的缩写，后续我们会涉及\n  obj, gvk, err := m.decoder.Decode(data, nil, nil)\n}\n```\n\n\n\n这时，我们想回头去看，这个mapper是在什么时候被定义的？\n\n```go\n// 在Builder初始化中，我们就找到了\nfunc (b *Builder) Unstructured() *Builder {\n\tb.mapper = &mapper{\n\t\tlocalFn:      b.isLocal,\n\t\trestMapperFn: b.restMapperFn,\n\t\tclientFn:     b.getClient,\n    // 我们查找资源用到的是这个decoder\n\t\tdecoder:      &metadataValidatingDecoder{unstructured.UnstructuredJSONScheme},\n\t}\n\treturn b\n}\n\n// 逐层往下找，对应的Decode方法的实现，就是对应的数据解析成data：\nfunc (s unstructuredJSONScheme) decode(data []byte) (runtime.Object, error) {\n\t// 细节暂时忽略\n}\n```\n\n\n\n## Post\n\n了解了`REST Client`和`Object`的大致产生逻辑后，我们再回过头来看发送的方法\n\n```go\n// RESTful接口风格中，POST请求对应的就是CREATE方法\nc.Post().\n\t\tNamespaceIfScoped(namespace, m.NamespaceScoped).\n\t\tResource(resource).\n\t\tVersionedParams(options, metav1.ParameterCodec).\n\t\tBody(obj).\n\t\tDo(context.TODO()). \n\t\tGet() \n\n// Do方法，发送请求\nerr := r.request(ctx, func(req *http.Request, resp *http.Response) {\n\t\tresult = r.transformResponse(resp, req)\n\t})\n\n// Get方法，获取请求的返回结果，用来打印状态\nswitch t := out.(type) {\n\tcase *metav1.Status:\n\t\tif t.Status != metav1.StatusSuccess {\n\t\t\treturn nil, errors.FromObject(t)\n\t\t}\n\t}\n```\n\n\n\n## Summary\n\n到这里我们对kubectl的功能有了初步的了解，希望大家对以下的关键内容有所掌握：\n\n1. 命令行采用了`cobra`库，主要支持7个大类的命令；\n2. 掌握Visitor设计模式，这个是kubectl实现各类资源对象的解析和校验的核心；\n3. 初步了解`RESTClient`和`Object`这两个对象，它们是贯穿kubernetes的核心概念；\n4. 调用逻辑\n   1. cobra匹配子命令\n   2. 用Visitor模式构建Builder\n   3. 用RESTClient将Object发送到kube-apiserver","slug":"k8s-004","published":1,"updated":"2021-02-18T08:58:44.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaograj0003a4qp11dzh6br","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解kubectl是怎么向kube-apiserver发送请求的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#send-request\">向kube-apiserver发送请求</a></li>\n<li><a href=\"#RESTful-client\">RESTful客户端是怎么创建的</a></li>\n<li><a href=\"#object\">Object是怎么生成的</a></li>\n<li><a href=\"#post\">发送post请求</a></li>\n<li><a href=\"#summary\">kubectl第一阶段源码阅读总结</a></li>\n</ol>\n<h2 id=\"send-request\"><a href=\"#send-request\" class=\"headerlink\" title=\"send request\"></a>send request</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在RunCreate函数中，关键的发送函数</span></span><br><span class=\"line\">obj, err := resource.</span><br><span class=\"line\">\t\t\t\tNewHelper(info.Client, info.Mapping).</span><br><span class=\"line\">\t\t\t\tDryRun(o.DryRunStrategy == cmdutil.DryRunServer).</span><br><span class=\"line\">\t\t\t\tWithFieldManager(o.fieldManager).</span><br><span class=\"line\">\t\t\t\tCreate(info.Namespace, <span class=\"literal\">true</span>, info.Object)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进入create函数，查看到</span></span><br><span class=\"line\">m.createResource(m.RESTClient, m.Resource, namespace, obj, options)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应的实现为</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Helper)</span> <span class=\"title\">createResource</span><span class=\"params\">(c RESTClient, resource, namespace <span class=\"keyword\">string</span>, obj runtime.Object, options *metav1.CreateOptions)</span> <span class=\"params\">(runtime.Object, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.Post().</span><br><span class=\"line\">\t\tNamespaceIfScoped(namespace, m.NamespaceScoped).</span><br><span class=\"line\">\t\tResource(resource).</span><br><span class=\"line\">\t\tVersionedParams(options, metav1.ParameterCodec).</span><br><span class=\"line\">\t\tBody(obj).</span><br><span class=\"line\">\t\tDo(context.TODO()).</span><br><span class=\"line\">\t\tGet()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">到这里，我们发现了2个关键性的定义:</span></span><br><span class=\"line\"><span class=\"comment\">1. RESTClient 与kube-apiserver交互的RESTful风格的客户端</span></span><br><span class=\"line\"><span class=\"comment\">2. runtime.Object 资源对象的抽象，包括Pod/Deployment/Service等各类资源</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"RESTful-Client\"><a href=\"#RESTful-Client\" class=\"headerlink\" title=\"RESTful Client\"></a>RESTful Client</h2><p>我们先来看看，与kube-apiserver交互的Client是怎么创建的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从传入参数来看，数据来源于Info这个结构</span></span><br><span class=\"line\">r.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *resource.Info, err error)</span> <span class=\"title\">error</span></span>&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而info来源于前面的Builder，前面部分都是将Builder参数化，核心的生成为Do函数</span></span><br><span class=\"line\">r := f.NewBuilder().</span><br><span class=\"line\">\t\tUnstructured().</span><br><span class=\"line\">\t\tSchema(schema).</span><br><span class=\"line\">\t\tContinueOnError().</span><br><span class=\"line\">\t\tNamespaceParam(cmdNamespace).DefaultNamespace().</span><br><span class=\"line\">\t\tFilenameParam(enforceNamespace, &amp;o.FilenameOptions).</span><br><span class=\"line\">\t\tLabelSelectorParam(o.Selector).</span><br><span class=\"line\">\t\tFlatten().</span><br><span class=\"line\">\t\tDo()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大致看一下这些函数，我们可以在Unstructured()中看到getClient函数，其实这就是我们要找的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Builder)</span> <span class=\"title\">getClient</span><span class=\"params\">(gv schema.GroupVersion)</span> <span class=\"params\">(RESTClient, error)</span></span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从返回值来看，client包括默认的REST client和配置选项</span></span><br><span class=\"line\">NewClientWithOptions(client, b.requestTransforms...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个Client会在kubernetes项目中大量出现，它是与kube-apiserver交互的核心组件，以后再深入。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><p><code>Object</code>这个对象是怎么获取到的呢？因为我们的数据源是来自文件的，那么我们最直观的想法就是<code>FileVisitor</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *FileVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 省略读取这块的代码，底层调用的是StreamVisitor的逻辑</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v.StreamVisitor.Visit(fn)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *StreamVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\td := yaml.NewYAMLOrJSONDecoder(v.Reader, <span class=\"number\">4096</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 这里就是返回info的地方</span></span><br><span class=\"line\">\t\tinfo, err := v.infoForData(ext.Raw, v.Source)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再往下一层看，来到mapper层，也就是kubernetes的资源对象映射关系</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *mapper)</span> <span class=\"title\">infoForData</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>, source <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Info, error)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里就是我们返回Object的地方，其中GVK是Group/Version/Kind的缩写，后续我们会涉及</span></span><br><span class=\"line\">  obj, gvk, err := m.decoder.Decode(data, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时，我们想回头去看，这个mapper是在什么时候被定义的？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在Builder初始化中，我们就找到了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Builder)</span> <span class=\"title\">Unstructured</span><span class=\"params\">()</span> *<span class=\"title\">Builder</span></span> &#123;</span><br><span class=\"line\">\tb.mapper = &amp;mapper&#123;</span><br><span class=\"line\">\t\tlocalFn:      b.isLocal,</span><br><span class=\"line\">\t\trestMapperFn: b.restMapperFn,</span><br><span class=\"line\">\t\tclientFn:     b.getClient,</span><br><span class=\"line\">    <span class=\"comment\">// 我们查找资源用到的是这个decoder</span></span><br><span class=\"line\">\t\tdecoder:      &amp;metadataValidatingDecoder&#123;unstructured.UnstructuredJSONScheme&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 逐层往下找，对应的Decode方法的实现，就是对应的数据解析成data：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s unstructuredJSONScheme)</span> <span class=\"title\">decode</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(runtime.Object, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 细节暂时忽略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Post\"><a href=\"#Post\" class=\"headerlink\" title=\"Post\"></a>Post</h2><p>了解了<code>REST Client</code>和<code>Object</code>的大致产生逻辑后，我们再回过头来看发送的方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RESTful接口风格中，POST请求对应的就是CREATE方法</span></span><br><span class=\"line\">c.Post().</span><br><span class=\"line\">\t\tNamespaceIfScoped(namespace, m.NamespaceScoped).</span><br><span class=\"line\">\t\tResource(resource).</span><br><span class=\"line\">\t\tVersionedParams(options, metav1.ParameterCodec).</span><br><span class=\"line\">\t\tBody(obj).</span><br><span class=\"line\">\t\tDo(context.TODO()). </span><br><span class=\"line\">\t\tGet() </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Do方法，发送请求</span></span><br><span class=\"line\">err := r.request(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(req *http.Request, resp *http.Response)</span></span> &#123;</span><br><span class=\"line\">\t\tresult = r.transformResponse(resp, req)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get方法，获取请求的返回结果，用来打印状态</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> t := out.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> *metav1.Status:</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Status != metav1.StatusSuccess &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, errors.FromObject(t)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>到这里我们对kubectl的功能有了初步的了解，希望大家对以下的关键内容有所掌握：</p>\n<ol>\n<li>命令行采用了<code>cobra</code>库，主要支持7个大类的命令；</li>\n<li>掌握Visitor设计模式，这个是kubectl实现各类资源对象的解析和校验的核心；</li>\n<li>初步了解<code>RESTClient</code>和<code>Object</code>这两个对象，它们是贯穿kubernetes的核心概念；</li>\n<li>调用逻辑<ol>\n<li>cobra匹配子命令</li>\n<li>用Visitor模式构建Builder</li>\n<li>用RESTClient将Object发送到kube-apiserver</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解kubectl是怎么向kube-apiserver发送请求的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#send-request\">向kube-apiserver发送请求</a></li>\n<li><a href=\"#RESTful-client\">RESTful客户端是怎么创建的</a></li>\n<li><a href=\"#object\">Object是怎么生成的</a></li>\n<li><a href=\"#post\">发送post请求</a></li>\n<li><a href=\"#summary\">kubectl第一阶段源码阅读总结</a></li>\n</ol>\n<h2 id=\"send-request\"><a href=\"#send-request\" class=\"headerlink\" title=\"send request\"></a>send request</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在RunCreate函数中，关键的发送函数</span></span><br><span class=\"line\">obj, err := resource.</span><br><span class=\"line\">\t\t\t\tNewHelper(info.Client, info.Mapping).</span><br><span class=\"line\">\t\t\t\tDryRun(o.DryRunStrategy == cmdutil.DryRunServer).</span><br><span class=\"line\">\t\t\t\tWithFieldManager(o.fieldManager).</span><br><span class=\"line\">\t\t\t\tCreate(info.Namespace, <span class=\"literal\">true</span>, info.Object)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进入create函数，查看到</span></span><br><span class=\"line\">m.createResource(m.RESTClient, m.Resource, namespace, obj, options)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应的实现为</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Helper)</span> <span class=\"title\">createResource</span><span class=\"params\">(c RESTClient, resource, namespace <span class=\"keyword\">string</span>, obj runtime.Object, options *metav1.CreateOptions)</span> <span class=\"params\">(runtime.Object, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.Post().</span><br><span class=\"line\">\t\tNamespaceIfScoped(namespace, m.NamespaceScoped).</span><br><span class=\"line\">\t\tResource(resource).</span><br><span class=\"line\">\t\tVersionedParams(options, metav1.ParameterCodec).</span><br><span class=\"line\">\t\tBody(obj).</span><br><span class=\"line\">\t\tDo(context.TODO()).</span><br><span class=\"line\">\t\tGet()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">到这里，我们发现了2个关键性的定义:</span></span><br><span class=\"line\"><span class=\"comment\">1. RESTClient 与kube-apiserver交互的RESTful风格的客户端</span></span><br><span class=\"line\"><span class=\"comment\">2. runtime.Object 资源对象的抽象，包括Pod/Deployment/Service等各类资源</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"RESTful-Client\"><a href=\"#RESTful-Client\" class=\"headerlink\" title=\"RESTful Client\"></a>RESTful Client</h2><p>我们先来看看，与kube-apiserver交互的Client是怎么创建的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从传入参数来看，数据来源于Info这个结构</span></span><br><span class=\"line\">r.Visit(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info *resource.Info, err error)</span> <span class=\"title\">error</span></span>&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而info来源于前面的Builder，前面部分都是将Builder参数化，核心的生成为Do函数</span></span><br><span class=\"line\">r := f.NewBuilder().</span><br><span class=\"line\">\t\tUnstructured().</span><br><span class=\"line\">\t\tSchema(schema).</span><br><span class=\"line\">\t\tContinueOnError().</span><br><span class=\"line\">\t\tNamespaceParam(cmdNamespace).DefaultNamespace().</span><br><span class=\"line\">\t\tFilenameParam(enforceNamespace, &amp;o.FilenameOptions).</span><br><span class=\"line\">\t\tLabelSelectorParam(o.Selector).</span><br><span class=\"line\">\t\tFlatten().</span><br><span class=\"line\">\t\tDo()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大致看一下这些函数，我们可以在Unstructured()中看到getClient函数，其实这就是我们要找的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Builder)</span> <span class=\"title\">getClient</span><span class=\"params\">(gv schema.GroupVersion)</span> <span class=\"params\">(RESTClient, error)</span></span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从返回值来看，client包括默认的REST client和配置选项</span></span><br><span class=\"line\">NewClientWithOptions(client, b.requestTransforms...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个Client会在kubernetes项目中大量出现，它是与kube-apiserver交互的核心组件，以后再深入。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><p><code>Object</code>这个对象是怎么获取到的呢？因为我们的数据源是来自文件的，那么我们最直观的想法就是<code>FileVisitor</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *FileVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 省略读取这块的代码，底层调用的是StreamVisitor的逻辑</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v.StreamVisitor.Visit(fn)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *StreamVisitor)</span> <span class=\"title\">Visit</span><span class=\"params\">(fn VisitorFunc)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\td := yaml.NewYAMLOrJSONDecoder(v.Reader, <span class=\"number\">4096</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 这里就是返回info的地方</span></span><br><span class=\"line\">\t\tinfo, err := v.infoForData(ext.Raw, v.Source)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再往下一层看，来到mapper层，也就是kubernetes的资源对象映射关系</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *mapper)</span> <span class=\"title\">infoForData</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>, source <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Info, error)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里就是我们返回Object的地方，其中GVK是Group/Version/Kind的缩写，后续我们会涉及</span></span><br><span class=\"line\">  obj, gvk, err := m.decoder.Decode(data, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时，我们想回头去看，这个mapper是在什么时候被定义的？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在Builder初始化中，我们就找到了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Builder)</span> <span class=\"title\">Unstructured</span><span class=\"params\">()</span> *<span class=\"title\">Builder</span></span> &#123;</span><br><span class=\"line\">\tb.mapper = &amp;mapper&#123;</span><br><span class=\"line\">\t\tlocalFn:      b.isLocal,</span><br><span class=\"line\">\t\trestMapperFn: b.restMapperFn,</span><br><span class=\"line\">\t\tclientFn:     b.getClient,</span><br><span class=\"line\">    <span class=\"comment\">// 我们查找资源用到的是这个decoder</span></span><br><span class=\"line\">\t\tdecoder:      &amp;metadataValidatingDecoder&#123;unstructured.UnstructuredJSONScheme&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 逐层往下找，对应的Decode方法的实现，就是对应的数据解析成data：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s unstructuredJSONScheme)</span> <span class=\"title\">decode</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(runtime.Object, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 细节暂时忽略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Post\"><a href=\"#Post\" class=\"headerlink\" title=\"Post\"></a>Post</h2><p>了解了<code>REST Client</code>和<code>Object</code>的大致产生逻辑后，我们再回过头来看发送的方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RESTful接口风格中，POST请求对应的就是CREATE方法</span></span><br><span class=\"line\">c.Post().</span><br><span class=\"line\">\t\tNamespaceIfScoped(namespace, m.NamespaceScoped).</span><br><span class=\"line\">\t\tResource(resource).</span><br><span class=\"line\">\t\tVersionedParams(options, metav1.ParameterCodec).</span><br><span class=\"line\">\t\tBody(obj).</span><br><span class=\"line\">\t\tDo(context.TODO()). </span><br><span class=\"line\">\t\tGet() </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Do方法，发送请求</span></span><br><span class=\"line\">err := r.request(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(req *http.Request, resp *http.Response)</span></span> &#123;</span><br><span class=\"line\">\t\tresult = r.transformResponse(resp, req)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get方法，获取请求的返回结果，用来打印状态</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> t := out.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> *metav1.Status:</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Status != metav1.StatusSuccess &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, errors.FromObject(t)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>到这里我们对kubectl的功能有了初步的了解，希望大家对以下的关键内容有所掌握：</p>\n<ol>\n<li>命令行采用了<code>cobra</code>库，主要支持7个大类的命令；</li>\n<li>掌握Visitor设计模式，这个是kubectl实现各类资源对象的解析和校验的核心；</li>\n<li>初步了解<code>RESTClient</code>和<code>Object</code>这两个对象，它们是贯穿kubernetes的核心概念；</li>\n<li>调用逻辑<ol>\n<li>cobra匹配子命令</li>\n<li>用Visitor模式构建Builder</li>\n<li>用RESTClient将Object发送到kube-apiserver</li>\n</ol>\n</li>\n</ol>\n"},{"title":"【K8s源码品读】005：Phase 1 - kube-apiserver 权限相关的三个核心概念","date":"2021-02-18T08:55:51.000Z","_content":"\n## 聚焦目标\n\n理解启动kube-apiserver的权限相关的三个核心概念 `Authentication`/`Authorization`/`Admission`\n\n\n\n## 目录\n\n1. [kube-apiserver的启动](#run)\n2. [kube-apiserver的三个Server](#three-servers)\n3. [KubeAPIServer的创建过程](#KubeAPIServer)\n   1. [通用配置概况](#GenericConfig)\n   2. [通用配置中的认证](#Authentication)\n   3. [通用配置中的授权](#Authorization)\n   4. [通用配置中的准入机制](#Admission)\n\n\n\n## Run\n\n```go\n// 类似kubectl的源代码，kube-apiserver的命令行工具也使用了cobra，我们很快就能找到启动的入口\nRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t// 这里包含2个参数，前者是参数completedOptions，后者是一个stopCh <-chan struct{}\n\t\t\treturn Run(completedOptions, genericapiserver.SetupSignalHandler())\n\t\t}\n\n/*\n\t在这里，我们可以和kubectl结合起来思考：\n\tkubectl是一个命令行工具，执行完命令就退出；kube-apiserver是一个常驻的服务器进程，监听端口\n\t这里引入了一个stopCh <-chan struct{}，可以在启动后，用一个 <-stopCh 作为阻塞，使程序不退出\n\t用channel阻塞进程退出，对比传统的方法 - 用一个永不退出的for循环，是一个很优雅的实现\n*/\n```\n\n\n\n## Three Servers\n\n```go\n// 在CreateServerChain这个函数下，创建了3个server\nfunc CreateServerChain(){\n  // API扩展服务，主要针对CRD\n\tcreateAPIExtensionsServer(){} \n  // API核心服务，包括常见的Pod/Deployment/Service，我们今天的重点聚焦在这里\n  // 我会跳过很多非核心的配置参数，一开始就去研究细节，很影响整体代码的阅读效率\n\tCreateKubeAPIServer(){} \n  // API聚合服务，主要针对metrics\n\tcreateAggregatorServer(){} \n}\n```\n\n\n\n## KubeAPIServer\n\n```go\n// 创建配置的流程\nfunc CreateKubeAPIServerConfig(){\n  // 创建通用配置genericConfig\n  genericConfig, versionedInformers, insecureServingInfo, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory, err := buildGenericConfig(s.ServerRunOptions, proxyTransport)\n}\n```\n\n\n\n### GenericConfig\n\n```go\n// 通用配置的创建\nfunc buildGenericConfig(s *options.ServerRunOptions,proxyTransport *http.Transport){\n  // Insecure对应的非安全的通信，也就是HTTP\n  if lastErr = s.InsecureServing...\n  // Secure对应的就是HTTPS\n  if lastErr = s.SecureServing...\n  // OpenAPIConfig是对外提供的API文档\n  genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig()\n  // 这一块是storageFactory的实例化，可以看到采用的是etcd作为存储方案\n  storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()\n\tstorageFactoryConfig.APIResourceConfig = genericConfig.MergedResourceConfig\n\tcompletedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)\n\tstorageFactory, lastErr = completedStorageFactoryConfig.New()\n  // Authentication 认证相关\n  if lastErr = s.Authentication.ApplyTo()...\n  // Authorization 授权相关\n  genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer()\n  // Admission 准入机制\n  err = s.Admission.ApplyTo()\n}\n```\n\n\n\n### Authentication\n\n```go\nfunc (o *BuiltInAuthenticationOptions) ApplyTo(){\n  // 前面都是对认证config进行参数设置，这里才是真正的实例化\n  authInfo.Authenticator, openAPIConfig.SecurityDefinitions, err = authenticatorConfig.New()\n}\n\n// New这块的代码，我们要抓住核心变量authenticators和tokenAuthenticators，也就是各种认证方法\nfunc (config Config) New() (authenticator.Request, *spec.SecurityDefinitions, error) {\n  // 核心变量authenticators和tokenAuthenticators\n\tvar authenticators []authenticator.Request\n  var tokenAuthenticators []authenticator.Token\n\n\tif config.RequestHeaderConfig != nil {\n\t\t// 1. 添加requestHeader\n\t\tauthenticators = append(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, requestHeaderAuthenticator))\n\t}\n\n\tif config.ClientCAContentProvider != nil {\n\t\t// 2. 添加ClientCA\n    authenticators = append(authenticators, certAuth)\n\t}\n\n\tif len(config.TokenAuthFile) > 0 {\n\t\t// 3. token 添加tokenfile\n\t\ttokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))\n\t}\n  \n  // 4. token 添加 service account，分两种来源\n\tif len(config.ServiceAccountKeyFiles) > 0 {\n\t\ttokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)\n\t}\n\tif utilfeature.DefaultFeatureGate.Enabled(features.TokenRequest) && config.ServiceAccountIssuer != \"\" {\n\t\ttokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)\n\t}\n\tif config.BootstrapToken {\n\t\tif config.BootstrapTokenAuthenticator != nil {\n      // 5. token 添加 bootstrap\n\t\t\ttokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, config.BootstrapTokenAuthenticator))\n\t\t}\n\t}\n\n\tif len(config.OIDCIssuerURL) > 0 && len(config.OIDCClientID) > 0 {\n\t\t// 6. token 添加 oidc\n    Authenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, oidcAuth))\n\t}\n\tif len(config.WebhookTokenAuthnConfigFile) > 0 {\n\t\t// 7. token 添加 webhook\n\t\ttokenAuthenticators = append(tokenAuthenticators, webhookTokenAuth)\n\t}\n\n  // 8. 组合tokenAuthenticators到tokenAuthenticators中\n\tif len(tokenAuthenticators) > 0 {\n\t\ttokenAuth := tokenunion.New(tokenAuthenticators...)\n\t\tif config.TokenSuccessCacheTTL > 0 || config.TokenFailureCacheTTL > 0 {\n\t\t\ttokenAuth = tokencache.New(tokenAuth, true, config.TokenSuccessCacheTTL, config.TokenFailureCacheTTL)\n\t\t}\n\t\tauthenticators = append(authenticators, bearertoken.New(tokenAuth), websocket.NewProtocolAuthenticator(tokenAuth))\n\t}\n\n  // 9. 没有任何认证方式且启用了Anonymous\n\tif len(authenticators) == 0 {\n\t\tif config.Anonymous {\n\t\t\treturn anonymous.NewAuthenticator(), &securityDefinitions, nil\n\t\t}\n\t\treturn nil, &securityDefinitions, nil\n\t}\n\n  // 10. 组合authenticators\n\tauthenticator := union.New(authenticators...)\n\n\treturn authenticator, &securityDefinitions, nil\n}\n```\n\n复杂的Authentication模块的初始化顺序我们看完了，有初步的了解即可，没必要去强制记忆其中的加载顺序。\n\n\n\n### Authorization\n\n```go\nfunc BuildAuthorizer(){\n  // 与上面一致，实例化是在这个New中\n  return authorizationConfig.New()\n}\n\n// 不得不说，Authorizer这块的阅读体验更好\nfunc (config Config) New() (authorizer.Authorizer, authorizer.RuleResolver, error) {\n  // 必须传入一个Authorizer机制\n\tif len(config.AuthorizationModes) == 0 {\n\t\treturn nil, nil, fmt.Errorf(\"at least one authorization mode must be passed\")\n\t}\n\n\tvar (\n\t\tauthorizers   []authorizer.Authorizer\n\t\truleResolvers []authorizer.RuleResolver\n\t)\n\n\tfor _, authorizationMode := range config.AuthorizationModes {\n\t\t// 具体的mode定义，可以跳转到对应的链接去看，今天不细讲\n\t\tswitch authorizationMode {\n\t\tcase modes.ModeNode:\n\t\t\tauthorizers = append(authorizers, nodeAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, nodeAuthorizer)\n\n\t\tcase modes.ModeAlwaysAllow:\n\t\t\tauthorizers = append(authorizers, alwaysAllowAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, alwaysAllowAuthorizer)\n      \n\t\tcase modes.ModeAlwaysDeny:\n\t\t\tauthorizers = append(authorizers, alwaysDenyAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, alwaysDenyAuthorizer)\n      \n\t\tcase modes.ModeABAC:\n\t\t\tauthorizers = append(authorizers, abacAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, abacAuthorizer)\n      \n\t\tcase modes.ModeWebhook:\n\t\t\tauthorizers = append(authorizers, webhookAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, webhookAuthorizer)\n      \n\t\tcase modes.ModeRBAC:\n\t\t\tauthorizers = append(authorizers, rbacAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, rbacAuthorizer)\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(\"unknown authorization mode %s specified\", authorizationMode)\n\t\t}\n\t}\n\n\treturn union.New(authorizers...), union.NewRuleResolvers(ruleResolvers...), nil\n}\n\nconst (\n\t// ModeAlwaysAllow is the mode to set all requests as authorized\n\tModeAlwaysAllow string = \"AlwaysAllow\"\n\t// ModeAlwaysDeny is the mode to set no requests as authorized\n\tModeAlwaysDeny string = \"AlwaysDeny\"\n\t// ModeABAC is the mode to use Attribute Based Access Control to authorize\n\tModeABAC string = \"ABAC\"\n\t// ModeWebhook is the mode to make an external webhook call to authorize\n\tModeWebhook string = \"Webhook\"\n\t// ModeRBAC is the mode to use Role Based Access Control to authorize\n\tModeRBAC string = \"RBAC\"\n\t// ModeNode is an authorization mode that authorizes API requests made by kubelets.\n\tModeNode string = \"Node\"\n)\n```\n\n\n\n### Admission\n\n```go\n// 查看定义\nerr = s.Admission.ApplyTo()\nfunc (a *AdmissionOptions) ApplyTo(){\n  return a.GenericAdmission.ApplyTo()\n}\n\nfunc (ps *Plugins) NewFromPlugins(){\n  for _, pluginName := range pluginNames {\n\t\t// InitPlugin 为初始化的工作\n\t\tplugin, err := ps.InitPlugin(pluginName, pluginConfig, pluginInitializer)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n}\n\nfunc (ps *Plugins) InitPlugin(name string, config io.Reader, pluginInitializer PluginInitializer) (Interface, error){\n  // 获取plugin\n  plugin, found, err := ps.getPlugin(name, config)\n}\n\n// 查看一下Interface的定义，就是对准入机制的控制\n// Interface is an abstract, pluggable interface for Admission Control decisions.\ntype Interface interface {\n\tHandles(operation Operation) bool\n}\n\n// 再去看看获取plugin的地方\nfunc (ps *Plugins) getPlugin(name string, config io.Reader) (Interface, bool, error) {\n\tps.lock.Lock()\n\tdefer ps.lock.Unlock()\n  // 我们再去研究ps.registry这个参数是在哪里被初始化的\n\tf, found := ps.registry[name]\n}\n\n// 接下来，我们从kube-apiserver启动过程，逐步找到Admission被初始化的地方\n// 启动命令\ncommand := app.NewAPIServerCommand()\n// server配置\ns := options.NewServerRunOptions()\n// admission选项\nAdmission:               kubeoptions.NewAdmissionOptions()\n// 注册准入机制\nRegisterAllAdmissionPlugins(options.Plugins)\n// 准入机制的所有内容\nfunc RegisterAllAdmissionPlugins(plugins *admission.Plugins){\n  // 这里有很多plugin的注册\n}\n\n// 往上翻，我们能找到所有plugin，也就是准入机制的定义\nvar AllOrderedPlugins = []string{\n\tadmit.PluginName,                        // AlwaysAdmit\n\tautoprovision.PluginName,                // NamespaceAutoProvision\n\tlifecycle.PluginName,                    // NamespaceLifecycle\n\texists.PluginName,                       // NamespaceExists\n\tscdeny.PluginName,                       // SecurityContextDeny\n\tantiaffinity.PluginName,                 // LimitPodHardAntiAffinityTopology\n\tpodpreset.PluginName,                    // PodPreset\n\tlimitranger.PluginName,                  // LimitRanger\n\tserviceaccount.PluginName,               // ServiceAccount\n\tnoderestriction.PluginName,              // NodeRestriction\n\tnodetaint.PluginName,                    // TaintNodesByCondition\n\talwayspullimages.PluginName,             // AlwaysPullImages\n\timagepolicy.PluginName,                  // ImagePolicyWebhook\n\tpodsecuritypolicy.PluginName,            // PodSecurityPolicy\n\tpodnodeselector.PluginName,              // PodNodeSelector\n\tpodpriority.PluginName,                  // Priority\n\tdefaulttolerationseconds.PluginName,     // DefaultTolerationSeconds\n\tpodtolerationrestriction.PluginName,     // PodTolerationRestriction\n\texec.DenyEscalatingExec,                 // DenyEscalatingExec\n\texec.DenyExecOnPrivileged,               // DenyExecOnPrivileged\n\teventratelimit.PluginName,               // EventRateLimit\n\textendedresourcetoleration.PluginName,   // ExtendedResourceToleration\n\tlabel.PluginName,                        // PersistentVolumeLabel\n\tsetdefault.PluginName,                   // DefaultStorageClass\n\tstorageobjectinuseprotection.PluginName, // StorageObjectInUseProtection\n\tgc.PluginName,                           // OwnerReferencesPermissionEnforcement\n\tresize.PluginName,                       // PersistentVolumeClaimResize\n\truntimeclass.PluginName,                 // RuntimeClass\n\tcertapproval.PluginName,                 // CertificateApproval\n\tcertsigning.PluginName,                  // CertificateSigning\n\tcertsubjectrestriction.PluginName,       // CertificateSubjectRestriction\n\tdefaultingressclass.PluginName,          // DefaultIngressClass\n\n\t// new admission plugins should generally be inserted above here\n\t// webhook, resourcequota, and deny plugins must go at the end\n\n\tmutatingwebhook.PluginName,   // MutatingAdmissionWebhook\n\tvalidatingwebhook.PluginName, // ValidatingAdmissionWebhook\n\tresourcequota.PluginName,     // ResourceQuota\n\tdeny.PluginName,              // AlwaysDeny\n}\n```\n\n","source":"_posts/k8s-005.md","raw":"---\ntitle: 【K8s源码品读】005：Phase 1 - kube-apiserver 权限相关的三个核心概念\ndate: 2021-02-18 16:55:51\ntags:\n---\n\n## 聚焦目标\n\n理解启动kube-apiserver的权限相关的三个核心概念 `Authentication`/`Authorization`/`Admission`\n\n\n\n## 目录\n\n1. [kube-apiserver的启动](#run)\n2. [kube-apiserver的三个Server](#three-servers)\n3. [KubeAPIServer的创建过程](#KubeAPIServer)\n   1. [通用配置概况](#GenericConfig)\n   2. [通用配置中的认证](#Authentication)\n   3. [通用配置中的授权](#Authorization)\n   4. [通用配置中的准入机制](#Admission)\n\n\n\n## Run\n\n```go\n// 类似kubectl的源代码，kube-apiserver的命令行工具也使用了cobra，我们很快就能找到启动的入口\nRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t// 这里包含2个参数，前者是参数completedOptions，后者是一个stopCh <-chan struct{}\n\t\t\treturn Run(completedOptions, genericapiserver.SetupSignalHandler())\n\t\t}\n\n/*\n\t在这里，我们可以和kubectl结合起来思考：\n\tkubectl是一个命令行工具，执行完命令就退出；kube-apiserver是一个常驻的服务器进程，监听端口\n\t这里引入了一个stopCh <-chan struct{}，可以在启动后，用一个 <-stopCh 作为阻塞，使程序不退出\n\t用channel阻塞进程退出，对比传统的方法 - 用一个永不退出的for循环，是一个很优雅的实现\n*/\n```\n\n\n\n## Three Servers\n\n```go\n// 在CreateServerChain这个函数下，创建了3个server\nfunc CreateServerChain(){\n  // API扩展服务，主要针对CRD\n\tcreateAPIExtensionsServer(){} \n  // API核心服务，包括常见的Pod/Deployment/Service，我们今天的重点聚焦在这里\n  // 我会跳过很多非核心的配置参数，一开始就去研究细节，很影响整体代码的阅读效率\n\tCreateKubeAPIServer(){} \n  // API聚合服务，主要针对metrics\n\tcreateAggregatorServer(){} \n}\n```\n\n\n\n## KubeAPIServer\n\n```go\n// 创建配置的流程\nfunc CreateKubeAPIServerConfig(){\n  // 创建通用配置genericConfig\n  genericConfig, versionedInformers, insecureServingInfo, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory, err := buildGenericConfig(s.ServerRunOptions, proxyTransport)\n}\n```\n\n\n\n### GenericConfig\n\n```go\n// 通用配置的创建\nfunc buildGenericConfig(s *options.ServerRunOptions,proxyTransport *http.Transport){\n  // Insecure对应的非安全的通信，也就是HTTP\n  if lastErr = s.InsecureServing...\n  // Secure对应的就是HTTPS\n  if lastErr = s.SecureServing...\n  // OpenAPIConfig是对外提供的API文档\n  genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig()\n  // 这一块是storageFactory的实例化，可以看到采用的是etcd作为存储方案\n  storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()\n\tstorageFactoryConfig.APIResourceConfig = genericConfig.MergedResourceConfig\n\tcompletedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)\n\tstorageFactory, lastErr = completedStorageFactoryConfig.New()\n  // Authentication 认证相关\n  if lastErr = s.Authentication.ApplyTo()...\n  // Authorization 授权相关\n  genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer()\n  // Admission 准入机制\n  err = s.Admission.ApplyTo()\n}\n```\n\n\n\n### Authentication\n\n```go\nfunc (o *BuiltInAuthenticationOptions) ApplyTo(){\n  // 前面都是对认证config进行参数设置，这里才是真正的实例化\n  authInfo.Authenticator, openAPIConfig.SecurityDefinitions, err = authenticatorConfig.New()\n}\n\n// New这块的代码，我们要抓住核心变量authenticators和tokenAuthenticators，也就是各种认证方法\nfunc (config Config) New() (authenticator.Request, *spec.SecurityDefinitions, error) {\n  // 核心变量authenticators和tokenAuthenticators\n\tvar authenticators []authenticator.Request\n  var tokenAuthenticators []authenticator.Token\n\n\tif config.RequestHeaderConfig != nil {\n\t\t// 1. 添加requestHeader\n\t\tauthenticators = append(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, requestHeaderAuthenticator))\n\t}\n\n\tif config.ClientCAContentProvider != nil {\n\t\t// 2. 添加ClientCA\n    authenticators = append(authenticators, certAuth)\n\t}\n\n\tif len(config.TokenAuthFile) > 0 {\n\t\t// 3. token 添加tokenfile\n\t\ttokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))\n\t}\n  \n  // 4. token 添加 service account，分两种来源\n\tif len(config.ServiceAccountKeyFiles) > 0 {\n\t\ttokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)\n\t}\n\tif utilfeature.DefaultFeatureGate.Enabled(features.TokenRequest) && config.ServiceAccountIssuer != \"\" {\n\t\ttokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)\n\t}\n\tif config.BootstrapToken {\n\t\tif config.BootstrapTokenAuthenticator != nil {\n      // 5. token 添加 bootstrap\n\t\t\ttokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, config.BootstrapTokenAuthenticator))\n\t\t}\n\t}\n\n\tif len(config.OIDCIssuerURL) > 0 && len(config.OIDCClientID) > 0 {\n\t\t// 6. token 添加 oidc\n    Authenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, oidcAuth))\n\t}\n\tif len(config.WebhookTokenAuthnConfigFile) > 0 {\n\t\t// 7. token 添加 webhook\n\t\ttokenAuthenticators = append(tokenAuthenticators, webhookTokenAuth)\n\t}\n\n  // 8. 组合tokenAuthenticators到tokenAuthenticators中\n\tif len(tokenAuthenticators) > 0 {\n\t\ttokenAuth := tokenunion.New(tokenAuthenticators...)\n\t\tif config.TokenSuccessCacheTTL > 0 || config.TokenFailureCacheTTL > 0 {\n\t\t\ttokenAuth = tokencache.New(tokenAuth, true, config.TokenSuccessCacheTTL, config.TokenFailureCacheTTL)\n\t\t}\n\t\tauthenticators = append(authenticators, bearertoken.New(tokenAuth), websocket.NewProtocolAuthenticator(tokenAuth))\n\t}\n\n  // 9. 没有任何认证方式且启用了Anonymous\n\tif len(authenticators) == 0 {\n\t\tif config.Anonymous {\n\t\t\treturn anonymous.NewAuthenticator(), &securityDefinitions, nil\n\t\t}\n\t\treturn nil, &securityDefinitions, nil\n\t}\n\n  // 10. 组合authenticators\n\tauthenticator := union.New(authenticators...)\n\n\treturn authenticator, &securityDefinitions, nil\n}\n```\n\n复杂的Authentication模块的初始化顺序我们看完了，有初步的了解即可，没必要去强制记忆其中的加载顺序。\n\n\n\n### Authorization\n\n```go\nfunc BuildAuthorizer(){\n  // 与上面一致，实例化是在这个New中\n  return authorizationConfig.New()\n}\n\n// 不得不说，Authorizer这块的阅读体验更好\nfunc (config Config) New() (authorizer.Authorizer, authorizer.RuleResolver, error) {\n  // 必须传入一个Authorizer机制\n\tif len(config.AuthorizationModes) == 0 {\n\t\treturn nil, nil, fmt.Errorf(\"at least one authorization mode must be passed\")\n\t}\n\n\tvar (\n\t\tauthorizers   []authorizer.Authorizer\n\t\truleResolvers []authorizer.RuleResolver\n\t)\n\n\tfor _, authorizationMode := range config.AuthorizationModes {\n\t\t// 具体的mode定义，可以跳转到对应的链接去看，今天不细讲\n\t\tswitch authorizationMode {\n\t\tcase modes.ModeNode:\n\t\t\tauthorizers = append(authorizers, nodeAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, nodeAuthorizer)\n\n\t\tcase modes.ModeAlwaysAllow:\n\t\t\tauthorizers = append(authorizers, alwaysAllowAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, alwaysAllowAuthorizer)\n      \n\t\tcase modes.ModeAlwaysDeny:\n\t\t\tauthorizers = append(authorizers, alwaysDenyAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, alwaysDenyAuthorizer)\n      \n\t\tcase modes.ModeABAC:\n\t\t\tauthorizers = append(authorizers, abacAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, abacAuthorizer)\n      \n\t\tcase modes.ModeWebhook:\n\t\t\tauthorizers = append(authorizers, webhookAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, webhookAuthorizer)\n      \n\t\tcase modes.ModeRBAC:\n\t\t\tauthorizers = append(authorizers, rbacAuthorizer)\n\t\t\truleResolvers = append(ruleResolvers, rbacAuthorizer)\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(\"unknown authorization mode %s specified\", authorizationMode)\n\t\t}\n\t}\n\n\treturn union.New(authorizers...), union.NewRuleResolvers(ruleResolvers...), nil\n}\n\nconst (\n\t// ModeAlwaysAllow is the mode to set all requests as authorized\n\tModeAlwaysAllow string = \"AlwaysAllow\"\n\t// ModeAlwaysDeny is the mode to set no requests as authorized\n\tModeAlwaysDeny string = \"AlwaysDeny\"\n\t// ModeABAC is the mode to use Attribute Based Access Control to authorize\n\tModeABAC string = \"ABAC\"\n\t// ModeWebhook is the mode to make an external webhook call to authorize\n\tModeWebhook string = \"Webhook\"\n\t// ModeRBAC is the mode to use Role Based Access Control to authorize\n\tModeRBAC string = \"RBAC\"\n\t// ModeNode is an authorization mode that authorizes API requests made by kubelets.\n\tModeNode string = \"Node\"\n)\n```\n\n\n\n### Admission\n\n```go\n// 查看定义\nerr = s.Admission.ApplyTo()\nfunc (a *AdmissionOptions) ApplyTo(){\n  return a.GenericAdmission.ApplyTo()\n}\n\nfunc (ps *Plugins) NewFromPlugins(){\n  for _, pluginName := range pluginNames {\n\t\t// InitPlugin 为初始化的工作\n\t\tplugin, err := ps.InitPlugin(pluginName, pluginConfig, pluginInitializer)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n}\n\nfunc (ps *Plugins) InitPlugin(name string, config io.Reader, pluginInitializer PluginInitializer) (Interface, error){\n  // 获取plugin\n  plugin, found, err := ps.getPlugin(name, config)\n}\n\n// 查看一下Interface的定义，就是对准入机制的控制\n// Interface is an abstract, pluggable interface for Admission Control decisions.\ntype Interface interface {\n\tHandles(operation Operation) bool\n}\n\n// 再去看看获取plugin的地方\nfunc (ps *Plugins) getPlugin(name string, config io.Reader) (Interface, bool, error) {\n\tps.lock.Lock()\n\tdefer ps.lock.Unlock()\n  // 我们再去研究ps.registry这个参数是在哪里被初始化的\n\tf, found := ps.registry[name]\n}\n\n// 接下来，我们从kube-apiserver启动过程，逐步找到Admission被初始化的地方\n// 启动命令\ncommand := app.NewAPIServerCommand()\n// server配置\ns := options.NewServerRunOptions()\n// admission选项\nAdmission:               kubeoptions.NewAdmissionOptions()\n// 注册准入机制\nRegisterAllAdmissionPlugins(options.Plugins)\n// 准入机制的所有内容\nfunc RegisterAllAdmissionPlugins(plugins *admission.Plugins){\n  // 这里有很多plugin的注册\n}\n\n// 往上翻，我们能找到所有plugin，也就是准入机制的定义\nvar AllOrderedPlugins = []string{\n\tadmit.PluginName,                        // AlwaysAdmit\n\tautoprovision.PluginName,                // NamespaceAutoProvision\n\tlifecycle.PluginName,                    // NamespaceLifecycle\n\texists.PluginName,                       // NamespaceExists\n\tscdeny.PluginName,                       // SecurityContextDeny\n\tantiaffinity.PluginName,                 // LimitPodHardAntiAffinityTopology\n\tpodpreset.PluginName,                    // PodPreset\n\tlimitranger.PluginName,                  // LimitRanger\n\tserviceaccount.PluginName,               // ServiceAccount\n\tnoderestriction.PluginName,              // NodeRestriction\n\tnodetaint.PluginName,                    // TaintNodesByCondition\n\talwayspullimages.PluginName,             // AlwaysPullImages\n\timagepolicy.PluginName,                  // ImagePolicyWebhook\n\tpodsecuritypolicy.PluginName,            // PodSecurityPolicy\n\tpodnodeselector.PluginName,              // PodNodeSelector\n\tpodpriority.PluginName,                  // Priority\n\tdefaulttolerationseconds.PluginName,     // DefaultTolerationSeconds\n\tpodtolerationrestriction.PluginName,     // PodTolerationRestriction\n\texec.DenyEscalatingExec,                 // DenyEscalatingExec\n\texec.DenyExecOnPrivileged,               // DenyExecOnPrivileged\n\teventratelimit.PluginName,               // EventRateLimit\n\textendedresourcetoleration.PluginName,   // ExtendedResourceToleration\n\tlabel.PluginName,                        // PersistentVolumeLabel\n\tsetdefault.PluginName,                   // DefaultStorageClass\n\tstorageobjectinuseprotection.PluginName, // StorageObjectInUseProtection\n\tgc.PluginName,                           // OwnerReferencesPermissionEnforcement\n\tresize.PluginName,                       // PersistentVolumeClaimResize\n\truntimeclass.PluginName,                 // RuntimeClass\n\tcertapproval.PluginName,                 // CertificateApproval\n\tcertsigning.PluginName,                  // CertificateSigning\n\tcertsubjectrestriction.PluginName,       // CertificateSubjectRestriction\n\tdefaultingressclass.PluginName,          // DefaultIngressClass\n\n\t// new admission plugins should generally be inserted above here\n\t// webhook, resourcequota, and deny plugins must go at the end\n\n\tmutatingwebhook.PluginName,   // MutatingAdmissionWebhook\n\tvalidatingwebhook.PluginName, // ValidatingAdmissionWebhook\n\tresourcequota.PluginName,     // ResourceQuota\n\tdeny.PluginName,              // AlwaysDeny\n}\n```\n\n","slug":"k8s-005","published":1,"updated":"2021-02-18T08:59:03.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaograk0004a4qp142929s8","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解启动kube-apiserver的权限相关的三个核心概念 <code>Authentication</code>/<code>Authorization</code>/<code>Admission</code></p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#run\">kube-apiserver的启动</a></li>\n<li><a href=\"#three-servers\">kube-apiserver的三个Server</a></li>\n<li><a href=\"#KubeAPIServer\">KubeAPIServer的创建过程</a><ol>\n<li><a href=\"#GenericConfig\">通用配置概况</a></li>\n<li><a href=\"#Authentication\">通用配置中的认证</a></li>\n<li><a href=\"#Authorization\">通用配置中的授权</a></li>\n<li><a href=\"#Admission\">通用配置中的准入机制</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类似kubectl的源代码，kube-apiserver的命令行工具也使用了cobra，我们很快就能找到启动的入口</span></span><br><span class=\"line\">RunE: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 这里包含2个参数，前者是参数completedOptions，后者是一个stopCh &lt;-chan struct&#123;&#125;</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Run(completedOptions, genericapiserver.SetupSignalHandler())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t在这里，我们可以和kubectl结合起来思考：</span></span><br><span class=\"line\"><span class=\"comment\">\tkubectl是一个命令行工具，执行完命令就退出；kube-apiserver是一个常驻的服务器进程，监听端口</span></span><br><span class=\"line\"><span class=\"comment\">\t这里引入了一个stopCh &lt;-chan struct&#123;&#125;，可以在启动后，用一个 &lt;-stopCh 作为阻塞，使程序不退出</span></span><br><span class=\"line\"><span class=\"comment\">\t用channel阻塞进程退出，对比传统的方法 - 用一个永不退出的for循环，是一个很优雅的实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Three-Servers\"><a href=\"#Three-Servers\" class=\"headerlink\" title=\"Three Servers\"></a>Three Servers</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在CreateServerChain这个函数下，创建了3个server</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CreateServerChain</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// API扩展服务，主要针对CRD</span></span><br><span class=\"line\">\tcreateAPIExtensionsServer()&#123;&#125; </span><br><span class=\"line\">  <span class=\"comment\">// API核心服务，包括常见的Pod/Deployment/Service，我们今天的重点聚焦在这里</span></span><br><span class=\"line\">  <span class=\"comment\">// 我会跳过很多非核心的配置参数，一开始就去研究细节，很影响整体代码的阅读效率</span></span><br><span class=\"line\">\tCreateKubeAPIServer()&#123;&#125; </span><br><span class=\"line\">  <span class=\"comment\">// API聚合服务，主要针对metrics</span></span><br><span class=\"line\">\tcreateAggregatorServer()&#123;&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"KubeAPIServer\"><a href=\"#KubeAPIServer\" class=\"headerlink\" title=\"KubeAPIServer\"></a>KubeAPIServer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建配置的流程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CreateKubeAPIServerConfig</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建通用配置genericConfig</span></span><br><span class=\"line\">  genericConfig, versionedInformers, insecureServingInfo, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory, err := buildGenericConfig(s.ServerRunOptions, proxyTransport)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GenericConfig\"><a href=\"#GenericConfig\" class=\"headerlink\" title=\"GenericConfig\"></a>GenericConfig</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通用配置的创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildGenericConfig</span><span class=\"params\">(s *options.ServerRunOptions,proxyTransport *http.Transport)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Insecure对应的非安全的通信，也就是HTTP</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> lastErr = s.InsecureServing...</span><br><span class=\"line\">  <span class=\"comment\">// Secure对应的就是HTTPS</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> lastErr = s.SecureServing...</span><br><span class=\"line\">  <span class=\"comment\">// OpenAPIConfig是对外提供的API文档</span></span><br><span class=\"line\">  genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig()</span><br><span class=\"line\">  <span class=\"comment\">// 这一块是storageFactory的实例化，可以看到采用的是etcd作为存储方案</span></span><br><span class=\"line\">  storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()</span><br><span class=\"line\">\tstorageFactoryConfig.APIResourceConfig = genericConfig.MergedResourceConfig</span><br><span class=\"line\">\tcompletedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)</span><br><span class=\"line\">\tstorageFactory, lastErr = completedStorageFactoryConfig.New()</span><br><span class=\"line\">  <span class=\"comment\">// Authentication 认证相关</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> lastErr = s.Authentication.ApplyTo()...</span><br><span class=\"line\">  <span class=\"comment\">// Authorization 授权相关</span></span><br><span class=\"line\">  genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer()</span><br><span class=\"line\">  <span class=\"comment\">// Admission 准入机制</span></span><br><span class=\"line\">  err = s.Admission.ApplyTo()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Authentication\"><a href=\"#Authentication\" class=\"headerlink\" title=\"Authentication\"></a>Authentication</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(o *BuiltInAuthenticationOptions)</span> <span class=\"title\">ApplyTo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 前面都是对认证config进行参数设置，这里才是真正的实例化</span></span><br><span class=\"line\">  authInfo.Authenticator, openAPIConfig.SecurityDefinitions, err = authenticatorConfig.New()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New这块的代码，我们要抓住核心变量authenticators和tokenAuthenticators，也就是各种认证方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(config Config)</span> <span class=\"title\">New</span><span class=\"params\">()</span> <span class=\"params\">(authenticator.Request, *spec.SecurityDefinitions, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 核心变量authenticators和tokenAuthenticators</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> authenticators []authenticator.Request</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tokenAuthenticators []authenticator.Token</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> config.RequestHeaderConfig != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 1. 添加requestHeader</span></span><br><span class=\"line\">\t\tauthenticators = <span class=\"built_in\">append</span>(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, requestHeaderAuthenticator))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> config.ClientCAContentProvider != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 2. 添加ClientCA</span></span><br><span class=\"line\">    authenticators = <span class=\"built_in\">append</span>(authenticators, certAuth)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.TokenAuthFile) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 3. token 添加tokenfile</span></span><br><span class=\"line\">\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 4. token 添加 service account，分两种来源</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.ServiceAccountKeyFiles) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, serviceAccountAuth)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> utilfeature.DefaultFeatureGate.Enabled(features.TokenRequest) &amp;&amp; config.ServiceAccountIssuer != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, serviceAccountAuth)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> config.BootstrapToken &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> config.BootstrapTokenAuthenticator != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 5. token 添加 bootstrap</span></span><br><span class=\"line\">\t\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, config.BootstrapTokenAuthenticator))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.OIDCIssuerURL) &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">len</span>(config.OIDCClientID) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 6. token 添加 oidc</span></span><br><span class=\"line\">    Authenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, oidcAuth))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.WebhookTokenAuthnConfigFile) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 7. token 添加 webhook</span></span><br><span class=\"line\">\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, webhookTokenAuth)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 8. 组合tokenAuthenticators到tokenAuthenticators中</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(tokenAuthenticators) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\ttokenAuth := tokenunion.New(tokenAuthenticators...)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> config.TokenSuccessCacheTTL &gt; <span class=\"number\">0</span> || config.TokenFailureCacheTTL &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ttokenAuth = tokencache.New(tokenAuth, <span class=\"literal\">true</span>, config.TokenSuccessCacheTTL, config.TokenFailureCacheTTL)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tauthenticators = <span class=\"built_in\">append</span>(authenticators, bearertoken.New(tokenAuth), websocket.NewProtocolAuthenticator(tokenAuth))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 9. 没有任何认证方式且启用了Anonymous</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(authenticators) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> config.Anonymous &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> anonymous.NewAuthenticator(), &amp;securityDefinitions, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, &amp;securityDefinitions, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 10. 组合authenticators</span></span><br><span class=\"line\">\tauthenticator := union.New(authenticators...)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> authenticator, &amp;securityDefinitions, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂的Authentication模块的初始化顺序我们看完了，有初步的了解即可，没必要去强制记忆其中的加载顺序。</p>\n<h3 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">BuildAuthorizer</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与上面一致，实例化是在这个New中</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> authorizationConfig.New()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不得不说，Authorizer这块的阅读体验更好</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(config Config)</span> <span class=\"title\">New</span><span class=\"params\">()</span> <span class=\"params\">(authorizer.Authorizer, authorizer.RuleResolver, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 必须传入一个Authorizer机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.AuthorizationModes) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;at least one authorization mode must be passed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> (</span><br><span class=\"line\">\t\tauthorizers   []authorizer.Authorizer</span><br><span class=\"line\">\t\truleResolvers []authorizer.RuleResolver</span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, authorizationMode := <span class=\"keyword\">range</span> config.AuthorizationModes &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 具体的mode定义，可以跳转到对应的链接去看，今天不细讲</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> authorizationMode &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeNode:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, nodeAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, nodeAuthorizer)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeAlwaysAllow:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, alwaysAllowAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, alwaysAllowAuthorizer)</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeAlwaysDeny:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, alwaysDenyAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, alwaysDenyAuthorizer)</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeABAC:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, abacAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, abacAuthorizer)</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeWebhook:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, webhookAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, webhookAuthorizer)</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeRBAC:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, rbacAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, rbacAuthorizer)</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;unknown authorization mode %s specified&quot;</span>, authorizationMode)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> union.New(authorizers...), union.NewRuleResolvers(ruleResolvers...), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"comment\">// ModeAlwaysAllow is the mode to set all requests as authorized</span></span><br><span class=\"line\">\tModeAlwaysAllow <span class=\"keyword\">string</span> = <span class=\"string\">&quot;AlwaysAllow&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeAlwaysDeny is the mode to set no requests as authorized</span></span><br><span class=\"line\">\tModeAlwaysDeny <span class=\"keyword\">string</span> = <span class=\"string\">&quot;AlwaysDeny&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeABAC is the mode to use Attribute Based Access Control to authorize</span></span><br><span class=\"line\">\tModeABAC <span class=\"keyword\">string</span> = <span class=\"string\">&quot;ABAC&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeWebhook is the mode to make an external webhook call to authorize</span></span><br><span class=\"line\">\tModeWebhook <span class=\"keyword\">string</span> = <span class=\"string\">&quot;Webhook&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeRBAC is the mode to use Role Based Access Control to authorize</span></span><br><span class=\"line\">\tModeRBAC <span class=\"keyword\">string</span> = <span class=\"string\">&quot;RBAC&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeNode is an authorization mode that authorizes API requests made by kubelets.</span></span><br><span class=\"line\">\tModeNode <span class=\"keyword\">string</span> = <span class=\"string\">&quot;Node&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Admission\"><a href=\"#Admission\" class=\"headerlink\" title=\"Admission\"></a>Admission</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查看定义</span></span><br><span class=\"line\">err = s.Admission.ApplyTo()</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *AdmissionOptions)</span> <span class=\"title\">ApplyTo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.GenericAdmission.ApplyTo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ps *Plugins)</span> <span class=\"title\">NewFromPlugins</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> _, pluginName := <span class=\"keyword\">range</span> pluginNames &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// InitPlugin 为初始化的工作</span></span><br><span class=\"line\">\t\tplugin, err := ps.InitPlugin(pluginName, pluginConfig, pluginInitializer)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ps *Plugins)</span> <span class=\"title\">InitPlugin</span><span class=\"params\">(name <span class=\"keyword\">string</span>, config io.Reader, pluginInitializer PluginInitializer)</span> <span class=\"params\">(Interface, error)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取plugin</span></span><br><span class=\"line\">  plugin, found, err := ps.getPlugin(name, config)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看一下Interface的定义，就是对准入机制的控制</span></span><br><span class=\"line\"><span class=\"comment\">// Interface is an abstract, pluggable interface for Admission Control decisions.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tHandles(operation Operation) <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再去看看获取plugin的地方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ps *Plugins)</span> <span class=\"title\">getPlugin</span><span class=\"params\">(name <span class=\"keyword\">string</span>, config io.Reader)</span> <span class=\"params\">(Interface, <span class=\"keyword\">bool</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tps.lock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ps.lock.Unlock()</span><br><span class=\"line\">  <span class=\"comment\">// 我们再去研究ps.registry这个参数是在哪里被初始化的</span></span><br><span class=\"line\">\tf, found := ps.registry[name]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下来，我们从kube-apiserver启动过程，逐步找到Admission被初始化的地方</span></span><br><span class=\"line\"><span class=\"comment\">// 启动命令</span></span><br><span class=\"line\">command := app.NewAPIServerCommand()</span><br><span class=\"line\"><span class=\"comment\">// server配置</span></span><br><span class=\"line\">s := options.NewServerRunOptions()</span><br><span class=\"line\"><span class=\"comment\">// admission选项</span></span><br><span class=\"line\">Admission:               kubeoptions.NewAdmissionOptions()</span><br><span class=\"line\"><span class=\"comment\">// 注册准入机制</span></span><br><span class=\"line\">RegisterAllAdmissionPlugins(options.Plugins)</span><br><span class=\"line\"><span class=\"comment\">// 准入机制的所有内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RegisterAllAdmissionPlugins</span><span class=\"params\">(plugins *admission.Plugins)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里有很多plugin的注册</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 往上翻，我们能找到所有plugin，也就是准入机制的定义</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> AllOrderedPlugins = []<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\tadmit.PluginName,                        <span class=\"comment\">// AlwaysAdmit</span></span><br><span class=\"line\">\tautoprovision.PluginName,                <span class=\"comment\">// NamespaceAutoProvision</span></span><br><span class=\"line\">\tlifecycle.PluginName,                    <span class=\"comment\">// NamespaceLifecycle</span></span><br><span class=\"line\">\texists.PluginName,                       <span class=\"comment\">// NamespaceExists</span></span><br><span class=\"line\">\tscdeny.PluginName,                       <span class=\"comment\">// SecurityContextDeny</span></span><br><span class=\"line\">\tantiaffinity.PluginName,                 <span class=\"comment\">// LimitPodHardAntiAffinityTopology</span></span><br><span class=\"line\">\tpodpreset.PluginName,                    <span class=\"comment\">// PodPreset</span></span><br><span class=\"line\">\tlimitranger.PluginName,                  <span class=\"comment\">// LimitRanger</span></span><br><span class=\"line\">\tserviceaccount.PluginName,               <span class=\"comment\">// ServiceAccount</span></span><br><span class=\"line\">\tnoderestriction.PluginName,              <span class=\"comment\">// NodeRestriction</span></span><br><span class=\"line\">\tnodetaint.PluginName,                    <span class=\"comment\">// TaintNodesByCondition</span></span><br><span class=\"line\">\talwayspullimages.PluginName,             <span class=\"comment\">// AlwaysPullImages</span></span><br><span class=\"line\">\timagepolicy.PluginName,                  <span class=\"comment\">// ImagePolicyWebhook</span></span><br><span class=\"line\">\tpodsecuritypolicy.PluginName,            <span class=\"comment\">// PodSecurityPolicy</span></span><br><span class=\"line\">\tpodnodeselector.PluginName,              <span class=\"comment\">// PodNodeSelector</span></span><br><span class=\"line\">\tpodpriority.PluginName,                  <span class=\"comment\">// Priority</span></span><br><span class=\"line\">\tdefaulttolerationseconds.PluginName,     <span class=\"comment\">// DefaultTolerationSeconds</span></span><br><span class=\"line\">\tpodtolerationrestriction.PluginName,     <span class=\"comment\">// PodTolerationRestriction</span></span><br><span class=\"line\">\texec.DenyEscalatingExec,                 <span class=\"comment\">// DenyEscalatingExec</span></span><br><span class=\"line\">\texec.DenyExecOnPrivileged,               <span class=\"comment\">// DenyExecOnPrivileged</span></span><br><span class=\"line\">\teventratelimit.PluginName,               <span class=\"comment\">// EventRateLimit</span></span><br><span class=\"line\">\textendedresourcetoleration.PluginName,   <span class=\"comment\">// ExtendedResourceToleration</span></span><br><span class=\"line\">\tlabel.PluginName,                        <span class=\"comment\">// PersistentVolumeLabel</span></span><br><span class=\"line\">\tsetdefault.PluginName,                   <span class=\"comment\">// DefaultStorageClass</span></span><br><span class=\"line\">\tstorageobjectinuseprotection.PluginName, <span class=\"comment\">// StorageObjectInUseProtection</span></span><br><span class=\"line\">\tgc.PluginName,                           <span class=\"comment\">// OwnerReferencesPermissionEnforcement</span></span><br><span class=\"line\">\tresize.PluginName,                       <span class=\"comment\">// PersistentVolumeClaimResize</span></span><br><span class=\"line\">\truntimeclass.PluginName,                 <span class=\"comment\">// RuntimeClass</span></span><br><span class=\"line\">\tcertapproval.PluginName,                 <span class=\"comment\">// CertificateApproval</span></span><br><span class=\"line\">\tcertsigning.PluginName,                  <span class=\"comment\">// CertificateSigning</span></span><br><span class=\"line\">\tcertsubjectrestriction.PluginName,       <span class=\"comment\">// CertificateSubjectRestriction</span></span><br><span class=\"line\">\tdefaultingressclass.PluginName,          <span class=\"comment\">// DefaultIngressClass</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// new admission plugins should generally be inserted above here</span></span><br><span class=\"line\">\t<span class=\"comment\">// webhook, resourcequota, and deny plugins must go at the end</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tmutatingwebhook.PluginName,   <span class=\"comment\">// MutatingAdmissionWebhook</span></span><br><span class=\"line\">\tvalidatingwebhook.PluginName, <span class=\"comment\">// ValidatingAdmissionWebhook</span></span><br><span class=\"line\">\tresourcequota.PluginName,     <span class=\"comment\">// ResourceQuota</span></span><br><span class=\"line\">\tdeny.PluginName,              <span class=\"comment\">// AlwaysDeny</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解启动kube-apiserver的权限相关的三个核心概念 <code>Authentication</code>/<code>Authorization</code>/<code>Admission</code></p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#run\">kube-apiserver的启动</a></li>\n<li><a href=\"#three-servers\">kube-apiserver的三个Server</a></li>\n<li><a href=\"#KubeAPIServer\">KubeAPIServer的创建过程</a><ol>\n<li><a href=\"#GenericConfig\">通用配置概况</a></li>\n<li><a href=\"#Authentication\">通用配置中的认证</a></li>\n<li><a href=\"#Authorization\">通用配置中的授权</a></li>\n<li><a href=\"#Admission\">通用配置中的准入机制</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类似kubectl的源代码，kube-apiserver的命令行工具也使用了cobra，我们很快就能找到启动的入口</span></span><br><span class=\"line\">RunE: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd *cobra.Command, args []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 这里包含2个参数，前者是参数completedOptions，后者是一个stopCh &lt;-chan struct&#123;&#125;</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Run(completedOptions, genericapiserver.SetupSignalHandler())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t在这里，我们可以和kubectl结合起来思考：</span></span><br><span class=\"line\"><span class=\"comment\">\tkubectl是一个命令行工具，执行完命令就退出；kube-apiserver是一个常驻的服务器进程，监听端口</span></span><br><span class=\"line\"><span class=\"comment\">\t这里引入了一个stopCh &lt;-chan struct&#123;&#125;，可以在启动后，用一个 &lt;-stopCh 作为阻塞，使程序不退出</span></span><br><span class=\"line\"><span class=\"comment\">\t用channel阻塞进程退出，对比传统的方法 - 用一个永不退出的for循环，是一个很优雅的实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Three-Servers\"><a href=\"#Three-Servers\" class=\"headerlink\" title=\"Three Servers\"></a>Three Servers</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在CreateServerChain这个函数下，创建了3个server</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CreateServerChain</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// API扩展服务，主要针对CRD</span></span><br><span class=\"line\">\tcreateAPIExtensionsServer()&#123;&#125; </span><br><span class=\"line\">  <span class=\"comment\">// API核心服务，包括常见的Pod/Deployment/Service，我们今天的重点聚焦在这里</span></span><br><span class=\"line\">  <span class=\"comment\">// 我会跳过很多非核心的配置参数，一开始就去研究细节，很影响整体代码的阅读效率</span></span><br><span class=\"line\">\tCreateKubeAPIServer()&#123;&#125; </span><br><span class=\"line\">  <span class=\"comment\">// API聚合服务，主要针对metrics</span></span><br><span class=\"line\">\tcreateAggregatorServer()&#123;&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"KubeAPIServer\"><a href=\"#KubeAPIServer\" class=\"headerlink\" title=\"KubeAPIServer\"></a>KubeAPIServer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建配置的流程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CreateKubeAPIServerConfig</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建通用配置genericConfig</span></span><br><span class=\"line\">  genericConfig, versionedInformers, insecureServingInfo, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory, err := buildGenericConfig(s.ServerRunOptions, proxyTransport)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GenericConfig\"><a href=\"#GenericConfig\" class=\"headerlink\" title=\"GenericConfig\"></a>GenericConfig</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通用配置的创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildGenericConfig</span><span class=\"params\">(s *options.ServerRunOptions,proxyTransport *http.Transport)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Insecure对应的非安全的通信，也就是HTTP</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> lastErr = s.InsecureServing...</span><br><span class=\"line\">  <span class=\"comment\">// Secure对应的就是HTTPS</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> lastErr = s.SecureServing...</span><br><span class=\"line\">  <span class=\"comment\">// OpenAPIConfig是对外提供的API文档</span></span><br><span class=\"line\">  genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig()</span><br><span class=\"line\">  <span class=\"comment\">// 这一块是storageFactory的实例化，可以看到采用的是etcd作为存储方案</span></span><br><span class=\"line\">  storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()</span><br><span class=\"line\">\tstorageFactoryConfig.APIResourceConfig = genericConfig.MergedResourceConfig</span><br><span class=\"line\">\tcompletedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)</span><br><span class=\"line\">\tstorageFactory, lastErr = completedStorageFactoryConfig.New()</span><br><span class=\"line\">  <span class=\"comment\">// Authentication 认证相关</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> lastErr = s.Authentication.ApplyTo()...</span><br><span class=\"line\">  <span class=\"comment\">// Authorization 授权相关</span></span><br><span class=\"line\">  genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer()</span><br><span class=\"line\">  <span class=\"comment\">// Admission 准入机制</span></span><br><span class=\"line\">  err = s.Admission.ApplyTo()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Authentication\"><a href=\"#Authentication\" class=\"headerlink\" title=\"Authentication\"></a>Authentication</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(o *BuiltInAuthenticationOptions)</span> <span class=\"title\">ApplyTo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 前面都是对认证config进行参数设置，这里才是真正的实例化</span></span><br><span class=\"line\">  authInfo.Authenticator, openAPIConfig.SecurityDefinitions, err = authenticatorConfig.New()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New这块的代码，我们要抓住核心变量authenticators和tokenAuthenticators，也就是各种认证方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(config Config)</span> <span class=\"title\">New</span><span class=\"params\">()</span> <span class=\"params\">(authenticator.Request, *spec.SecurityDefinitions, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 核心变量authenticators和tokenAuthenticators</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> authenticators []authenticator.Request</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tokenAuthenticators []authenticator.Token</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> config.RequestHeaderConfig != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 1. 添加requestHeader</span></span><br><span class=\"line\">\t\tauthenticators = <span class=\"built_in\">append</span>(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, requestHeaderAuthenticator))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> config.ClientCAContentProvider != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 2. 添加ClientCA</span></span><br><span class=\"line\">    authenticators = <span class=\"built_in\">append</span>(authenticators, certAuth)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.TokenAuthFile) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 3. token 添加tokenfile</span></span><br><span class=\"line\">\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 4. token 添加 service account，分两种来源</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.ServiceAccountKeyFiles) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, serviceAccountAuth)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> utilfeature.DefaultFeatureGate.Enabled(features.TokenRequest) &amp;&amp; config.ServiceAccountIssuer != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, serviceAccountAuth)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> config.BootstrapToken &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> config.BootstrapTokenAuthenticator != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 5. token 添加 bootstrap</span></span><br><span class=\"line\">\t\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, config.BootstrapTokenAuthenticator))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.OIDCIssuerURL) &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">len</span>(config.OIDCClientID) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 6. token 添加 oidc</span></span><br><span class=\"line\">    Authenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, oidcAuth))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.WebhookTokenAuthnConfigFile) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 7. token 添加 webhook</span></span><br><span class=\"line\">\t\ttokenAuthenticators = <span class=\"built_in\">append</span>(tokenAuthenticators, webhookTokenAuth)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 8. 组合tokenAuthenticators到tokenAuthenticators中</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(tokenAuthenticators) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\ttokenAuth := tokenunion.New(tokenAuthenticators...)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> config.TokenSuccessCacheTTL &gt; <span class=\"number\">0</span> || config.TokenFailureCacheTTL &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ttokenAuth = tokencache.New(tokenAuth, <span class=\"literal\">true</span>, config.TokenSuccessCacheTTL, config.TokenFailureCacheTTL)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tauthenticators = <span class=\"built_in\">append</span>(authenticators, bearertoken.New(tokenAuth), websocket.NewProtocolAuthenticator(tokenAuth))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 9. 没有任何认证方式且启用了Anonymous</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(authenticators) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> config.Anonymous &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> anonymous.NewAuthenticator(), &amp;securityDefinitions, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, &amp;securityDefinitions, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 10. 组合authenticators</span></span><br><span class=\"line\">\tauthenticator := union.New(authenticators...)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> authenticator, &amp;securityDefinitions, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂的Authentication模块的初始化顺序我们看完了，有初步的了解即可，没必要去强制记忆其中的加载顺序。</p>\n<h3 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">BuildAuthorizer</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 与上面一致，实例化是在这个New中</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> authorizationConfig.New()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不得不说，Authorizer这块的阅读体验更好</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(config Config)</span> <span class=\"title\">New</span><span class=\"params\">()</span> <span class=\"params\">(authorizer.Authorizer, authorizer.RuleResolver, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 必须传入一个Authorizer机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(config.AuthorizationModes) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;at least one authorization mode must be passed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> (</span><br><span class=\"line\">\t\tauthorizers   []authorizer.Authorizer</span><br><span class=\"line\">\t\truleResolvers []authorizer.RuleResolver</span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, authorizationMode := <span class=\"keyword\">range</span> config.AuthorizationModes &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 具体的mode定义，可以跳转到对应的链接去看，今天不细讲</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> authorizationMode &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeNode:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, nodeAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, nodeAuthorizer)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeAlwaysAllow:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, alwaysAllowAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, alwaysAllowAuthorizer)</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeAlwaysDeny:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, alwaysDenyAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, alwaysDenyAuthorizer)</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeABAC:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, abacAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, abacAuthorizer)</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeWebhook:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, webhookAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, webhookAuthorizer)</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> modes.ModeRBAC:</span><br><span class=\"line\">\t\t\tauthorizers = <span class=\"built_in\">append</span>(authorizers, rbacAuthorizer)</span><br><span class=\"line\">\t\t\truleResolvers = <span class=\"built_in\">append</span>(ruleResolvers, rbacAuthorizer)</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;unknown authorization mode %s specified&quot;</span>, authorizationMode)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> union.New(authorizers...), union.NewRuleResolvers(ruleResolvers...), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"comment\">// ModeAlwaysAllow is the mode to set all requests as authorized</span></span><br><span class=\"line\">\tModeAlwaysAllow <span class=\"keyword\">string</span> = <span class=\"string\">&quot;AlwaysAllow&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeAlwaysDeny is the mode to set no requests as authorized</span></span><br><span class=\"line\">\tModeAlwaysDeny <span class=\"keyword\">string</span> = <span class=\"string\">&quot;AlwaysDeny&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeABAC is the mode to use Attribute Based Access Control to authorize</span></span><br><span class=\"line\">\tModeABAC <span class=\"keyword\">string</span> = <span class=\"string\">&quot;ABAC&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeWebhook is the mode to make an external webhook call to authorize</span></span><br><span class=\"line\">\tModeWebhook <span class=\"keyword\">string</span> = <span class=\"string\">&quot;Webhook&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeRBAC is the mode to use Role Based Access Control to authorize</span></span><br><span class=\"line\">\tModeRBAC <span class=\"keyword\">string</span> = <span class=\"string\">&quot;RBAC&quot;</span></span><br><span class=\"line\">\t<span class=\"comment\">// ModeNode is an authorization mode that authorizes API requests made by kubelets.</span></span><br><span class=\"line\">\tModeNode <span class=\"keyword\">string</span> = <span class=\"string\">&quot;Node&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Admission\"><a href=\"#Admission\" class=\"headerlink\" title=\"Admission\"></a>Admission</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查看定义</span></span><br><span class=\"line\">err = s.Admission.ApplyTo()</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *AdmissionOptions)</span> <span class=\"title\">ApplyTo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.GenericAdmission.ApplyTo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ps *Plugins)</span> <span class=\"title\">NewFromPlugins</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> _, pluginName := <span class=\"keyword\">range</span> pluginNames &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// InitPlugin 为初始化的工作</span></span><br><span class=\"line\">\t\tplugin, err := ps.InitPlugin(pluginName, pluginConfig, pluginInitializer)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ps *Plugins)</span> <span class=\"title\">InitPlugin</span><span class=\"params\">(name <span class=\"keyword\">string</span>, config io.Reader, pluginInitializer PluginInitializer)</span> <span class=\"params\">(Interface, error)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取plugin</span></span><br><span class=\"line\">  plugin, found, err := ps.getPlugin(name, config)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看一下Interface的定义，就是对准入机制的控制</span></span><br><span class=\"line\"><span class=\"comment\">// Interface is an abstract, pluggable interface for Admission Control decisions.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tHandles(operation Operation) <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再去看看获取plugin的地方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ps *Plugins)</span> <span class=\"title\">getPlugin</span><span class=\"params\">(name <span class=\"keyword\">string</span>, config io.Reader)</span> <span class=\"params\">(Interface, <span class=\"keyword\">bool</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tps.lock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> ps.lock.Unlock()</span><br><span class=\"line\">  <span class=\"comment\">// 我们再去研究ps.registry这个参数是在哪里被初始化的</span></span><br><span class=\"line\">\tf, found := ps.registry[name]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下来，我们从kube-apiserver启动过程，逐步找到Admission被初始化的地方</span></span><br><span class=\"line\"><span class=\"comment\">// 启动命令</span></span><br><span class=\"line\">command := app.NewAPIServerCommand()</span><br><span class=\"line\"><span class=\"comment\">// server配置</span></span><br><span class=\"line\">s := options.NewServerRunOptions()</span><br><span class=\"line\"><span class=\"comment\">// admission选项</span></span><br><span class=\"line\">Admission:               kubeoptions.NewAdmissionOptions()</span><br><span class=\"line\"><span class=\"comment\">// 注册准入机制</span></span><br><span class=\"line\">RegisterAllAdmissionPlugins(options.Plugins)</span><br><span class=\"line\"><span class=\"comment\">// 准入机制的所有内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RegisterAllAdmissionPlugins</span><span class=\"params\">(plugins *admission.Plugins)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里有很多plugin的注册</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 往上翻，我们能找到所有plugin，也就是准入机制的定义</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> AllOrderedPlugins = []<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\tadmit.PluginName,                        <span class=\"comment\">// AlwaysAdmit</span></span><br><span class=\"line\">\tautoprovision.PluginName,                <span class=\"comment\">// NamespaceAutoProvision</span></span><br><span class=\"line\">\tlifecycle.PluginName,                    <span class=\"comment\">// NamespaceLifecycle</span></span><br><span class=\"line\">\texists.PluginName,                       <span class=\"comment\">// NamespaceExists</span></span><br><span class=\"line\">\tscdeny.PluginName,                       <span class=\"comment\">// SecurityContextDeny</span></span><br><span class=\"line\">\tantiaffinity.PluginName,                 <span class=\"comment\">// LimitPodHardAntiAffinityTopology</span></span><br><span class=\"line\">\tpodpreset.PluginName,                    <span class=\"comment\">// PodPreset</span></span><br><span class=\"line\">\tlimitranger.PluginName,                  <span class=\"comment\">// LimitRanger</span></span><br><span class=\"line\">\tserviceaccount.PluginName,               <span class=\"comment\">// ServiceAccount</span></span><br><span class=\"line\">\tnoderestriction.PluginName,              <span class=\"comment\">// NodeRestriction</span></span><br><span class=\"line\">\tnodetaint.PluginName,                    <span class=\"comment\">// TaintNodesByCondition</span></span><br><span class=\"line\">\talwayspullimages.PluginName,             <span class=\"comment\">// AlwaysPullImages</span></span><br><span class=\"line\">\timagepolicy.PluginName,                  <span class=\"comment\">// ImagePolicyWebhook</span></span><br><span class=\"line\">\tpodsecuritypolicy.PluginName,            <span class=\"comment\">// PodSecurityPolicy</span></span><br><span class=\"line\">\tpodnodeselector.PluginName,              <span class=\"comment\">// PodNodeSelector</span></span><br><span class=\"line\">\tpodpriority.PluginName,                  <span class=\"comment\">// Priority</span></span><br><span class=\"line\">\tdefaulttolerationseconds.PluginName,     <span class=\"comment\">// DefaultTolerationSeconds</span></span><br><span class=\"line\">\tpodtolerationrestriction.PluginName,     <span class=\"comment\">// PodTolerationRestriction</span></span><br><span class=\"line\">\texec.DenyEscalatingExec,                 <span class=\"comment\">// DenyEscalatingExec</span></span><br><span class=\"line\">\texec.DenyExecOnPrivileged,               <span class=\"comment\">// DenyExecOnPrivileged</span></span><br><span class=\"line\">\teventratelimit.PluginName,               <span class=\"comment\">// EventRateLimit</span></span><br><span class=\"line\">\textendedresourcetoleration.PluginName,   <span class=\"comment\">// ExtendedResourceToleration</span></span><br><span class=\"line\">\tlabel.PluginName,                        <span class=\"comment\">// PersistentVolumeLabel</span></span><br><span class=\"line\">\tsetdefault.PluginName,                   <span class=\"comment\">// DefaultStorageClass</span></span><br><span class=\"line\">\tstorageobjectinuseprotection.PluginName, <span class=\"comment\">// StorageObjectInUseProtection</span></span><br><span class=\"line\">\tgc.PluginName,                           <span class=\"comment\">// OwnerReferencesPermissionEnforcement</span></span><br><span class=\"line\">\tresize.PluginName,                       <span class=\"comment\">// PersistentVolumeClaimResize</span></span><br><span class=\"line\">\truntimeclass.PluginName,                 <span class=\"comment\">// RuntimeClass</span></span><br><span class=\"line\">\tcertapproval.PluginName,                 <span class=\"comment\">// CertificateApproval</span></span><br><span class=\"line\">\tcertsigning.PluginName,                  <span class=\"comment\">// CertificateSigning</span></span><br><span class=\"line\">\tcertsubjectrestriction.PluginName,       <span class=\"comment\">// CertificateSubjectRestriction</span></span><br><span class=\"line\">\tdefaultingressclass.PluginName,          <span class=\"comment\">// DefaultIngressClass</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// new admission plugins should generally be inserted above here</span></span><br><span class=\"line\">\t<span class=\"comment\">// webhook, resourcequota, and deny plugins must go at the end</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tmutatingwebhook.PluginName,   <span class=\"comment\">// MutatingAdmissionWebhook</span></span><br><span class=\"line\">\tvalidatingwebhook.PluginName, <span class=\"comment\">// ValidatingAdmissionWebhook</span></span><br><span class=\"line\">\tresourcequota.PluginName,     <span class=\"comment\">// ResourceQuota</span></span><br><span class=\"line\">\tdeny.PluginName,              <span class=\"comment\">// AlwaysDeny</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"【K8s源码品读】006：Phase 1 - kube-apiserver - GenericAPIServer的初始化","date":"2021-02-18T08:55:52.000Z","_content":"\n## 聚焦目标\n\n理解kube-apiserver是中的管理核心资源的`KubeAPIServer`是怎么启动的\n\n\n\n## 目录\n\n1. [genericServer的创建](#genericServer)\n2. [创建REST的Handler](#NewAPIServerHandler)\n3. [Generic的API路由规则](#installAPI)\n4. [初始化核心Apiserver](#apiserver)\n5. [核心资源的API路由规则](#InstallLegacyAPI)\n6. [创建Pod的函数](#create-pod)\n\n\n\n\n\n## GenericServer\n\n```go\n// 在APIExtensionsServer、KubeAPIServer和AggregatorServer三种Server启动时，我们都能发现这么一个函数\n// APIExtensionsServer\ngenericServer, err := c.GenericConfig.New(\"apiextensions-apiserver\", delegationTarget)\n// KubeAPIServer\ns, err := c.GenericConfig.New(\"kube-apiserver\", delegationTarget)\n// AggregatorServer\ngenericServer, err := c.GenericConfig.New(\"kube-aggregator\", delegationTarget)\n\n// 都通过GenericConfig创建了genericServer，我们先大致浏览下\nfunc (c completedConfig) New(name string, delegationTarget DelegationTarget) (*GenericAPIServer, error) {\n\t// 新建Handler\n\tapiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())\n  \n\t// 实例化一个Server\n\ts := &GenericAPIServer{\n    ...\n  }\n\n\t// 处理钩子hook操作\n\tfor k, v := range delegationTarget.PostStartHooks() {\n\t\ts.postStartHooks[k] = v\n\t}\n\n\tfor k, v := range delegationTarget.PreShutdownHooks() {\n\t\ts.preShutdownHooks[k] = v\n\t}\n\n\t// 健康监测\n\tfor _, delegateCheck := range delegationTarget.HealthzChecks() {\n\t\tskip := false\n\t\tfor _, existingCheck := range c.HealthzChecks {\n\t\t\tif existingCheck.Name() == delegateCheck.Name() {\n\t\t\t\tskip = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif skip {\n\t\t\tcontinue\n\t\t}\n\t\ts.AddHealthChecks(delegateCheck)\n\t}\n\t\n  // 安装API相关参数，这个是重点\n\tinstallAPI(s, c.Config)\n\n\treturn s, nil\n}\n```\n\n\n\n## NewAPIServerHandler\n\n```go\nfunc NewAPIServerHandler(name string, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler) *APIServerHandler {\n\t// 采用了 github.com/emicklei/go-restful 这个库作为 RESTful 接口的设计，目前了解即可\n\tgorestfulContainer := restful.NewContainer()\n\t\n}\n```\n\n\n\n## installAPI\n\n```go\nfunc installAPI(s *GenericAPIServer, c *Config) {\n  // 添加 /index.html 路由规则\n\tif c.EnableIndex {\n\t\troutes.Index{}.Install(s.listedPathProvider, s.Handler.NonGoRestfulMux)\n\t}\n  // 添加go语言 /pprof 的路由规则，常用于性能分析\n\tif c.EnableProfiling {\n\t\troutes.Profiling{}.Install(s.Handler.NonGoRestfulMux)\n\t\tif c.EnableContentionProfiling {\n\t\t\tgoruntime.SetBlockProfileRate(1)\n\t\t}\n\t\troutes.DebugFlags{}.Install(s.Handler.NonGoRestfulMux, \"v\", routes.StringFlagPutHandler(logs.GlogSetter))\n\t}\n  // 添加监控相关的 /metrics 的指标路由规则\n\tif c.EnableMetrics {\n\t\tif c.EnableProfiling {\n\t\t\troutes.MetricsWithReset{}.Install(s.Handler.NonGoRestfulMux)\n\t\t} else {\n\t\t\troutes.DefaultMetrics{}.Install(s.Handler.NonGoRestfulMux)\n\t\t}\n\t}\n\t// 添加版本 /version 的路由规则\n\troutes.Version{Version: c.Version}.Install(s.Handler.GoRestfulContainer)\n\t// 开启服务发现\n\tif c.EnableDiscovery {\n\t\ts.Handler.GoRestfulContainer.Add(s.DiscoveryGroupManager.WebService())\n\t}\n\tif feature.DefaultFeatureGate.Enabled(features.APIPriorityAndFairness) {\n\t\tc.FlowControl.Install(s.Handler.NonGoRestfulMux)\n\t}\n}\n```\n\n\n\n## Apiserver\n\n```go\nfunc (c completedConfig) New(delegationTarget genericapiserver.DelegationTarget) (*Master, error) {\n\t// genericServer的初始化\n\ts, err := c.GenericConfig.New(\"kube-apiserver\", delegationTarget)\n\t// 核心KubeAPIServer的实例化\n\tm := &Master{\n\t\tGenericAPIServer:          s,\n\t\tClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,\n\t}\n\n\t// 注册Legacy API的注册\n\tif c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) {\n\t\tlegacyRESTStorageProvider := corerest.LegacyRESTStorageProvider{}\n\t\tif err := m.InstallLegacyAPI(&c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// REST接口的存储定义，可以看到很多k8s上的常见定义，比如node节点/storage存储/event事件等等\n\trestStorageProviders := []RESTStorageProvider{\n\t\tauthenticationrest.RESTStorageProvider{Authenticator: c.GenericConfig.Authentication.Authenticator, APIAudiences: c.GenericConfig.Authentication.APIAudiences},\n\t\tauthorizationrest.RESTStorageProvider{Authorizer: c.GenericConfig.Authorization.Authorizer, RuleResolver: c.GenericConfig.RuleResolver},\n\t\tautoscalingrest.RESTStorageProvider{},\n\t\tbatchrest.RESTStorageProvider{},\n\t\tcertificatesrest.RESTStorageProvider{},\n\t\tcoordinationrest.RESTStorageProvider{},\n\t\tdiscoveryrest.StorageProvider{},\n\t\textensionsrest.RESTStorageProvider{},\n\t\tnetworkingrest.RESTStorageProvider{},\n\t\tnoderest.RESTStorageProvider{},\n\t\tpolicyrest.RESTStorageProvider{},\n\t\trbacrest.RESTStorageProvider{Authorizer: c.GenericConfig.Authorization.Authorizer},\n\t\tschedulingrest.RESTStorageProvider{},\n\t\tsettingsrest.RESTStorageProvider{},\n\t\tstoragerest.RESTStorageProvider{},\n\t\tflowcontrolrest.RESTStorageProvider{},\n\t\t// keep apps after extensions so legacy clients resolve the extensions versions of shared resource names.\n\t\t// See https://github.com/kubernetes/kubernetes/issues/42392\n\t\tappsrest.StorageProvider{},\n\t\tadmissionregistrationrest.RESTStorageProvider{},\n\t\teventsrest.RESTStorageProvider{TTL: c.ExtraConfig.EventTTL},\n\t}\n  // 注册API\n\tif err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != nil {\n\t\treturn nil, err\n\t}\n\t// 添加Hook\n\tm.GenericAPIServer.AddPostStartHookOrDie(\"start-cluster-authentication-info-controller\", func(hookContext genericapiserver.PostStartHookContext) error {\n\t})\n\treturn m, nil\n}\n```\n\n注册API的关键在`InstallLegacyAPI`和`InstallAPIs`，如果你对kubernetes的资源有一定的了解，会知道核心资源都放在Legacy中（如果不了解的话，点击函数看一下，就能有所有了解）\n\n\n\n## InstallLegacyAPI\n\n```go\nfunc (m *Master) InstallLegacyAPI(c *completedConfig, restOptionsGetter generic.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider) error {\n  // RESTStorage的初始化\n\tlegacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)\n  \n  // 前缀为 /api，注册上对应的Version和Resource\n  // Pod作为核心资源，没有Group的概念\n\tif err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &apiGroupInfo); err != nil {\n\t\treturn fmt.Errorf(\"error in registering group versions: %v\", err)\n\t}\n\treturn nil\n}\n\n// 我们再细看这个RESTStorage的初始化\nfunc (c LegacyRESTStorageProvider) NewLegacyRESTStorage(restOptionsGetter generic.RESTOptionsGetter) (LegacyRESTStorage, genericapiserver.APIGroupInfo, error) {\n\t// pod 模板\n\tpodTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)\n\t// event事件\n\teventStorage, err := eventstore.NewREST(restOptionsGetter, uint64(c.EventTTL.Seconds()))\n\t// limitRange资源限制\n\tlimitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)\n\t// resourceQuota资源配额\n\tresourceQuotaStorage, resourceQuotaStatusStorage, err := resourcequotastore.NewREST(restOptionsGetter)\n\t// secret加密\n\tsecretStorage, err := secretstore.NewREST(restOptionsGetter)\n\t// PV 存储\n\tpersistentVolumeStorage, persistentVolumeStatusStorage, err := pvstore.NewREST(restOptionsGetter)\n\t// PVC 存储\n\tpersistentVolumeClaimStorage, persistentVolumeClaimStatusStorage, err := pvcstore.NewREST(restOptionsGetter)\n\t// ConfigMap 配置\n\tconfigMapStorage, err := configmapstore.NewREST(restOptionsGetter)\n\t// 等等核心资源，暂不一一列举\n  \n  // pod模板，我们的示例nginx-pod属于这个类型的资源\n  podStorage, err := podstore.NewStorage()\n \n  // 保存storage的对应关系\n  restStorageMap := map[string]rest.Storage{\n\t\t\"pods\":             podStorage.Pod,\n\t\t\"pods/attach\":      podStorage.Attach,\n\t\t\"pods/status\":      podStorage.Status,\n\t\t\"pods/log\":         podStorage.Log,\n\t\t\"pods/exec\":        podStorage.Exec,\n\t\t\"pods/portforward\": podStorage.PortForward,\n\t\t\"pods/proxy\":       podStorage.Proxy,\n\t\t\"pods/binding\":     podStorage.Binding,\n\t\t\"bindings\":         podStorage.LegacyBinding,\n    ...\n  }\n}\n```\n\n\n\n## Create Pod\n\n```go\n// 查看Pod初始化\nfunc NewStorage(optsGetter generic.RESTOptionsGetter, k client.ConnectionInfoGetter, proxyTransport http.RoundTripper, podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter) (PodStorage, error) {\n\n\tstore := &genericregistry.Store{\n\t\tNewFunc:                  func() runtime.Object { return &api.Pod{} },\n\t\tNewListFunc:              func() runtime.Object { return &api.PodList{} },\n\t\tPredicateFunc:            registrypod.MatchPod,\n\t\tDefaultQualifiedResource: api.Resource(\"pods\"),\n\t\t// 增改删的策略\n\t\tCreateStrategy:      registrypod.Strategy,\n\t\tUpdateStrategy:      registrypod.Strategy,\n\t\tDeleteStrategy:      registrypod.Strategy,\n\t\tReturnDeletedObject: true,\n\n\t\tTableConvertor: printerstorage.TableConvertor{TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)},\n\t}\n}\n// 查看 Strategy 的初始化\nvar Strategy = podStrategy{legacyscheme.Scheme, names.SimpleNameGenerator}\n\n// 又查询到Scheme的初始化。Schema可以理解为Kubernetes的注册表，即所有的资源类型必须先注册进Schema才可使用\nvar Scheme = runtime.NewScheme()\n```\n\n","source":"_posts/k8s-006.md","raw":"---\ntitle: 【K8s源码品读】006：Phase 1 - kube-apiserver - GenericAPIServer的初始化\ndate: 2021-02-18 16:55:52\ntags:\n---\n\n## 聚焦目标\n\n理解kube-apiserver是中的管理核心资源的`KubeAPIServer`是怎么启动的\n\n\n\n## 目录\n\n1. [genericServer的创建](#genericServer)\n2. [创建REST的Handler](#NewAPIServerHandler)\n3. [Generic的API路由规则](#installAPI)\n4. [初始化核心Apiserver](#apiserver)\n5. [核心资源的API路由规则](#InstallLegacyAPI)\n6. [创建Pod的函数](#create-pod)\n\n\n\n\n\n## GenericServer\n\n```go\n// 在APIExtensionsServer、KubeAPIServer和AggregatorServer三种Server启动时，我们都能发现这么一个函数\n// APIExtensionsServer\ngenericServer, err := c.GenericConfig.New(\"apiextensions-apiserver\", delegationTarget)\n// KubeAPIServer\ns, err := c.GenericConfig.New(\"kube-apiserver\", delegationTarget)\n// AggregatorServer\ngenericServer, err := c.GenericConfig.New(\"kube-aggregator\", delegationTarget)\n\n// 都通过GenericConfig创建了genericServer，我们先大致浏览下\nfunc (c completedConfig) New(name string, delegationTarget DelegationTarget) (*GenericAPIServer, error) {\n\t// 新建Handler\n\tapiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())\n  \n\t// 实例化一个Server\n\ts := &GenericAPIServer{\n    ...\n  }\n\n\t// 处理钩子hook操作\n\tfor k, v := range delegationTarget.PostStartHooks() {\n\t\ts.postStartHooks[k] = v\n\t}\n\n\tfor k, v := range delegationTarget.PreShutdownHooks() {\n\t\ts.preShutdownHooks[k] = v\n\t}\n\n\t// 健康监测\n\tfor _, delegateCheck := range delegationTarget.HealthzChecks() {\n\t\tskip := false\n\t\tfor _, existingCheck := range c.HealthzChecks {\n\t\t\tif existingCheck.Name() == delegateCheck.Name() {\n\t\t\t\tskip = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif skip {\n\t\t\tcontinue\n\t\t}\n\t\ts.AddHealthChecks(delegateCheck)\n\t}\n\t\n  // 安装API相关参数，这个是重点\n\tinstallAPI(s, c.Config)\n\n\treturn s, nil\n}\n```\n\n\n\n## NewAPIServerHandler\n\n```go\nfunc NewAPIServerHandler(name string, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler) *APIServerHandler {\n\t// 采用了 github.com/emicklei/go-restful 这个库作为 RESTful 接口的设计，目前了解即可\n\tgorestfulContainer := restful.NewContainer()\n\t\n}\n```\n\n\n\n## installAPI\n\n```go\nfunc installAPI(s *GenericAPIServer, c *Config) {\n  // 添加 /index.html 路由规则\n\tif c.EnableIndex {\n\t\troutes.Index{}.Install(s.listedPathProvider, s.Handler.NonGoRestfulMux)\n\t}\n  // 添加go语言 /pprof 的路由规则，常用于性能分析\n\tif c.EnableProfiling {\n\t\troutes.Profiling{}.Install(s.Handler.NonGoRestfulMux)\n\t\tif c.EnableContentionProfiling {\n\t\t\tgoruntime.SetBlockProfileRate(1)\n\t\t}\n\t\troutes.DebugFlags{}.Install(s.Handler.NonGoRestfulMux, \"v\", routes.StringFlagPutHandler(logs.GlogSetter))\n\t}\n  // 添加监控相关的 /metrics 的指标路由规则\n\tif c.EnableMetrics {\n\t\tif c.EnableProfiling {\n\t\t\troutes.MetricsWithReset{}.Install(s.Handler.NonGoRestfulMux)\n\t\t} else {\n\t\t\troutes.DefaultMetrics{}.Install(s.Handler.NonGoRestfulMux)\n\t\t}\n\t}\n\t// 添加版本 /version 的路由规则\n\troutes.Version{Version: c.Version}.Install(s.Handler.GoRestfulContainer)\n\t// 开启服务发现\n\tif c.EnableDiscovery {\n\t\ts.Handler.GoRestfulContainer.Add(s.DiscoveryGroupManager.WebService())\n\t}\n\tif feature.DefaultFeatureGate.Enabled(features.APIPriorityAndFairness) {\n\t\tc.FlowControl.Install(s.Handler.NonGoRestfulMux)\n\t}\n}\n```\n\n\n\n## Apiserver\n\n```go\nfunc (c completedConfig) New(delegationTarget genericapiserver.DelegationTarget) (*Master, error) {\n\t// genericServer的初始化\n\ts, err := c.GenericConfig.New(\"kube-apiserver\", delegationTarget)\n\t// 核心KubeAPIServer的实例化\n\tm := &Master{\n\t\tGenericAPIServer:          s,\n\t\tClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,\n\t}\n\n\t// 注册Legacy API的注册\n\tif c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) {\n\t\tlegacyRESTStorageProvider := corerest.LegacyRESTStorageProvider{}\n\t\tif err := m.InstallLegacyAPI(&c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// REST接口的存储定义，可以看到很多k8s上的常见定义，比如node节点/storage存储/event事件等等\n\trestStorageProviders := []RESTStorageProvider{\n\t\tauthenticationrest.RESTStorageProvider{Authenticator: c.GenericConfig.Authentication.Authenticator, APIAudiences: c.GenericConfig.Authentication.APIAudiences},\n\t\tauthorizationrest.RESTStorageProvider{Authorizer: c.GenericConfig.Authorization.Authorizer, RuleResolver: c.GenericConfig.RuleResolver},\n\t\tautoscalingrest.RESTStorageProvider{},\n\t\tbatchrest.RESTStorageProvider{},\n\t\tcertificatesrest.RESTStorageProvider{},\n\t\tcoordinationrest.RESTStorageProvider{},\n\t\tdiscoveryrest.StorageProvider{},\n\t\textensionsrest.RESTStorageProvider{},\n\t\tnetworkingrest.RESTStorageProvider{},\n\t\tnoderest.RESTStorageProvider{},\n\t\tpolicyrest.RESTStorageProvider{},\n\t\trbacrest.RESTStorageProvider{Authorizer: c.GenericConfig.Authorization.Authorizer},\n\t\tschedulingrest.RESTStorageProvider{},\n\t\tsettingsrest.RESTStorageProvider{},\n\t\tstoragerest.RESTStorageProvider{},\n\t\tflowcontrolrest.RESTStorageProvider{},\n\t\t// keep apps after extensions so legacy clients resolve the extensions versions of shared resource names.\n\t\t// See https://github.com/kubernetes/kubernetes/issues/42392\n\t\tappsrest.StorageProvider{},\n\t\tadmissionregistrationrest.RESTStorageProvider{},\n\t\teventsrest.RESTStorageProvider{TTL: c.ExtraConfig.EventTTL},\n\t}\n  // 注册API\n\tif err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != nil {\n\t\treturn nil, err\n\t}\n\t// 添加Hook\n\tm.GenericAPIServer.AddPostStartHookOrDie(\"start-cluster-authentication-info-controller\", func(hookContext genericapiserver.PostStartHookContext) error {\n\t})\n\treturn m, nil\n}\n```\n\n注册API的关键在`InstallLegacyAPI`和`InstallAPIs`，如果你对kubernetes的资源有一定的了解，会知道核心资源都放在Legacy中（如果不了解的话，点击函数看一下，就能有所有了解）\n\n\n\n## InstallLegacyAPI\n\n```go\nfunc (m *Master) InstallLegacyAPI(c *completedConfig, restOptionsGetter generic.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider) error {\n  // RESTStorage的初始化\n\tlegacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)\n  \n  // 前缀为 /api，注册上对应的Version和Resource\n  // Pod作为核心资源，没有Group的概念\n\tif err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &apiGroupInfo); err != nil {\n\t\treturn fmt.Errorf(\"error in registering group versions: %v\", err)\n\t}\n\treturn nil\n}\n\n// 我们再细看这个RESTStorage的初始化\nfunc (c LegacyRESTStorageProvider) NewLegacyRESTStorage(restOptionsGetter generic.RESTOptionsGetter) (LegacyRESTStorage, genericapiserver.APIGroupInfo, error) {\n\t// pod 模板\n\tpodTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)\n\t// event事件\n\teventStorage, err := eventstore.NewREST(restOptionsGetter, uint64(c.EventTTL.Seconds()))\n\t// limitRange资源限制\n\tlimitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)\n\t// resourceQuota资源配额\n\tresourceQuotaStorage, resourceQuotaStatusStorage, err := resourcequotastore.NewREST(restOptionsGetter)\n\t// secret加密\n\tsecretStorage, err := secretstore.NewREST(restOptionsGetter)\n\t// PV 存储\n\tpersistentVolumeStorage, persistentVolumeStatusStorage, err := pvstore.NewREST(restOptionsGetter)\n\t// PVC 存储\n\tpersistentVolumeClaimStorage, persistentVolumeClaimStatusStorage, err := pvcstore.NewREST(restOptionsGetter)\n\t// ConfigMap 配置\n\tconfigMapStorage, err := configmapstore.NewREST(restOptionsGetter)\n\t// 等等核心资源，暂不一一列举\n  \n  // pod模板，我们的示例nginx-pod属于这个类型的资源\n  podStorage, err := podstore.NewStorage()\n \n  // 保存storage的对应关系\n  restStorageMap := map[string]rest.Storage{\n\t\t\"pods\":             podStorage.Pod,\n\t\t\"pods/attach\":      podStorage.Attach,\n\t\t\"pods/status\":      podStorage.Status,\n\t\t\"pods/log\":         podStorage.Log,\n\t\t\"pods/exec\":        podStorage.Exec,\n\t\t\"pods/portforward\": podStorage.PortForward,\n\t\t\"pods/proxy\":       podStorage.Proxy,\n\t\t\"pods/binding\":     podStorage.Binding,\n\t\t\"bindings\":         podStorage.LegacyBinding,\n    ...\n  }\n}\n```\n\n\n\n## Create Pod\n\n```go\n// 查看Pod初始化\nfunc NewStorage(optsGetter generic.RESTOptionsGetter, k client.ConnectionInfoGetter, proxyTransport http.RoundTripper, podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter) (PodStorage, error) {\n\n\tstore := &genericregistry.Store{\n\t\tNewFunc:                  func() runtime.Object { return &api.Pod{} },\n\t\tNewListFunc:              func() runtime.Object { return &api.PodList{} },\n\t\tPredicateFunc:            registrypod.MatchPod,\n\t\tDefaultQualifiedResource: api.Resource(\"pods\"),\n\t\t// 增改删的策略\n\t\tCreateStrategy:      registrypod.Strategy,\n\t\tUpdateStrategy:      registrypod.Strategy,\n\t\tDeleteStrategy:      registrypod.Strategy,\n\t\tReturnDeletedObject: true,\n\n\t\tTableConvertor: printerstorage.TableConvertor{TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)},\n\t}\n}\n// 查看 Strategy 的初始化\nvar Strategy = podStrategy{legacyscheme.Scheme, names.SimpleNameGenerator}\n\n// 又查询到Scheme的初始化。Schema可以理解为Kubernetes的注册表，即所有的资源类型必须先注册进Schema才可使用\nvar Scheme = runtime.NewScheme()\n```\n\n","slug":"k8s-006","published":1,"updated":"2021-02-18T08:59:20.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaogral0005a4qp8ea7b0rs","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解kube-apiserver是中的管理核心资源的<code>KubeAPIServer</code>是怎么启动的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#genericServer\">genericServer的创建</a></li>\n<li><a href=\"#NewAPIServerHandler\">创建REST的Handler</a></li>\n<li><a href=\"#installAPI\">Generic的API路由规则</a></li>\n<li><a href=\"#apiserver\">初始化核心Apiserver</a></li>\n<li><a href=\"#InstallLegacyAPI\">核心资源的API路由规则</a></li>\n<li><a href=\"#create-pod\">创建Pod的函数</a></li>\n</ol>\n<h2 id=\"GenericServer\"><a href=\"#GenericServer\" class=\"headerlink\" title=\"GenericServer\"></a>GenericServer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在APIExtensionsServer、KubeAPIServer和AggregatorServer三种Server启动时，我们都能发现这么一个函数</span></span><br><span class=\"line\"><span class=\"comment\">// APIExtensionsServer</span></span><br><span class=\"line\">genericServer, err := c.GenericConfig.New(<span class=\"string\">&quot;apiextensions-apiserver&quot;</span>, delegationTarget)</span><br><span class=\"line\"><span class=\"comment\">// KubeAPIServer</span></span><br><span class=\"line\">s, err := c.GenericConfig.New(<span class=\"string\">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class=\"line\"><span class=\"comment\">// AggregatorServer</span></span><br><span class=\"line\">genericServer, err := c.GenericConfig.New(<span class=\"string\">&quot;kube-aggregator&quot;</span>, delegationTarget)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 都通过GenericConfig创建了genericServer，我们先大致浏览下</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c completedConfig)</span> <span class=\"title\">New</span><span class=\"params\">(name <span class=\"keyword\">string</span>, delegationTarget DelegationTarget)</span> <span class=\"params\">(*GenericAPIServer, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 新建Handler</span></span><br><span class=\"line\">\tapiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// 实例化一个Server</span></span><br><span class=\"line\">\ts := &amp;GenericAPIServer&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 处理钩子hook操作</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> delegationTarget.PostStartHooks() &#123;</span><br><span class=\"line\">\t\ts.postStartHooks[k] = v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> delegationTarget.PreShutdownHooks() &#123;</span><br><span class=\"line\">\t\ts.preShutdownHooks[k] = v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 健康监测</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, delegateCheck := <span class=\"keyword\">range</span> delegationTarget.HealthzChecks() &#123;</span><br><span class=\"line\">\t\tskip := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, existingCheck := <span class=\"keyword\">range</span> c.HealthzChecks &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> existingCheck.Name() == delegateCheck.Name() &#123;</span><br><span class=\"line\">\t\t\t\tskip = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ts.AddHealthChecks(delegateCheck)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// 安装API相关参数，这个是重点</span></span><br><span class=\"line\">\tinstallAPI(s, c.Config)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"NewAPIServerHandler\"><a href=\"#NewAPIServerHandler\" class=\"headerlink\" title=\"NewAPIServerHandler\"></a>NewAPIServerHandler</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewAPIServerHandler</span><span class=\"params\">(name <span class=\"keyword\">string</span>, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler)</span> *<span class=\"title\">APIServerHandler</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 采用了 github.com/emicklei/go-restful 这个库作为 RESTful 接口的设计，目前了解即可</span></span><br><span class=\"line\">\tgorestfulContainer := restful.NewContainer()</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"installAPI\"><a href=\"#installAPI\" class=\"headerlink\" title=\"installAPI\"></a>installAPI</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">installAPI</span><span class=\"params\">(s *GenericAPIServer, c *Config)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 添加 /index.html 路由规则</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.EnableIndex &#123;</span><br><span class=\"line\">\t\troutes.Index&#123;&#125;.Install(s.listedPathProvider, s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加go语言 /pprof 的路由规则，常用于性能分析</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.EnableProfiling &#123;</span><br><span class=\"line\">\t\troutes.Profiling&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c.EnableContentionProfiling &#123;</span><br><span class=\"line\">\t\t\tgoruntime.SetBlockProfileRate(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\troutes.DebugFlags&#123;&#125;.Install(s.Handler.NonGoRestfulMux, <span class=\"string\">&quot;v&quot;</span>, routes.StringFlagPutHandler(logs.GlogSetter))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加监控相关的 /metrics 的指标路由规则</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.EnableMetrics &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c.EnableProfiling &#123;</span><br><span class=\"line\">\t\t\troutes.MetricsWithReset&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\troutes.DefaultMetrics&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 添加版本 /version 的路由规则</span></span><br><span class=\"line\">\troutes.Version&#123;Version: c.Version&#125;.Install(s.Handler.GoRestfulContainer)</span><br><span class=\"line\">\t<span class=\"comment\">// 开启服务发现</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.EnableDiscovery &#123;</span><br><span class=\"line\">\t\ts.Handler.GoRestfulContainer.Add(s.DiscoveryGroupManager.WebService())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> feature.DefaultFeatureGate.Enabled(features.APIPriorityAndFairness) &#123;</span><br><span class=\"line\">\t\tc.FlowControl.Install(s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Apiserver\"><a href=\"#Apiserver\" class=\"headerlink\" title=\"Apiserver\"></a>Apiserver</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c completedConfig)</span> <span class=\"title\">New</span><span class=\"params\">(delegationTarget genericapiserver.DelegationTarget)</span> <span class=\"params\">(*Master, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// genericServer的初始化</span></span><br><span class=\"line\">\ts, err := c.GenericConfig.New(<span class=\"string\">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class=\"line\">\t<span class=\"comment\">// 核心KubeAPIServer的实例化</span></span><br><span class=\"line\">\tm := &amp;Master&#123;</span><br><span class=\"line\">\t\tGenericAPIServer:          s,</span><br><span class=\"line\">\t\tClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 注册Legacy API的注册</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) &#123;</span><br><span class=\"line\">\t\tlegacyRESTStorageProvider := corerest.LegacyRESTStorageProvider&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := m.InstallLegacyAPI(&amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// REST接口的存储定义，可以看到很多k8s上的常见定义，比如node节点/storage存储/event事件等等</span></span><br><span class=\"line\">\trestStorageProviders := []RESTStorageProvider&#123;</span><br><span class=\"line\">\t\tauthenticationrest.RESTStorageProvider&#123;Authenticator: c.GenericConfig.Authentication.Authenticator, APIAudiences: c.GenericConfig.Authentication.APIAudiences&#125;,</span><br><span class=\"line\">\t\tauthorizationrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer, RuleResolver: c.GenericConfig.RuleResolver&#125;,</span><br><span class=\"line\">\t\tautoscalingrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tbatchrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tcertificatesrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tcoordinationrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tdiscoveryrest.StorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\textensionsrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tnetworkingrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tnoderest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tpolicyrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\trbacrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer&#125;,</span><br><span class=\"line\">\t\tschedulingrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tsettingsrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tstoragerest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tflowcontrolrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\t<span class=\"comment\">// keep apps after extensions so legacy clients resolve the extensions versions of shared resource names.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// See https://github.com/kubernetes/kubernetes/issues/42392</span></span><br><span class=\"line\">\t\tappsrest.StorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tadmissionregistrationrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\teventsrest.RESTStorageProvider&#123;TTL: c.ExtraConfig.EventTTL&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 注册API</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 添加Hook</span></span><br><span class=\"line\">\tm.GenericAPIServer.AddPostStartHookOrDie(<span class=\"string\">&quot;start-cluster-authentication-info-controller&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hookContext genericapiserver.PostStartHookContext)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注册API的关键在<code>InstallLegacyAPI</code>和<code>InstallAPIs</code>，如果你对kubernetes的资源有一定的了解，会知道核心资源都放在Legacy中（如果不了解的话，点击函数看一下，就能有所有了解）</p>\n<h2 id=\"InstallLegacyAPI\"><a href=\"#InstallLegacyAPI\" class=\"headerlink\" title=\"InstallLegacyAPI\"></a>InstallLegacyAPI</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Master)</span> <span class=\"title\">InstallLegacyAPI</span><span class=\"params\">(c *completedConfig, restOptionsGetter generic.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// RESTStorage的初始化</span></span><br><span class=\"line\">\tlegacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 前缀为 /api，注册上对应的Version和Resource</span></span><br><span class=\"line\">  <span class=\"comment\">// Pod作为核心资源，没有Group的概念</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;error in registering group versions: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们再细看这个RESTStorage的初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c LegacyRESTStorageProvider)</span> <span class=\"title\">NewLegacyRESTStorage</span><span class=\"params\">(restOptionsGetter generic.RESTOptionsGetter)</span> <span class=\"params\">(LegacyRESTStorage, genericapiserver.APIGroupInfo, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// pod 模板</span></span><br><span class=\"line\">\tpodTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// event事件</span></span><br><span class=\"line\">\teventStorage, err := eventstore.NewREST(restOptionsGetter, <span class=\"keyword\">uint64</span>(c.EventTTL.Seconds()))</span><br><span class=\"line\">\t<span class=\"comment\">// limitRange资源限制</span></span><br><span class=\"line\">\tlimitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// resourceQuota资源配额</span></span><br><span class=\"line\">\tresourceQuotaStorage, resourceQuotaStatusStorage, err := resourcequotastore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// secret加密</span></span><br><span class=\"line\">\tsecretStorage, err := secretstore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// PV 存储</span></span><br><span class=\"line\">\tpersistentVolumeStorage, persistentVolumeStatusStorage, err := pvstore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// PVC 存储</span></span><br><span class=\"line\">\tpersistentVolumeClaimStorage, persistentVolumeClaimStatusStorage, err := pvcstore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// ConfigMap 配置</span></span><br><span class=\"line\">\tconfigMapStorage, err := configmapstore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// 等等核心资源，暂不一一列举</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// pod模板，我们的示例nginx-pod属于这个类型的资源</span></span><br><span class=\"line\">  podStorage, err := podstore.NewStorage()</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 保存storage的对应关系</span></span><br><span class=\"line\">  restStorageMap := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]rest.Storage&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods&quot;</span>:             podStorage.Pod,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/attach&quot;</span>:      podStorage.Attach,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/status&quot;</span>:      podStorage.Status,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/log&quot;</span>:         podStorage.Log,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/exec&quot;</span>:        podStorage.Exec,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/portforward&quot;</span>: podStorage.PortForward,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/proxy&quot;</span>:       podStorage.Proxy,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/binding&quot;</span>:     podStorage.Binding,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;bindings&quot;</span>:         podStorage.LegacyBinding,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Create-Pod\"><a href=\"#Create-Pod\" class=\"headerlink\" title=\"Create Pod\"></a>Create Pod</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查看Pod初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewStorage</span><span class=\"params\">(optsGetter generic.RESTOptionsGetter, k client.ConnectionInfoGetter, proxyTransport http.RoundTripper, podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter)</span> <span class=\"params\">(PodStorage, error)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstore := &amp;genericregistry.Store&#123;</span><br><span class=\"line\">\t\tNewFunc:                  <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">runtime</span>.<span class=\"title\">Object</span></span> &#123; <span class=\"keyword\">return</span> &amp;api.Pod&#123;&#125; &#125;,</span><br><span class=\"line\">\t\tNewListFunc:              <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">runtime</span>.<span class=\"title\">Object</span></span> &#123; <span class=\"keyword\">return</span> &amp;api.PodList&#123;&#125; &#125;,</span><br><span class=\"line\">\t\tPredicateFunc:            registrypod.MatchPod,</span><br><span class=\"line\">\t\tDefaultQualifiedResource: api.Resource(<span class=\"string\">&quot;pods&quot;</span>),</span><br><span class=\"line\">\t\t<span class=\"comment\">// 增改删的策略</span></span><br><span class=\"line\">\t\tCreateStrategy:      registrypod.Strategy,</span><br><span class=\"line\">\t\tUpdateStrategy:      registrypod.Strategy,</span><br><span class=\"line\">\t\tDeleteStrategy:      registrypod.Strategy,</span><br><span class=\"line\">\t\tReturnDeletedObject: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTableConvertor: printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 查看 Strategy 的初始化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Strategy = podStrategy&#123;legacyscheme.Scheme, names.SimpleNameGenerator&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 又查询到Scheme的初始化。Schema可以理解为Kubernetes的注册表，即所有的资源类型必须先注册进Schema才可使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Scheme = runtime.NewScheme()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解kube-apiserver是中的管理核心资源的<code>KubeAPIServer</code>是怎么启动的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#genericServer\">genericServer的创建</a></li>\n<li><a href=\"#NewAPIServerHandler\">创建REST的Handler</a></li>\n<li><a href=\"#installAPI\">Generic的API路由规则</a></li>\n<li><a href=\"#apiserver\">初始化核心Apiserver</a></li>\n<li><a href=\"#InstallLegacyAPI\">核心资源的API路由规则</a></li>\n<li><a href=\"#create-pod\">创建Pod的函数</a></li>\n</ol>\n<h2 id=\"GenericServer\"><a href=\"#GenericServer\" class=\"headerlink\" title=\"GenericServer\"></a>GenericServer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在APIExtensionsServer、KubeAPIServer和AggregatorServer三种Server启动时，我们都能发现这么一个函数</span></span><br><span class=\"line\"><span class=\"comment\">// APIExtensionsServer</span></span><br><span class=\"line\">genericServer, err := c.GenericConfig.New(<span class=\"string\">&quot;apiextensions-apiserver&quot;</span>, delegationTarget)</span><br><span class=\"line\"><span class=\"comment\">// KubeAPIServer</span></span><br><span class=\"line\">s, err := c.GenericConfig.New(<span class=\"string\">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class=\"line\"><span class=\"comment\">// AggregatorServer</span></span><br><span class=\"line\">genericServer, err := c.GenericConfig.New(<span class=\"string\">&quot;kube-aggregator&quot;</span>, delegationTarget)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 都通过GenericConfig创建了genericServer，我们先大致浏览下</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c completedConfig)</span> <span class=\"title\">New</span><span class=\"params\">(name <span class=\"keyword\">string</span>, delegationTarget DelegationTarget)</span> <span class=\"params\">(*GenericAPIServer, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 新建Handler</span></span><br><span class=\"line\">\tapiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// 实例化一个Server</span></span><br><span class=\"line\">\ts := &amp;GenericAPIServer&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 处理钩子hook操作</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> delegationTarget.PostStartHooks() &#123;</span><br><span class=\"line\">\t\ts.postStartHooks[k] = v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> delegationTarget.PreShutdownHooks() &#123;</span><br><span class=\"line\">\t\ts.preShutdownHooks[k] = v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 健康监测</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, delegateCheck := <span class=\"keyword\">range</span> delegationTarget.HealthzChecks() &#123;</span><br><span class=\"line\">\t\tskip := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, existingCheck := <span class=\"keyword\">range</span> c.HealthzChecks &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> existingCheck.Name() == delegateCheck.Name() &#123;</span><br><span class=\"line\">\t\t\t\tskip = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> skip &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ts.AddHealthChecks(delegateCheck)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// 安装API相关参数，这个是重点</span></span><br><span class=\"line\">\tinstallAPI(s, c.Config)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"NewAPIServerHandler\"><a href=\"#NewAPIServerHandler\" class=\"headerlink\" title=\"NewAPIServerHandler\"></a>NewAPIServerHandler</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewAPIServerHandler</span><span class=\"params\">(name <span class=\"keyword\">string</span>, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler)</span> *<span class=\"title\">APIServerHandler</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 采用了 github.com/emicklei/go-restful 这个库作为 RESTful 接口的设计，目前了解即可</span></span><br><span class=\"line\">\tgorestfulContainer := restful.NewContainer()</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"installAPI\"><a href=\"#installAPI\" class=\"headerlink\" title=\"installAPI\"></a>installAPI</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">installAPI</span><span class=\"params\">(s *GenericAPIServer, c *Config)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 添加 /index.html 路由规则</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.EnableIndex &#123;</span><br><span class=\"line\">\t\troutes.Index&#123;&#125;.Install(s.listedPathProvider, s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加go语言 /pprof 的路由规则，常用于性能分析</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.EnableProfiling &#123;</span><br><span class=\"line\">\t\troutes.Profiling&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c.EnableContentionProfiling &#123;</span><br><span class=\"line\">\t\t\tgoruntime.SetBlockProfileRate(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\troutes.DebugFlags&#123;&#125;.Install(s.Handler.NonGoRestfulMux, <span class=\"string\">&quot;v&quot;</span>, routes.StringFlagPutHandler(logs.GlogSetter))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加监控相关的 /metrics 的指标路由规则</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.EnableMetrics &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c.EnableProfiling &#123;</span><br><span class=\"line\">\t\t\troutes.MetricsWithReset&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\troutes.DefaultMetrics&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 添加版本 /version 的路由规则</span></span><br><span class=\"line\">\troutes.Version&#123;Version: c.Version&#125;.Install(s.Handler.GoRestfulContainer)</span><br><span class=\"line\">\t<span class=\"comment\">// 开启服务发现</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.EnableDiscovery &#123;</span><br><span class=\"line\">\t\ts.Handler.GoRestfulContainer.Add(s.DiscoveryGroupManager.WebService())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> feature.DefaultFeatureGate.Enabled(features.APIPriorityAndFairness) &#123;</span><br><span class=\"line\">\t\tc.FlowControl.Install(s.Handler.NonGoRestfulMux)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Apiserver\"><a href=\"#Apiserver\" class=\"headerlink\" title=\"Apiserver\"></a>Apiserver</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c completedConfig)</span> <span class=\"title\">New</span><span class=\"params\">(delegationTarget genericapiserver.DelegationTarget)</span> <span class=\"params\">(*Master, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// genericServer的初始化</span></span><br><span class=\"line\">\ts, err := c.GenericConfig.New(<span class=\"string\">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class=\"line\">\t<span class=\"comment\">// 核心KubeAPIServer的实例化</span></span><br><span class=\"line\">\tm := &amp;Master&#123;</span><br><span class=\"line\">\t\tGenericAPIServer:          s,</span><br><span class=\"line\">\t\tClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 注册Legacy API的注册</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) &#123;</span><br><span class=\"line\">\t\tlegacyRESTStorageProvider := corerest.LegacyRESTStorageProvider&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := m.InstallLegacyAPI(&amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// REST接口的存储定义，可以看到很多k8s上的常见定义，比如node节点/storage存储/event事件等等</span></span><br><span class=\"line\">\trestStorageProviders := []RESTStorageProvider&#123;</span><br><span class=\"line\">\t\tauthenticationrest.RESTStorageProvider&#123;Authenticator: c.GenericConfig.Authentication.Authenticator, APIAudiences: c.GenericConfig.Authentication.APIAudiences&#125;,</span><br><span class=\"line\">\t\tauthorizationrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer, RuleResolver: c.GenericConfig.RuleResolver&#125;,</span><br><span class=\"line\">\t\tautoscalingrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tbatchrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tcertificatesrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tcoordinationrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tdiscoveryrest.StorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\textensionsrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tnetworkingrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tnoderest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tpolicyrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\trbacrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer&#125;,</span><br><span class=\"line\">\t\tschedulingrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tsettingsrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tstoragerest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tflowcontrolrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\t<span class=\"comment\">// keep apps after extensions so legacy clients resolve the extensions versions of shared resource names.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// See https://github.com/kubernetes/kubernetes/issues/42392</span></span><br><span class=\"line\">\t\tappsrest.StorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\tadmissionregistrationrest.RESTStorageProvider&#123;&#125;,</span><br><span class=\"line\">\t\teventsrest.RESTStorageProvider&#123;TTL: c.ExtraConfig.EventTTL&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 注册API</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 添加Hook</span></span><br><span class=\"line\">\tm.GenericAPIServer.AddPostStartHookOrDie(<span class=\"string\">&quot;start-cluster-authentication-info-controller&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hookContext genericapiserver.PostStartHookContext)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注册API的关键在<code>InstallLegacyAPI</code>和<code>InstallAPIs</code>，如果你对kubernetes的资源有一定的了解，会知道核心资源都放在Legacy中（如果不了解的话，点击函数看一下，就能有所有了解）</p>\n<h2 id=\"InstallLegacyAPI\"><a href=\"#InstallLegacyAPI\" class=\"headerlink\" title=\"InstallLegacyAPI\"></a>InstallLegacyAPI</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Master)</span> <span class=\"title\">InstallLegacyAPI</span><span class=\"params\">(c *completedConfig, restOptionsGetter generic.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// RESTStorage的初始化</span></span><br><span class=\"line\">\tlegacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 前缀为 /api，注册上对应的Version和Resource</span></span><br><span class=\"line\">  <span class=\"comment\">// Pod作为核心资源，没有Group的概念</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;error in registering group versions: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们再细看这个RESTStorage的初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c LegacyRESTStorageProvider)</span> <span class=\"title\">NewLegacyRESTStorage</span><span class=\"params\">(restOptionsGetter generic.RESTOptionsGetter)</span> <span class=\"params\">(LegacyRESTStorage, genericapiserver.APIGroupInfo, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// pod 模板</span></span><br><span class=\"line\">\tpodTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// event事件</span></span><br><span class=\"line\">\teventStorage, err := eventstore.NewREST(restOptionsGetter, <span class=\"keyword\">uint64</span>(c.EventTTL.Seconds()))</span><br><span class=\"line\">\t<span class=\"comment\">// limitRange资源限制</span></span><br><span class=\"line\">\tlimitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// resourceQuota资源配额</span></span><br><span class=\"line\">\tresourceQuotaStorage, resourceQuotaStatusStorage, err := resourcequotastore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// secret加密</span></span><br><span class=\"line\">\tsecretStorage, err := secretstore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// PV 存储</span></span><br><span class=\"line\">\tpersistentVolumeStorage, persistentVolumeStatusStorage, err := pvstore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// PVC 存储</span></span><br><span class=\"line\">\tpersistentVolumeClaimStorage, persistentVolumeClaimStatusStorage, err := pvcstore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// ConfigMap 配置</span></span><br><span class=\"line\">\tconfigMapStorage, err := configmapstore.NewREST(restOptionsGetter)</span><br><span class=\"line\">\t<span class=\"comment\">// 等等核心资源，暂不一一列举</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// pod模板，我们的示例nginx-pod属于这个类型的资源</span></span><br><span class=\"line\">  podStorage, err := podstore.NewStorage()</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 保存storage的对应关系</span></span><br><span class=\"line\">  restStorageMap := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]rest.Storage&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods&quot;</span>:             podStorage.Pod,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/attach&quot;</span>:      podStorage.Attach,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/status&quot;</span>:      podStorage.Status,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/log&quot;</span>:         podStorage.Log,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/exec&quot;</span>:        podStorage.Exec,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/portforward&quot;</span>: podStorage.PortForward,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/proxy&quot;</span>:       podStorage.Proxy,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pods/binding&quot;</span>:     podStorage.Binding,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;bindings&quot;</span>:         podStorage.LegacyBinding,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Create-Pod\"><a href=\"#Create-Pod\" class=\"headerlink\" title=\"Create Pod\"></a>Create Pod</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查看Pod初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewStorage</span><span class=\"params\">(optsGetter generic.RESTOptionsGetter, k client.ConnectionInfoGetter, proxyTransport http.RoundTripper, podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter)</span> <span class=\"params\">(PodStorage, error)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstore := &amp;genericregistry.Store&#123;</span><br><span class=\"line\">\t\tNewFunc:                  <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">runtime</span>.<span class=\"title\">Object</span></span> &#123; <span class=\"keyword\">return</span> &amp;api.Pod&#123;&#125; &#125;,</span><br><span class=\"line\">\t\tNewListFunc:              <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">runtime</span>.<span class=\"title\">Object</span></span> &#123; <span class=\"keyword\">return</span> &amp;api.PodList&#123;&#125; &#125;,</span><br><span class=\"line\">\t\tPredicateFunc:            registrypod.MatchPod,</span><br><span class=\"line\">\t\tDefaultQualifiedResource: api.Resource(<span class=\"string\">&quot;pods&quot;</span>),</span><br><span class=\"line\">\t\t<span class=\"comment\">// 增改删的策略</span></span><br><span class=\"line\">\t\tCreateStrategy:      registrypod.Strategy,</span><br><span class=\"line\">\t\tUpdateStrategy:      registrypod.Strategy,</span><br><span class=\"line\">\t\tDeleteStrategy:      registrypod.Strategy,</span><br><span class=\"line\">\t\tReturnDeletedObject: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTableConvertor: printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 查看 Strategy 的初始化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Strategy = podStrategy&#123;legacyscheme.Scheme, names.SimpleNameGenerator&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 又查询到Scheme的初始化。Schema可以理解为Kubernetes的注册表，即所有的资源类型必须先注册进Schema才可使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Scheme = runtime.NewScheme()</span><br></pre></td></tr></table></figure>\n"},{"title":"【K8s源码品读】007：Phase 1 - kube-apiserver - Pod数据的保存","date":"2021-02-18T08:55:53.000Z","_content":"\n## 聚焦目标\n\n理解Pod发送到`kube-apiserver`后是怎么保存的\n\n\n\n## 目录\n\n1. [RESTCreateStrategy创建的预处理](#RESTCreateStrategy)\n2. [REST Pod数据的存储](#Storage)\n3. [存储的底层实现](#storage-implement)\n4. [kube-apiserver第一阶段源码阅读总结](#summary)\n\n\n\n## RESTCreateStrategy\n\n```go\n// podStrategy 是封装了 Pod 的各类动作，这里我们先关注create这个操作\ntype podStrategy struct {\n\truntime.ObjectTyper\n\tnames.NameGenerator\n}\n\n// podStrategy 的接口\ntype RESTCreateStrategy interface {\n\truntime.ObjectTyper\n\tnames.NameGenerator\n  // 是否属于当前的 namespace\n\tNamespaceScoped() bool\n  // 准备创建前的检查\n\tPrepareForCreate(ctx context.Context, obj runtime.Object)\n  // 验证资源对象\n\tValidate(ctx context.Context, obj runtime.Object) field.ErrorList\n  // 规范化\n\tCanonicalize(obj runtime.Object)\n}\n\n// 完成了检查，我们就要保存数据了\n```\n\n\n\n## Storage\n\n```go\n// PodStorage 是 Pod 存储的实现，里面包含了多个存储的定义\ntype PodStorage struct {\n  // REST implements a RESTStorage for pods\n\tPod                 *REST\n  // BindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.\n\tBinding             *BindingREST\n  // LegacyBindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.\n\tLegacyBinding       *LegacyBindingREST\n\tEviction            *EvictionREST\n  // StatusREST implements the REST endpoint for changing the status of a pod.\n\tStatus              *StatusREST\n  // EphemeralContainersREST implements the REST endpoint for adding EphemeralContainers\n\tEphemeralContainers *EphemeralContainersREST\n\tLog                 *podrest.LogREST\n\tProxy               *podrest.ProxyREST\n\tExec                *podrest.ExecREST\n\tAttach              *podrest.AttachREST\n\tPortForward         *podrest.PortForwardREST\n}\n\n/*\n从上一节的map关系中，保存在REST中\nrestStorageMap := map[string]rest.Storage{\n\t\t\"pods\":             podStorage.Pod,\n}\n*/\ntype REST struct {\n\t*genericregistry.Store\n\tproxyTransport http.RoundTripper\n}\n\n// Store是一个通用的数据结构\ntype Store struct {\n\t// Storage定义\n\tStorage DryRunnableStorage\n}\n\n// DryRunnableStorage中的Storage是一个Interface\ntype DryRunnableStorage struct {\n\tStorage storage.Interface\n\tCodec   runtime.Codec\n}\n\nfunc (s *DryRunnableStorage) Create(ctx context.Context, key string, obj, out runtime.Object, ttl uint64, dryRun bool) error {\n\tif dryRun {\n\t\tif err := s.Storage.Get(ctx, key, storage.GetOptions{}, out); err == nil {\n\t\t\treturn storage.NewKeyExistsError(key, 0)\n\t\t}\n\t\treturn s.copyInto(obj, out)\n\t}\n  // 这里，就是Create的真正调用\n\treturn s.Storage.Create(ctx, key, obj, out, ttl)\n}\n```\n\n\n\n## Storage Implement\n\n```go\n// Storage Interface 的定义，包括基本的增删改查，以及watch等等进阶操作\ntype Interface interface {\n\tVersioner() Versioner\n\tCreate(ctx context.Context, key string, obj, out runtime.Object, ttl uint64) error\n\tDelete(ctx context.Context, key string, out runtime.Object, preconditions *Preconditions, validateDeletion ValidateObjectFunc) error\n\tWatch(ctx context.Context, key string, opts ListOptions) (watch.Interface, error)\n\tWatchList(ctx context.Context, key string, opts ListOptions) (watch.Interface, error)\n\tGet(ctx context.Context, key string, opts GetOptions, objPtr runtime.Object) error\n\tGetToList(ctx context.Context, key string, opts ListOptions, listObj runtime.Object) error\n\tList(ctx context.Context, key string, opts ListOptions, listObj runtime.Object) error\n\tGuaranteedUpdate(\n\t\tctx context.Context, key string, ptrToType runtime.Object, ignoreNotFound bool,\n\t\tprecondtions *Preconditions, tryUpdate UpdateFunc, suggestion ...runtime.Object) error\n\tCount(key string) (int64, error)\n}\n\nfunc NewRawStorage(config *storagebackend.Config) (storage.Interface, factory.DestroyFunc, error) {\n\treturn factory.Create(*config)\n}\n\nfunc Create(c storagebackend.Config) (storage.Interface, DestroyFunc, error) {\n\tswitch c.Type {\n  // 已经不支持etcd2\n\tcase \"etcd2\":\n\t\treturn nil, nil, fmt.Errorf(\"%v is no longer a supported storage backend\", c.Type)\n  // 默认为etcd3版本\n\tcase storagebackend.StorageTypeUnset, storagebackend.StorageTypeETCD3:\n\t\treturn newETCD3Storage(c)\n\tdefault:\n\t\treturn nil, nil, fmt.Errorf(\"unknown storage type: %s\", c.Type)\n\t}\n}\n```\n\n\n\n## Summary\n\n我们对第一阶段学习kube-apiserver的知识点进行总结：\n\n1. `kube-apiserver` 包含三个apiserver`APIExtensionsServer`、`KubeAPIServer`和`AggregatorServer`\n   1. 三个APIServer底层均依赖通用的`GenericServer`，使用`go-restful`对外提供RESTful风格的API服务\n2. `kube-apiserver` 对请求进行 `Authentication`、`Authorization`和`Admission`三层验证\n3. 完成验证后，请求会根据路由规则，触发到对应资源的handler，主要包括数据的`预处理`和`保存`\n4. `kube-apiserver` 的底层存储为etcd v3，它被抽象为一种RESTStorage，使请求和存储操作一一对应\n\n","source":"_posts/k8s-007.md","raw":"---\ntitle: 【K8s源码品读】007：Phase 1 - kube-apiserver - Pod数据的保存\ndate: 2021-02-18 16:55:53\ntags:\n---\n\n## 聚焦目标\n\n理解Pod发送到`kube-apiserver`后是怎么保存的\n\n\n\n## 目录\n\n1. [RESTCreateStrategy创建的预处理](#RESTCreateStrategy)\n2. [REST Pod数据的存储](#Storage)\n3. [存储的底层实现](#storage-implement)\n4. [kube-apiserver第一阶段源码阅读总结](#summary)\n\n\n\n## RESTCreateStrategy\n\n```go\n// podStrategy 是封装了 Pod 的各类动作，这里我们先关注create这个操作\ntype podStrategy struct {\n\truntime.ObjectTyper\n\tnames.NameGenerator\n}\n\n// podStrategy 的接口\ntype RESTCreateStrategy interface {\n\truntime.ObjectTyper\n\tnames.NameGenerator\n  // 是否属于当前的 namespace\n\tNamespaceScoped() bool\n  // 准备创建前的检查\n\tPrepareForCreate(ctx context.Context, obj runtime.Object)\n  // 验证资源对象\n\tValidate(ctx context.Context, obj runtime.Object) field.ErrorList\n  // 规范化\n\tCanonicalize(obj runtime.Object)\n}\n\n// 完成了检查，我们就要保存数据了\n```\n\n\n\n## Storage\n\n```go\n// PodStorage 是 Pod 存储的实现，里面包含了多个存储的定义\ntype PodStorage struct {\n  // REST implements a RESTStorage for pods\n\tPod                 *REST\n  // BindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.\n\tBinding             *BindingREST\n  // LegacyBindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.\n\tLegacyBinding       *LegacyBindingREST\n\tEviction            *EvictionREST\n  // StatusREST implements the REST endpoint for changing the status of a pod.\n\tStatus              *StatusREST\n  // EphemeralContainersREST implements the REST endpoint for adding EphemeralContainers\n\tEphemeralContainers *EphemeralContainersREST\n\tLog                 *podrest.LogREST\n\tProxy               *podrest.ProxyREST\n\tExec                *podrest.ExecREST\n\tAttach              *podrest.AttachREST\n\tPortForward         *podrest.PortForwardREST\n}\n\n/*\n从上一节的map关系中，保存在REST中\nrestStorageMap := map[string]rest.Storage{\n\t\t\"pods\":             podStorage.Pod,\n}\n*/\ntype REST struct {\n\t*genericregistry.Store\n\tproxyTransport http.RoundTripper\n}\n\n// Store是一个通用的数据结构\ntype Store struct {\n\t// Storage定义\n\tStorage DryRunnableStorage\n}\n\n// DryRunnableStorage中的Storage是一个Interface\ntype DryRunnableStorage struct {\n\tStorage storage.Interface\n\tCodec   runtime.Codec\n}\n\nfunc (s *DryRunnableStorage) Create(ctx context.Context, key string, obj, out runtime.Object, ttl uint64, dryRun bool) error {\n\tif dryRun {\n\t\tif err := s.Storage.Get(ctx, key, storage.GetOptions{}, out); err == nil {\n\t\t\treturn storage.NewKeyExistsError(key, 0)\n\t\t}\n\t\treturn s.copyInto(obj, out)\n\t}\n  // 这里，就是Create的真正调用\n\treturn s.Storage.Create(ctx, key, obj, out, ttl)\n}\n```\n\n\n\n## Storage Implement\n\n```go\n// Storage Interface 的定义，包括基本的增删改查，以及watch等等进阶操作\ntype Interface interface {\n\tVersioner() Versioner\n\tCreate(ctx context.Context, key string, obj, out runtime.Object, ttl uint64) error\n\tDelete(ctx context.Context, key string, out runtime.Object, preconditions *Preconditions, validateDeletion ValidateObjectFunc) error\n\tWatch(ctx context.Context, key string, opts ListOptions) (watch.Interface, error)\n\tWatchList(ctx context.Context, key string, opts ListOptions) (watch.Interface, error)\n\tGet(ctx context.Context, key string, opts GetOptions, objPtr runtime.Object) error\n\tGetToList(ctx context.Context, key string, opts ListOptions, listObj runtime.Object) error\n\tList(ctx context.Context, key string, opts ListOptions, listObj runtime.Object) error\n\tGuaranteedUpdate(\n\t\tctx context.Context, key string, ptrToType runtime.Object, ignoreNotFound bool,\n\t\tprecondtions *Preconditions, tryUpdate UpdateFunc, suggestion ...runtime.Object) error\n\tCount(key string) (int64, error)\n}\n\nfunc NewRawStorage(config *storagebackend.Config) (storage.Interface, factory.DestroyFunc, error) {\n\treturn factory.Create(*config)\n}\n\nfunc Create(c storagebackend.Config) (storage.Interface, DestroyFunc, error) {\n\tswitch c.Type {\n  // 已经不支持etcd2\n\tcase \"etcd2\":\n\t\treturn nil, nil, fmt.Errorf(\"%v is no longer a supported storage backend\", c.Type)\n  // 默认为etcd3版本\n\tcase storagebackend.StorageTypeUnset, storagebackend.StorageTypeETCD3:\n\t\treturn newETCD3Storage(c)\n\tdefault:\n\t\treturn nil, nil, fmt.Errorf(\"unknown storage type: %s\", c.Type)\n\t}\n}\n```\n\n\n\n## Summary\n\n我们对第一阶段学习kube-apiserver的知识点进行总结：\n\n1. `kube-apiserver` 包含三个apiserver`APIExtensionsServer`、`KubeAPIServer`和`AggregatorServer`\n   1. 三个APIServer底层均依赖通用的`GenericServer`，使用`go-restful`对外提供RESTful风格的API服务\n2. `kube-apiserver` 对请求进行 `Authentication`、`Authorization`和`Admission`三层验证\n3. 完成验证后，请求会根据路由规则，触发到对应资源的handler，主要包括数据的`预处理`和`保存`\n4. `kube-apiserver` 的底层存储为etcd v3，它被抽象为一种RESTStorage，使请求和存储操作一一对应\n\n","slug":"k8s-007","published":1,"updated":"2021-02-18T08:59:37.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaogram0006a4qpddhj9uh0","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解Pod发送到<code>kube-apiserver</code>后是怎么保存的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#RESTCreateStrategy\">RESTCreateStrategy创建的预处理</a></li>\n<li><a href=\"#Storage\">REST Pod数据的存储</a></li>\n<li><a href=\"#storage-implement\">存储的底层实现</a></li>\n<li><a href=\"#summary\">kube-apiserver第一阶段源码阅读总结</a></li>\n</ol>\n<h2 id=\"RESTCreateStrategy\"><a href=\"#RESTCreateStrategy\" class=\"headerlink\" title=\"RESTCreateStrategy\"></a>RESTCreateStrategy</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// podStrategy 是封装了 Pod 的各类动作，这里我们先关注create这个操作</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> podStrategy <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\truntime.ObjectTyper</span><br><span class=\"line\">\tnames.NameGenerator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// podStrategy 的接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> RESTCreateStrategy <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\truntime.ObjectTyper</span><br><span class=\"line\">\tnames.NameGenerator</span><br><span class=\"line\">  <span class=\"comment\">// 是否属于当前的 namespace</span></span><br><span class=\"line\">\tNamespaceScoped() <span class=\"keyword\">bool</span></span><br><span class=\"line\">  <span class=\"comment\">// 准备创建前的检查</span></span><br><span class=\"line\">\tPrepareForCreate(ctx context.Context, obj runtime.Object)</span><br><span class=\"line\">  <span class=\"comment\">// 验证资源对象</span></span><br><span class=\"line\">\tValidate(ctx context.Context, obj runtime.Object) field.ErrorList</span><br><span class=\"line\">  <span class=\"comment\">// 规范化</span></span><br><span class=\"line\">\tCanonicalize(obj runtime.Object)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 完成了检查，我们就要保存数据了</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Storage\"><a href=\"#Storage\" class=\"headerlink\" title=\"Storage\"></a>Storage</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PodStorage 是 Pod 存储的实现，里面包含了多个存储的定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PodStorage <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// REST implements a RESTStorage for pods</span></span><br><span class=\"line\">\tPod                 *REST</span><br><span class=\"line\">  <span class=\"comment\">// BindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.</span></span><br><span class=\"line\">\tBinding             *BindingREST</span><br><span class=\"line\">  <span class=\"comment\">// LegacyBindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.</span></span><br><span class=\"line\">\tLegacyBinding       *LegacyBindingREST</span><br><span class=\"line\">\tEviction            *EvictionREST</span><br><span class=\"line\">  <span class=\"comment\">// StatusREST implements the REST endpoint for changing the status of a pod.</span></span><br><span class=\"line\">\tStatus              *StatusREST</span><br><span class=\"line\">  <span class=\"comment\">// EphemeralContainersREST implements the REST endpoint for adding EphemeralContainers</span></span><br><span class=\"line\">\tEphemeralContainers *EphemeralContainersREST</span><br><span class=\"line\">\tLog                 *podrest.LogREST</span><br><span class=\"line\">\tProxy               *podrest.ProxyREST</span><br><span class=\"line\">\tExec                *podrest.ExecREST</span><br><span class=\"line\">\tAttach              *podrest.AttachREST</span><br><span class=\"line\">\tPortForward         *podrest.PortForwardREST</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">从上一节的map关系中，保存在REST中</span></span><br><span class=\"line\"><span class=\"comment\">restStorageMap := map[string]rest.Storage&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t&quot;pods&quot;:             podStorage.Pod,</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> REST <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*genericregistry.Store</span><br><span class=\"line\">\tproxyTransport http.RoundTripper</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Store是一个通用的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Storage定义</span></span><br><span class=\"line\">\tStorage DryRunnableStorage</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DryRunnableStorage中的Storage是一个Interface</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> DryRunnableStorage <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tStorage storage.Interface</span><br><span class=\"line\">\tCodec   runtime.Codec</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *DryRunnableStorage)</span> <span class=\"title\">Create</span><span class=\"params\">(ctx context.Context, key <span class=\"keyword\">string</span>, obj, out runtime.Object, ttl <span class=\"keyword\">uint64</span>, dryRun <span class=\"keyword\">bool</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> dryRun &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := s.Storage.Get(ctx, key, storage.GetOptions&#123;&#125;, out); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> storage.NewKeyExistsError(key, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s.copyInto(obj, out)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 这里，就是Create的真正调用</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.Storage.Create(ctx, key, obj, out, ttl)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Storage-Implement\"><a href=\"#Storage-Implement\" class=\"headerlink\" title=\"Storage Implement\"></a>Storage Implement</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Storage Interface 的定义，包括基本的增删改查，以及watch等等进阶操作</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tVersioner() Versioner</span><br><span class=\"line\">\tCreate(ctx context.Context, key <span class=\"keyword\">string</span>, obj, out runtime.Object, ttl <span class=\"keyword\">uint64</span>) error</span><br><span class=\"line\">\tDelete(ctx context.Context, key <span class=\"keyword\">string</span>, out runtime.Object, preconditions *Preconditions, validateDeletion ValidateObjectFunc) error</span><br><span class=\"line\">\tWatch(ctx context.Context, key <span class=\"keyword\">string</span>, opts ListOptions) (watch.Interface, error)</span><br><span class=\"line\">\tWatchList(ctx context.Context, key <span class=\"keyword\">string</span>, opts ListOptions) (watch.Interface, error)</span><br><span class=\"line\">\tGet(ctx context.Context, key <span class=\"keyword\">string</span>, opts GetOptions, objPtr runtime.Object) error</span><br><span class=\"line\">\tGetToList(ctx context.Context, key <span class=\"keyword\">string</span>, opts ListOptions, listObj runtime.Object) error</span><br><span class=\"line\">\tList(ctx context.Context, key <span class=\"keyword\">string</span>, opts ListOptions, listObj runtime.Object) error</span><br><span class=\"line\">\tGuaranteedUpdate(</span><br><span class=\"line\">\t\tctx context.Context, key <span class=\"keyword\">string</span>, ptrToType runtime.Object, ignoreNotFound <span class=\"keyword\">bool</span>,</span><br><span class=\"line\">\t\tprecondtions *Preconditions, tryUpdate UpdateFunc, suggestion ...runtime.Object) error</span><br><span class=\"line\">\tCount(key <span class=\"keyword\">string</span>) (<span class=\"keyword\">int64</span>, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRawStorage</span><span class=\"params\">(config *storagebackend.Config)</span> <span class=\"params\">(storage.Interface, factory.DestroyFunc, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> factory.Create(*config)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Create</span><span class=\"params\">(c storagebackend.Config)</span> <span class=\"params\">(storage.Interface, DestroyFunc, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> c.Type &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 已经不支持etcd2</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;etcd2&quot;</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;%v is no longer a supported storage backend&quot;</span>, c.Type)</span><br><span class=\"line\">  <span class=\"comment\">// 默认为etcd3版本</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> storagebackend.StorageTypeUnset, storagebackend.StorageTypeETCD3:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> newETCD3Storage(c)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;unknown storage type: %s&quot;</span>, c.Type)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>我们对第一阶段学习kube-apiserver的知识点进行总结：</p>\n<ol>\n<li><code>kube-apiserver</code> 包含三个apiserver<code>APIExtensionsServer</code>、<code>KubeAPIServer</code>和<code>AggregatorServer</code><ol>\n<li>三个APIServer底层均依赖通用的<code>GenericServer</code>，使用<code>go-restful</code>对外提供RESTful风格的API服务</li>\n</ol>\n</li>\n<li><code>kube-apiserver</code> 对请求进行 <code>Authentication</code>、<code>Authorization</code>和<code>Admission</code>三层验证</li>\n<li>完成验证后，请求会根据路由规则，触发到对应资源的handler，主要包括数据的<code>预处理</code>和<code>保存</code></li>\n<li><code>kube-apiserver</code> 的底层存储为etcd v3，它被抽象为一种RESTStorage，使请求和存储操作一一对应</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解Pod发送到<code>kube-apiserver</code>后是怎么保存的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#RESTCreateStrategy\">RESTCreateStrategy创建的预处理</a></li>\n<li><a href=\"#Storage\">REST Pod数据的存储</a></li>\n<li><a href=\"#storage-implement\">存储的底层实现</a></li>\n<li><a href=\"#summary\">kube-apiserver第一阶段源码阅读总结</a></li>\n</ol>\n<h2 id=\"RESTCreateStrategy\"><a href=\"#RESTCreateStrategy\" class=\"headerlink\" title=\"RESTCreateStrategy\"></a>RESTCreateStrategy</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// podStrategy 是封装了 Pod 的各类动作，这里我们先关注create这个操作</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> podStrategy <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\truntime.ObjectTyper</span><br><span class=\"line\">\tnames.NameGenerator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// podStrategy 的接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> RESTCreateStrategy <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\truntime.ObjectTyper</span><br><span class=\"line\">\tnames.NameGenerator</span><br><span class=\"line\">  <span class=\"comment\">// 是否属于当前的 namespace</span></span><br><span class=\"line\">\tNamespaceScoped() <span class=\"keyword\">bool</span></span><br><span class=\"line\">  <span class=\"comment\">// 准备创建前的检查</span></span><br><span class=\"line\">\tPrepareForCreate(ctx context.Context, obj runtime.Object)</span><br><span class=\"line\">  <span class=\"comment\">// 验证资源对象</span></span><br><span class=\"line\">\tValidate(ctx context.Context, obj runtime.Object) field.ErrorList</span><br><span class=\"line\">  <span class=\"comment\">// 规范化</span></span><br><span class=\"line\">\tCanonicalize(obj runtime.Object)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 完成了检查，我们就要保存数据了</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Storage\"><a href=\"#Storage\" class=\"headerlink\" title=\"Storage\"></a>Storage</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PodStorage 是 Pod 存储的实现，里面包含了多个存储的定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PodStorage <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// REST implements a RESTStorage for pods</span></span><br><span class=\"line\">\tPod                 *REST</span><br><span class=\"line\">  <span class=\"comment\">// BindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.</span></span><br><span class=\"line\">\tBinding             *BindingREST</span><br><span class=\"line\">  <span class=\"comment\">// LegacyBindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.</span></span><br><span class=\"line\">\tLegacyBinding       *LegacyBindingREST</span><br><span class=\"line\">\tEviction            *EvictionREST</span><br><span class=\"line\">  <span class=\"comment\">// StatusREST implements the REST endpoint for changing the status of a pod.</span></span><br><span class=\"line\">\tStatus              *StatusREST</span><br><span class=\"line\">  <span class=\"comment\">// EphemeralContainersREST implements the REST endpoint for adding EphemeralContainers</span></span><br><span class=\"line\">\tEphemeralContainers *EphemeralContainersREST</span><br><span class=\"line\">\tLog                 *podrest.LogREST</span><br><span class=\"line\">\tProxy               *podrest.ProxyREST</span><br><span class=\"line\">\tExec                *podrest.ExecREST</span><br><span class=\"line\">\tAttach              *podrest.AttachREST</span><br><span class=\"line\">\tPortForward         *podrest.PortForwardREST</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">从上一节的map关系中，保存在REST中</span></span><br><span class=\"line\"><span class=\"comment\">restStorageMap := map[string]rest.Storage&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t&quot;pods&quot;:             podStorage.Pod,</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> REST <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*genericregistry.Store</span><br><span class=\"line\">\tproxyTransport http.RoundTripper</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Store是一个通用的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Storage定义</span></span><br><span class=\"line\">\tStorage DryRunnableStorage</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DryRunnableStorage中的Storage是一个Interface</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> DryRunnableStorage <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tStorage storage.Interface</span><br><span class=\"line\">\tCodec   runtime.Codec</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *DryRunnableStorage)</span> <span class=\"title\">Create</span><span class=\"params\">(ctx context.Context, key <span class=\"keyword\">string</span>, obj, out runtime.Object, ttl <span class=\"keyword\">uint64</span>, dryRun <span class=\"keyword\">bool</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> dryRun &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := s.Storage.Get(ctx, key, storage.GetOptions&#123;&#125;, out); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> storage.NewKeyExistsError(key, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s.copyInto(obj, out)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 这里，就是Create的真正调用</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s.Storage.Create(ctx, key, obj, out, ttl)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Storage-Implement\"><a href=\"#Storage-Implement\" class=\"headerlink\" title=\"Storage Implement\"></a>Storage Implement</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Storage Interface 的定义，包括基本的增删改查，以及watch等等进阶操作</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tVersioner() Versioner</span><br><span class=\"line\">\tCreate(ctx context.Context, key <span class=\"keyword\">string</span>, obj, out runtime.Object, ttl <span class=\"keyword\">uint64</span>) error</span><br><span class=\"line\">\tDelete(ctx context.Context, key <span class=\"keyword\">string</span>, out runtime.Object, preconditions *Preconditions, validateDeletion ValidateObjectFunc) error</span><br><span class=\"line\">\tWatch(ctx context.Context, key <span class=\"keyword\">string</span>, opts ListOptions) (watch.Interface, error)</span><br><span class=\"line\">\tWatchList(ctx context.Context, key <span class=\"keyword\">string</span>, opts ListOptions) (watch.Interface, error)</span><br><span class=\"line\">\tGet(ctx context.Context, key <span class=\"keyword\">string</span>, opts GetOptions, objPtr runtime.Object) error</span><br><span class=\"line\">\tGetToList(ctx context.Context, key <span class=\"keyword\">string</span>, opts ListOptions, listObj runtime.Object) error</span><br><span class=\"line\">\tList(ctx context.Context, key <span class=\"keyword\">string</span>, opts ListOptions, listObj runtime.Object) error</span><br><span class=\"line\">\tGuaranteedUpdate(</span><br><span class=\"line\">\t\tctx context.Context, key <span class=\"keyword\">string</span>, ptrToType runtime.Object, ignoreNotFound <span class=\"keyword\">bool</span>,</span><br><span class=\"line\">\t\tprecondtions *Preconditions, tryUpdate UpdateFunc, suggestion ...runtime.Object) error</span><br><span class=\"line\">\tCount(key <span class=\"keyword\">string</span>) (<span class=\"keyword\">int64</span>, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRawStorage</span><span class=\"params\">(config *storagebackend.Config)</span> <span class=\"params\">(storage.Interface, factory.DestroyFunc, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> factory.Create(*config)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Create</span><span class=\"params\">(c storagebackend.Config)</span> <span class=\"params\">(storage.Interface, DestroyFunc, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> c.Type &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 已经不支持etcd2</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;etcd2&quot;</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;%v is no longer a supported storage backend&quot;</span>, c.Type)</span><br><span class=\"line\">  <span class=\"comment\">// 默认为etcd3版本</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> storagebackend.StorageTypeUnset, storagebackend.StorageTypeETCD3:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> newETCD3Storage(c)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;unknown storage type: %s&quot;</span>, c.Type)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>我们对第一阶段学习kube-apiserver的知识点进行总结：</p>\n<ol>\n<li><code>kube-apiserver</code> 包含三个apiserver<code>APIExtensionsServer</code>、<code>KubeAPIServer</code>和<code>AggregatorServer</code><ol>\n<li>三个APIServer底层均依赖通用的<code>GenericServer</code>，使用<code>go-restful</code>对外提供RESTful风格的API服务</li>\n</ol>\n</li>\n<li><code>kube-apiserver</code> 对请求进行 <code>Authentication</code>、<code>Authorization</code>和<code>Admission</code>三层验证</li>\n<li>完成验证后，请求会根据路由规则，触发到对应资源的handler，主要包括数据的<code>预处理</code>和<code>保存</code></li>\n<li><code>kube-apiserver</code> 的底层存储为etcd v3，它被抽象为一种RESTStorage，使请求和存储操作一一对应</li>\n</ol>\n"},{"title":"【K8s源码品读】008：Phase 1 - kube-scheduler - 初探调度的启动流程与算法","date":"2021-02-18T08:55:54.000Z","_content":"\n## 聚焦目标\n\n理解kube-scheduler启动的流程\n\n\n\n## 目录\n\n1. [kube-scheduler的启动](#run)\n2. [Scheduler的注册](#Scheduler)\n3. [了解一个最简单的算法NodeName](#NodeName)\n\n\n\n## run\n\n```go\n// kube-scheduler 类似于kube-apiserver，是个常驻进程，查看其对应的Run函数\nfunc runCommand(cmd *cobra.Command, opts *options.Options, registryOptions ...Option) error {\n\t// 根据入参，返回配置cc与调度sched\n   cc, sched, err := Setup(ctx, opts, registryOptions...)\n\t// 运行\n   return Run(ctx, cc, sched)\n}\n\n// 运行调度策略\nfunc Run(ctx context.Context, cc *schedulerserverconfig.CompletedConfig, sched *scheduler.Scheduler) error {\n\t// 将配置注册到configz中，会保存在一个全局map里\n\tif cz, err := configz.New(\"componentconfig\"); err == nil {\n\t\tcz.Set(cc.ComponentConfig)\n\t} else {\n\t\treturn fmt.Errorf(\"unable to register configz: %s\", err)\n\t}\n\n\t// 事件广播管理器，涉及到k8s里的一个核心资源 - Event事件，暂时不细讲\n\tcc.EventBroadcaster.StartRecordingToSink(ctx.Done())\n\n\t// 健康监测的服务\n\tvar checks []healthz.HealthChecker\n\n\t// 异步各个Informer。Informer是kube-scheduler的一个重点\n\tgo cc.PodInformer.Informer().Run(ctx.Done())\n\tcc.InformerFactory.Start(ctx.Done())\n\tcc.InformerFactory.WaitForCacheSync(ctx.Done())\n\n\t// 选举Leader的工作，因为Master节点可以存在多个，选举一个作为Leader\n\tif cc.LeaderElection != nil {\n\t\tcc.LeaderElection.Callbacks = leaderelection.LeaderCallbacks{\n      // 两个钩子函数，开启Leading时运行调度，结束时打印报错\n\t\t\tOnStartedLeading: sched.Run,\n\t\t\tOnStoppedLeading: func() {\n\t\t\t\tklog.Fatalf(\"leaderelection lost\")\n\t\t\t},\n\t\t}\n\t\tleaderElector, err := leaderelection.NewLeaderElector(*cc.LeaderElection)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't create leader elector: %v\", err)\n\t\t}\n    // 参与选举的会持续通信\n\t\tleaderElector.Run(ctx)\n\t\treturn fmt.Errorf(\"lost lease\")\n\t}\n\n\t// 不参与选举的，也就是单节点的情况时，在这里运行\n\tsched.Run(ctx)\n\treturn fmt.Errorf(\"finished without leader elect\")\n}\n\n/*\n到这里，我们已经接触了kube-scheduler的2个核心概念：\n1. scheduler：正如程序名kube-scheduler，这个进程的核心作用是进行调度，会涉及到多种调度策略\n2. Informer：k8s中有各种类型的资源，包括自定义的。而Informer的实现就将调度和资源结合了起来\n*/\n```\n\n\n\n## Scheduler\n\n```go\n// 在创建scheduler的函数\nfunc Setup() {\n\t// 创建scheduler，包括多个选项\n\tsched, err := scheduler.New(cc.Client,\n\t\tcc.InformerFactory,\n\t\tcc.PodInformer,\n\t\trecorderFactory,\n\t\tctx.Done(),\n\t\tscheduler.WithProfiles(cc.ComponentConfig.Profiles...),\n\t\tscheduler.WithAlgorithmSource(cc.ComponentConfig.AlgorithmSource),\n\t\tscheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),\n\t\tscheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),\n\t\tscheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),\n\t\tscheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),\n\t\tscheduler.WithExtenders(cc.ComponentConfig.Extenders...),\n\t)\n\treturn &cc, sched, nil\n}\n\n// 我们再看一下New这个函数\nfunc New() (*Scheduler, error) {\n  // 先注册了所有的算法，保存到一个 map[string]PluginFactory 中\n  registry := frameworkplugins.NewInTreeRegistry()\n  \n  // 重点看一下Scheduler的创建过程\n  var sched *Scheduler\n\tsource := options.schedulerAlgorithmSource\n\tswitch {\n   // 根据Provider创建，重点看这里\n\tcase source.Provider != nil:\n\t\tsc, err := configurator.createFromProvider(*source.Provider)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"couldn't create scheduler using provider %q: %v\", *source.Provider, err)\n\t\t}\n\t\tsched = sc\n  // 根据用户设置创建，来自文件或者ConfigMap\n\tcase source.Policy != nil:\n\t\tpolicy := &schedulerapi.Policy{}\n\t\tswitch {\n\t\tcase source.Policy.File != nil:\n\t\t\tif err := initPolicyFromFile(source.Policy.File.Path, policy); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase source.Policy.ConfigMap != nil:\n\t\t\tif err := initPolicyFromConfigMap(client, source.Policy.ConfigMap, policy); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tconfigurator.extenders = policy.Extenders\n\t\tsc, err := configurator.createFromConfig(*policy)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"couldn't create scheduler from policy: %v\", err)\n\t\t}\n\t\tsched = sc\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported algorithm source: %v\", source)\n\t}\n}\n\n// 创建\nfunc (c *Configurator) createFromProvider(providerName string) (*Scheduler, error) {\n\tklog.V(2).Infof(\"Creating scheduler from algorithm provider '%v'\", providerName)\n  // 实例化算法的Registry\n\tr := algorithmprovider.NewRegistry()\n\tdefaultPlugins, exist := r[providerName]\n\tif !exist {\n\t\treturn nil, fmt.Errorf(\"algorithm provider %q is not registered\", providerName)\n\t}\n\n  // 将各种算法作为plugin进行设置\n\tfor i := range c.profiles {\n\t\tprof := &c.profiles[i]\n\t\tplugins := &schedulerapi.Plugins{}\n\t\tplugins.Append(defaultPlugins)\n\t\tplugins.Apply(prof.Plugins)\n\t\tprof.Plugins = plugins\n\t}\n\treturn c.create()\n}\n\n// 从这个初始化中可以看到，主要分为2类：默认与ClusterAutoscaler两种算法\nfunc NewRegistry() Registry {\n  // 默认算法包括过滤、打分、绑定等，有兴趣的去源码中逐个阅读\n\tdefaultConfig := getDefaultConfig()\n\tapplyFeatureGates(defaultConfig)\n\t// ClusterAutoscaler 是集群自动扩展的算法，被单独拎出来，\n\tcaConfig := getClusterAutoscalerConfig()\n\tapplyFeatureGates(caConfig)\n\n\treturn Registry{\n\t\tschedulerapi.SchedulerDefaultProviderName: defaultConfig,\n\t\tClusterAutoscalerProvider:                 caConfig,\n\t}\n}\n/*\n在这里，熟悉k8s的朋友会有个疑问：以前听说kubernets的调度有个Predicate和Priority两个算法，这里怎么没有分类？\n这个疑问，我们在后面具体场景时再进行分析。\n*/\n```\n\n\n\n## NodeName\n\n```go\n// 为了加深大家对Plugin的印象，我选择一个最简单的示例：根据Pod的spec字段中的NodeName，分配到指定名称的节点\npackage nodename\n\nimport (\n\t\"context\"\n\n\tv1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\tframework \"k8s.io/kubernetes/pkg/scheduler/framework/v1alpha1\"\n)\n\ntype NodeName struct{}\n\nvar _ framework.FilterPlugin = &NodeName{}\n\n// 这个调度算法的名称和错误信息\nconst (\n\tName = \"NodeName\"\n\tErrReason = \"node(s) didn't match the requested hostname\"\n)\n\n// 调度算法的明明\nfunc (pl *NodeName) Name() string {\n\treturn Name\n}\n\n// 过滤功能，这个就是NodeName算法的实现\nfunc (pl *NodeName) Filter(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo) *framework.Status {\n  // 找不到Node\n\tif nodeInfo.Node() == nil {\n\t\treturn framework.NewStatus(framework.Error, \"node not found\")\n\t}\n  // 匹配不到，返回错误\n\tif !Fits(pod, nodeInfo) {\n\t\treturn framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)\n\t}\n\treturn nil\n}\n\n/*\n  匹配的算法，两种条件满足一个就认为成功\n  1. spec没有填NodeName \n  2.spec的NodeName和节点匹配\n*/\nfunc Fits(pod *v1.Pod, nodeInfo *framework.NodeInfo) bool {\n\treturn len(pod.Spec.NodeName) == 0 || pod.Spec.NodeName == nodeInfo.Node().Name\n}\n\n// 初始化\nfunc New(_ runtime.Object, _ framework.FrameworkHandle) (framework.Plugin, error) {\n\treturn &NodeName{}, nil\n}\n```\n\n","source":"_posts/k8s-008.md","raw":"---\ntitle: 【K8s源码品读】008：Phase 1 - kube-scheduler - 初探调度的启动流程与算法\ndate: 2021-02-18 16:55:54\ntags:\n---\n\n## 聚焦目标\n\n理解kube-scheduler启动的流程\n\n\n\n## 目录\n\n1. [kube-scheduler的启动](#run)\n2. [Scheduler的注册](#Scheduler)\n3. [了解一个最简单的算法NodeName](#NodeName)\n\n\n\n## run\n\n```go\n// kube-scheduler 类似于kube-apiserver，是个常驻进程，查看其对应的Run函数\nfunc runCommand(cmd *cobra.Command, opts *options.Options, registryOptions ...Option) error {\n\t// 根据入参，返回配置cc与调度sched\n   cc, sched, err := Setup(ctx, opts, registryOptions...)\n\t// 运行\n   return Run(ctx, cc, sched)\n}\n\n// 运行调度策略\nfunc Run(ctx context.Context, cc *schedulerserverconfig.CompletedConfig, sched *scheduler.Scheduler) error {\n\t// 将配置注册到configz中，会保存在一个全局map里\n\tif cz, err := configz.New(\"componentconfig\"); err == nil {\n\t\tcz.Set(cc.ComponentConfig)\n\t} else {\n\t\treturn fmt.Errorf(\"unable to register configz: %s\", err)\n\t}\n\n\t// 事件广播管理器，涉及到k8s里的一个核心资源 - Event事件，暂时不细讲\n\tcc.EventBroadcaster.StartRecordingToSink(ctx.Done())\n\n\t// 健康监测的服务\n\tvar checks []healthz.HealthChecker\n\n\t// 异步各个Informer。Informer是kube-scheduler的一个重点\n\tgo cc.PodInformer.Informer().Run(ctx.Done())\n\tcc.InformerFactory.Start(ctx.Done())\n\tcc.InformerFactory.WaitForCacheSync(ctx.Done())\n\n\t// 选举Leader的工作，因为Master节点可以存在多个，选举一个作为Leader\n\tif cc.LeaderElection != nil {\n\t\tcc.LeaderElection.Callbacks = leaderelection.LeaderCallbacks{\n      // 两个钩子函数，开启Leading时运行调度，结束时打印报错\n\t\t\tOnStartedLeading: sched.Run,\n\t\t\tOnStoppedLeading: func() {\n\t\t\t\tklog.Fatalf(\"leaderelection lost\")\n\t\t\t},\n\t\t}\n\t\tleaderElector, err := leaderelection.NewLeaderElector(*cc.LeaderElection)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't create leader elector: %v\", err)\n\t\t}\n    // 参与选举的会持续通信\n\t\tleaderElector.Run(ctx)\n\t\treturn fmt.Errorf(\"lost lease\")\n\t}\n\n\t// 不参与选举的，也就是单节点的情况时，在这里运行\n\tsched.Run(ctx)\n\treturn fmt.Errorf(\"finished without leader elect\")\n}\n\n/*\n到这里，我们已经接触了kube-scheduler的2个核心概念：\n1. scheduler：正如程序名kube-scheduler，这个进程的核心作用是进行调度，会涉及到多种调度策略\n2. Informer：k8s中有各种类型的资源，包括自定义的。而Informer的实现就将调度和资源结合了起来\n*/\n```\n\n\n\n## Scheduler\n\n```go\n// 在创建scheduler的函数\nfunc Setup() {\n\t// 创建scheduler，包括多个选项\n\tsched, err := scheduler.New(cc.Client,\n\t\tcc.InformerFactory,\n\t\tcc.PodInformer,\n\t\trecorderFactory,\n\t\tctx.Done(),\n\t\tscheduler.WithProfiles(cc.ComponentConfig.Profiles...),\n\t\tscheduler.WithAlgorithmSource(cc.ComponentConfig.AlgorithmSource),\n\t\tscheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),\n\t\tscheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),\n\t\tscheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),\n\t\tscheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),\n\t\tscheduler.WithExtenders(cc.ComponentConfig.Extenders...),\n\t)\n\treturn &cc, sched, nil\n}\n\n// 我们再看一下New这个函数\nfunc New() (*Scheduler, error) {\n  // 先注册了所有的算法，保存到一个 map[string]PluginFactory 中\n  registry := frameworkplugins.NewInTreeRegistry()\n  \n  // 重点看一下Scheduler的创建过程\n  var sched *Scheduler\n\tsource := options.schedulerAlgorithmSource\n\tswitch {\n   // 根据Provider创建，重点看这里\n\tcase source.Provider != nil:\n\t\tsc, err := configurator.createFromProvider(*source.Provider)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"couldn't create scheduler using provider %q: %v\", *source.Provider, err)\n\t\t}\n\t\tsched = sc\n  // 根据用户设置创建，来自文件或者ConfigMap\n\tcase source.Policy != nil:\n\t\tpolicy := &schedulerapi.Policy{}\n\t\tswitch {\n\t\tcase source.Policy.File != nil:\n\t\t\tif err := initPolicyFromFile(source.Policy.File.Path, policy); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase source.Policy.ConfigMap != nil:\n\t\t\tif err := initPolicyFromConfigMap(client, source.Policy.ConfigMap, policy); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tconfigurator.extenders = policy.Extenders\n\t\tsc, err := configurator.createFromConfig(*policy)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"couldn't create scheduler from policy: %v\", err)\n\t\t}\n\t\tsched = sc\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported algorithm source: %v\", source)\n\t}\n}\n\n// 创建\nfunc (c *Configurator) createFromProvider(providerName string) (*Scheduler, error) {\n\tklog.V(2).Infof(\"Creating scheduler from algorithm provider '%v'\", providerName)\n  // 实例化算法的Registry\n\tr := algorithmprovider.NewRegistry()\n\tdefaultPlugins, exist := r[providerName]\n\tif !exist {\n\t\treturn nil, fmt.Errorf(\"algorithm provider %q is not registered\", providerName)\n\t}\n\n  // 将各种算法作为plugin进行设置\n\tfor i := range c.profiles {\n\t\tprof := &c.profiles[i]\n\t\tplugins := &schedulerapi.Plugins{}\n\t\tplugins.Append(defaultPlugins)\n\t\tplugins.Apply(prof.Plugins)\n\t\tprof.Plugins = plugins\n\t}\n\treturn c.create()\n}\n\n// 从这个初始化中可以看到，主要分为2类：默认与ClusterAutoscaler两种算法\nfunc NewRegistry() Registry {\n  // 默认算法包括过滤、打分、绑定等，有兴趣的去源码中逐个阅读\n\tdefaultConfig := getDefaultConfig()\n\tapplyFeatureGates(defaultConfig)\n\t// ClusterAutoscaler 是集群自动扩展的算法，被单独拎出来，\n\tcaConfig := getClusterAutoscalerConfig()\n\tapplyFeatureGates(caConfig)\n\n\treturn Registry{\n\t\tschedulerapi.SchedulerDefaultProviderName: defaultConfig,\n\t\tClusterAutoscalerProvider:                 caConfig,\n\t}\n}\n/*\n在这里，熟悉k8s的朋友会有个疑问：以前听说kubernets的调度有个Predicate和Priority两个算法，这里怎么没有分类？\n这个疑问，我们在后面具体场景时再进行分析。\n*/\n```\n\n\n\n## NodeName\n\n```go\n// 为了加深大家对Plugin的印象，我选择一个最简单的示例：根据Pod的spec字段中的NodeName，分配到指定名称的节点\npackage nodename\n\nimport (\n\t\"context\"\n\n\tv1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\tframework \"k8s.io/kubernetes/pkg/scheduler/framework/v1alpha1\"\n)\n\ntype NodeName struct{}\n\nvar _ framework.FilterPlugin = &NodeName{}\n\n// 这个调度算法的名称和错误信息\nconst (\n\tName = \"NodeName\"\n\tErrReason = \"node(s) didn't match the requested hostname\"\n)\n\n// 调度算法的明明\nfunc (pl *NodeName) Name() string {\n\treturn Name\n}\n\n// 过滤功能，这个就是NodeName算法的实现\nfunc (pl *NodeName) Filter(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo) *framework.Status {\n  // 找不到Node\n\tif nodeInfo.Node() == nil {\n\t\treturn framework.NewStatus(framework.Error, \"node not found\")\n\t}\n  // 匹配不到，返回错误\n\tif !Fits(pod, nodeInfo) {\n\t\treturn framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)\n\t}\n\treturn nil\n}\n\n/*\n  匹配的算法，两种条件满足一个就认为成功\n  1. spec没有填NodeName \n  2.spec的NodeName和节点匹配\n*/\nfunc Fits(pod *v1.Pod, nodeInfo *framework.NodeInfo) bool {\n\treturn len(pod.Spec.NodeName) == 0 || pod.Spec.NodeName == nodeInfo.Node().Name\n}\n\n// 初始化\nfunc New(_ runtime.Object, _ framework.FrameworkHandle) (framework.Plugin, error) {\n\treturn &NodeName{}, nil\n}\n```\n\n","slug":"k8s-008","published":1,"updated":"2021-02-18T08:59:53.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaogram0007a4qp8hc9a7wj","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解kube-scheduler启动的流程</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#run\">kube-scheduler的启动</a></li>\n<li><a href=\"#Scheduler\">Scheduler的注册</a></li>\n<li><a href=\"#NodeName\">了解一个最简单的算法NodeName</a></li>\n</ol>\n<h2 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// kube-scheduler 类似于kube-apiserver，是个常驻进程，查看其对应的Run函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">runCommand</span><span class=\"params\">(cmd *cobra.Command, opts *options.Options, registryOptions ...Option)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据入参，返回配置cc与调度sched</span></span><br><span class=\"line\">   cc, sched, err := Setup(ctx, opts, registryOptions...)</span><br><span class=\"line\">\t<span class=\"comment\">// 运行</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> Run(ctx, cc, sched)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行调度策略</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Run</span><span class=\"params\">(ctx context.Context, cc *schedulerserverconfig.CompletedConfig, sched *scheduler.Scheduler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将配置注册到configz中，会保存在一个全局map里</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cz, err := configz.New(<span class=\"string\">&quot;componentconfig&quot;</span>); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tcz.Set(cc.ComponentConfig)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;unable to register configz: %s&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件广播管理器，涉及到k8s里的一个核心资源 - Event事件，暂时不细讲</span></span><br><span class=\"line\">\tcc.EventBroadcaster.StartRecordingToSink(ctx.Done())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 健康监测的服务</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> checks []healthz.HealthChecker</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 异步各个Informer。Informer是kube-scheduler的一个重点</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> cc.PodInformer.Informer().Run(ctx.Done())</span><br><span class=\"line\">\tcc.InformerFactory.Start(ctx.Done())</span><br><span class=\"line\">\tcc.InformerFactory.WaitForCacheSync(ctx.Done())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 选举Leader的工作，因为Master节点可以存在多个，选举一个作为Leader</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cc.LeaderElection != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tcc.LeaderElection.Callbacks = leaderelection.LeaderCallbacks&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 两个钩子函数，开启Leading时运行调度，结束时打印报错</span></span><br><span class=\"line\">\t\t\tOnStartedLeading: sched.Run,</span><br><span class=\"line\">\t\t\tOnStoppedLeading: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\tklog.Fatalf(<span class=\"string\">&quot;leaderelection lost&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tleaderElector, err := leaderelection.NewLeaderElector(*cc.LeaderElection)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;couldn&#x27;t create leader elector: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 参与选举的会持续通信</span></span><br><span class=\"line\">\t\tleaderElector.Run(ctx)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;lost lease&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 不参与选举的，也就是单节点的情况时，在这里运行</span></span><br><span class=\"line\">\tsched.Run(ctx)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;finished without leader elect&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">到这里，我们已经接触了kube-scheduler的2个核心概念：</span></span><br><span class=\"line\"><span class=\"comment\">1. scheduler：正如程序名kube-scheduler，这个进程的核心作用是进行调度，会涉及到多种调度策略</span></span><br><span class=\"line\"><span class=\"comment\">2. Informer：k8s中有各种类型的资源，包括自定义的。而Informer的实现就将调度和资源结合了起来</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在创建scheduler的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Setup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建scheduler，包括多个选项</span></span><br><span class=\"line\">\tsched, err := scheduler.New(cc.Client,</span><br><span class=\"line\">\t\tcc.InformerFactory,</span><br><span class=\"line\">\t\tcc.PodInformer,</span><br><span class=\"line\">\t\trecorderFactory,</span><br><span class=\"line\">\t\tctx.Done(),</span><br><span class=\"line\">\t\tscheduler.WithProfiles(cc.ComponentConfig.Profiles...),</span><br><span class=\"line\">\t\tscheduler.WithAlgorithmSource(cc.ComponentConfig.AlgorithmSource),</span><br><span class=\"line\">\t\tscheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span><br><span class=\"line\">\t\tscheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),</span><br><span class=\"line\">\t\tscheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),</span><br><span class=\"line\">\t\tscheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),</span><br><span class=\"line\">\t\tscheduler.WithExtenders(cc.ComponentConfig.Extenders...),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;cc, sched, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们再看一下New这个函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先注册了所有的算法，保存到一个 map[string]PluginFactory 中</span></span><br><span class=\"line\">  registry := frameworkplugins.NewInTreeRegistry()</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 重点看一下Scheduler的创建过程</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> sched *Scheduler</span><br><span class=\"line\">\tsource := options.schedulerAlgorithmSource</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 根据Provider创建，重点看这里</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> source.Provider != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\tsc, err := configurator.createFromProvider(*source.Provider)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;couldn&#x27;t create scheduler using provider %q: %v&quot;</span>, *source.Provider, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsched = sc</span><br><span class=\"line\">  <span class=\"comment\">// 根据用户设置创建，来自文件或者ConfigMap</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> source.Policy != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\tpolicy := &amp;schedulerapi.Policy&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> source.Policy.File != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := initPolicyFromFile(source.Policy.File.Path, policy); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> source.Policy.ConfigMap != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := initPolicyFromConfigMap(client, source.Policy.ConfigMap, policy); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tconfigurator.extenders = policy.Extenders</span><br><span class=\"line\">\t\tsc, err := configurator.createFromConfig(*policy)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;couldn&#x27;t create scheduler from policy: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsched = sc</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;unsupported algorithm source: %v&quot;</span>, source)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">createFromProvider</span><span class=\"params\">(providerName <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;Creating scheduler from algorithm provider &#x27;%v&#x27;&quot;</span>, providerName)</span><br><span class=\"line\">  <span class=\"comment\">// 实例化算法的Registry</span></span><br><span class=\"line\">\tr := algorithmprovider.NewRegistry()</span><br><span class=\"line\">\tdefaultPlugins, exist := r[providerName]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !exist &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;algorithm provider %q is not registered&quot;</span>, providerName)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将各种算法作为plugin进行设置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> c.profiles &#123;</span><br><span class=\"line\">\t\tprof := &amp;c.profiles[i]</span><br><span class=\"line\">\t\tplugins := &amp;schedulerapi.Plugins&#123;&#125;</span><br><span class=\"line\">\t\tplugins.Append(defaultPlugins)</span><br><span class=\"line\">\t\tplugins.Apply(prof.Plugins)</span><br><span class=\"line\">\t\tprof.Plugins = plugins</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从这个初始化中可以看到，主要分为2类：默认与ClusterAutoscaler两种算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRegistry</span><span class=\"params\">()</span> <span class=\"title\">Registry</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 默认算法包括过滤、打分、绑定等，有兴趣的去源码中逐个阅读</span></span><br><span class=\"line\">\tdefaultConfig := getDefaultConfig()</span><br><span class=\"line\">\tapplyFeatureGates(defaultConfig)</span><br><span class=\"line\">\t<span class=\"comment\">// ClusterAutoscaler 是集群自动扩展的算法，被单独拎出来，</span></span><br><span class=\"line\">\tcaConfig := getClusterAutoscalerConfig()</span><br><span class=\"line\">\tapplyFeatureGates(caConfig)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Registry&#123;</span><br><span class=\"line\">\t\tschedulerapi.SchedulerDefaultProviderName: defaultConfig,</span><br><span class=\"line\">\t\tClusterAutoscalerProvider:                 caConfig,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">在这里，熟悉k8s的朋友会有个疑问：以前听说kubernets的调度有个Predicate和Priority两个算法，这里怎么没有分类？</span></span><br><span class=\"line\"><span class=\"comment\">这个疑问，我们在后面具体场景时再进行分析。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"NodeName\"><a href=\"#NodeName\" class=\"headerlink\" title=\"NodeName\"></a>NodeName</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为了加深大家对Plugin的印象，我选择一个最简单的示例：根据Pod的spec字段中的NodeName，分配到指定名称的节点</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> nodename</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tv1 <span class=\"string\">&quot;k8s.io/api/core/v1&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class=\"line\">\tframework <span class=\"string\">&quot;k8s.io/kubernetes/pkg/scheduler/framework/v1alpha1&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> NodeName <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ framework.FilterPlugin = &amp;NodeName&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个调度算法的名称和错误信息</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tName = <span class=\"string\">&quot;NodeName&quot;</span></span><br><span class=\"line\">\tErrReason = <span class=\"string\">&quot;node(s) didn&#x27;t match the requested hostname&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调度算法的明明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pl *NodeName)</span> <span class=\"title\">Name</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 过滤功能，这个就是NodeName算法的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pl *NodeName)</span> <span class=\"title\">Filter</span><span class=\"params\">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class=\"title\">framework</span>.<span class=\"title\">Status</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 找不到Node</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> nodeInfo.Node() == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> framework.NewStatus(framework.Error, <span class=\"string\">&quot;node not found&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 匹配不到，返回错误</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !Fits(pod, nodeInfo) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  匹配的算法，两种条件满足一个就认为成功</span></span><br><span class=\"line\"><span class=\"comment\">  1. spec没有填NodeName </span></span><br><span class=\"line\"><span class=\"comment\">  2.spec的NodeName和节点匹配</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fits</span><span class=\"params\">(pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(pod.Spec.NodeName) == <span class=\"number\">0</span> || pod.Spec.NodeName == nodeInfo.Node().Name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(_ runtime.Object, _ framework.FrameworkHandle)</span> <span class=\"params\">(framework.Plugin, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;NodeName&#123;&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解kube-scheduler启动的流程</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#run\">kube-scheduler的启动</a></li>\n<li><a href=\"#Scheduler\">Scheduler的注册</a></li>\n<li><a href=\"#NodeName\">了解一个最简单的算法NodeName</a></li>\n</ol>\n<h2 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// kube-scheduler 类似于kube-apiserver，是个常驻进程，查看其对应的Run函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">runCommand</span><span class=\"params\">(cmd *cobra.Command, opts *options.Options, registryOptions ...Option)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据入参，返回配置cc与调度sched</span></span><br><span class=\"line\">   cc, sched, err := Setup(ctx, opts, registryOptions...)</span><br><span class=\"line\">\t<span class=\"comment\">// 运行</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> Run(ctx, cc, sched)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行调度策略</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Run</span><span class=\"params\">(ctx context.Context, cc *schedulerserverconfig.CompletedConfig, sched *scheduler.Scheduler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将配置注册到configz中，会保存在一个全局map里</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cz, err := configz.New(<span class=\"string\">&quot;componentconfig&quot;</span>); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tcz.Set(cc.ComponentConfig)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;unable to register configz: %s&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件广播管理器，涉及到k8s里的一个核心资源 - Event事件，暂时不细讲</span></span><br><span class=\"line\">\tcc.EventBroadcaster.StartRecordingToSink(ctx.Done())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 健康监测的服务</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> checks []healthz.HealthChecker</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 异步各个Informer。Informer是kube-scheduler的一个重点</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> cc.PodInformer.Informer().Run(ctx.Done())</span><br><span class=\"line\">\tcc.InformerFactory.Start(ctx.Done())</span><br><span class=\"line\">\tcc.InformerFactory.WaitForCacheSync(ctx.Done())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 选举Leader的工作，因为Master节点可以存在多个，选举一个作为Leader</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cc.LeaderElection != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tcc.LeaderElection.Callbacks = leaderelection.LeaderCallbacks&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 两个钩子函数，开启Leading时运行调度，结束时打印报错</span></span><br><span class=\"line\">\t\t\tOnStartedLeading: sched.Run,</span><br><span class=\"line\">\t\t\tOnStoppedLeading: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\tklog.Fatalf(<span class=\"string\">&quot;leaderelection lost&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tleaderElector, err := leaderelection.NewLeaderElector(*cc.LeaderElection)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;couldn&#x27;t create leader elector: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 参与选举的会持续通信</span></span><br><span class=\"line\">\t\tleaderElector.Run(ctx)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;lost lease&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 不参与选举的，也就是单节点的情况时，在这里运行</span></span><br><span class=\"line\">\tsched.Run(ctx)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;finished without leader elect&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">到这里，我们已经接触了kube-scheduler的2个核心概念：</span></span><br><span class=\"line\"><span class=\"comment\">1. scheduler：正如程序名kube-scheduler，这个进程的核心作用是进行调度，会涉及到多种调度策略</span></span><br><span class=\"line\"><span class=\"comment\">2. Informer：k8s中有各种类型的资源，包括自定义的。而Informer的实现就将调度和资源结合了起来</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在创建scheduler的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Setup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建scheduler，包括多个选项</span></span><br><span class=\"line\">\tsched, err := scheduler.New(cc.Client,</span><br><span class=\"line\">\t\tcc.InformerFactory,</span><br><span class=\"line\">\t\tcc.PodInformer,</span><br><span class=\"line\">\t\trecorderFactory,</span><br><span class=\"line\">\t\tctx.Done(),</span><br><span class=\"line\">\t\tscheduler.WithProfiles(cc.ComponentConfig.Profiles...),</span><br><span class=\"line\">\t\tscheduler.WithAlgorithmSource(cc.ComponentConfig.AlgorithmSource),</span><br><span class=\"line\">\t\tscheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span><br><span class=\"line\">\t\tscheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),</span><br><span class=\"line\">\t\tscheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),</span><br><span class=\"line\">\t\tscheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),</span><br><span class=\"line\">\t\tscheduler.WithExtenders(cc.ComponentConfig.Extenders...),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;cc, sched, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们再看一下New这个函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先注册了所有的算法，保存到一个 map[string]PluginFactory 中</span></span><br><span class=\"line\">  registry := frameworkplugins.NewInTreeRegistry()</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 重点看一下Scheduler的创建过程</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> sched *Scheduler</span><br><span class=\"line\">\tsource := options.schedulerAlgorithmSource</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 根据Provider创建，重点看这里</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> source.Provider != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\tsc, err := configurator.createFromProvider(*source.Provider)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;couldn&#x27;t create scheduler using provider %q: %v&quot;</span>, *source.Provider, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsched = sc</span><br><span class=\"line\">  <span class=\"comment\">// 根据用户设置创建，来自文件或者ConfigMap</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> source.Policy != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\tpolicy := &amp;schedulerapi.Policy&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> source.Policy.File != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := initPolicyFromFile(source.Policy.File.Path, policy); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> source.Policy.ConfigMap != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := initPolicyFromConfigMap(client, source.Policy.ConfigMap, policy); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tconfigurator.extenders = policy.Extenders</span><br><span class=\"line\">\t\tsc, err := configurator.createFromConfig(*policy)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;couldn&#x27;t create scheduler from policy: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsched = sc</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;unsupported algorithm source: %v&quot;</span>, source)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">createFromProvider</span><span class=\"params\">(providerName <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;Creating scheduler from algorithm provider &#x27;%v&#x27;&quot;</span>, providerName)</span><br><span class=\"line\">  <span class=\"comment\">// 实例化算法的Registry</span></span><br><span class=\"line\">\tr := algorithmprovider.NewRegistry()</span><br><span class=\"line\">\tdefaultPlugins, exist := r[providerName]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !exist &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;algorithm provider %q is not registered&quot;</span>, providerName)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将各种算法作为plugin进行设置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> c.profiles &#123;</span><br><span class=\"line\">\t\tprof := &amp;c.profiles[i]</span><br><span class=\"line\">\t\tplugins := &amp;schedulerapi.Plugins&#123;&#125;</span><br><span class=\"line\">\t\tplugins.Append(defaultPlugins)</span><br><span class=\"line\">\t\tplugins.Apply(prof.Plugins)</span><br><span class=\"line\">\t\tprof.Plugins = plugins</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从这个初始化中可以看到，主要分为2类：默认与ClusterAutoscaler两种算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRegistry</span><span class=\"params\">()</span> <span class=\"title\">Registry</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 默认算法包括过滤、打分、绑定等，有兴趣的去源码中逐个阅读</span></span><br><span class=\"line\">\tdefaultConfig := getDefaultConfig()</span><br><span class=\"line\">\tapplyFeatureGates(defaultConfig)</span><br><span class=\"line\">\t<span class=\"comment\">// ClusterAutoscaler 是集群自动扩展的算法，被单独拎出来，</span></span><br><span class=\"line\">\tcaConfig := getClusterAutoscalerConfig()</span><br><span class=\"line\">\tapplyFeatureGates(caConfig)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Registry&#123;</span><br><span class=\"line\">\t\tschedulerapi.SchedulerDefaultProviderName: defaultConfig,</span><br><span class=\"line\">\t\tClusterAutoscalerProvider:                 caConfig,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">在这里，熟悉k8s的朋友会有个疑问：以前听说kubernets的调度有个Predicate和Priority两个算法，这里怎么没有分类？</span></span><br><span class=\"line\"><span class=\"comment\">这个疑问，我们在后面具体场景时再进行分析。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"NodeName\"><a href=\"#NodeName\" class=\"headerlink\" title=\"NodeName\"></a>NodeName</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为了加深大家对Plugin的印象，我选择一个最简单的示例：根据Pod的spec字段中的NodeName，分配到指定名称的节点</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> nodename</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tv1 <span class=\"string\">&quot;k8s.io/api/core/v1&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class=\"line\">\tframework <span class=\"string\">&quot;k8s.io/kubernetes/pkg/scheduler/framework/v1alpha1&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> NodeName <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ framework.FilterPlugin = &amp;NodeName&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个调度算法的名称和错误信息</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tName = <span class=\"string\">&quot;NodeName&quot;</span></span><br><span class=\"line\">\tErrReason = <span class=\"string\">&quot;node(s) didn&#x27;t match the requested hostname&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调度算法的明明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pl *NodeName)</span> <span class=\"title\">Name</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 过滤功能，这个就是NodeName算法的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pl *NodeName)</span> <span class=\"title\">Filter</span><span class=\"params\">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class=\"title\">framework</span>.<span class=\"title\">Status</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 找不到Node</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> nodeInfo.Node() == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> framework.NewStatus(framework.Error, <span class=\"string\">&quot;node not found&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 匹配不到，返回错误</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !Fits(pod, nodeInfo) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  匹配的算法，两种条件满足一个就认为成功</span></span><br><span class=\"line\"><span class=\"comment\">  1. spec没有填NodeName </span></span><br><span class=\"line\"><span class=\"comment\">  2.spec的NodeName和节点匹配</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fits</span><span class=\"params\">(pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(pod.Spec.NodeName) == <span class=\"number\">0</span> || pod.Spec.NodeName == nodeInfo.Node().Name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(_ runtime.Object, _ framework.FrameworkHandle)</span> <span class=\"params\">(framework.Plugin, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;NodeName&#123;&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"【K8s源码品读】009：Phase 1 - kube-scheduler - Informer监听资源变化","date":"2021-02-18T08:55:55.000Z","_content":"\n## 聚焦目标\n\n了解`Informer`是如何从kube-apiserver监听资源变化的情况\n\n\n\n## 目录\n\n1. [什么是Informer](#informer)\n2. [Shared Informer的实现](#Shared-Informer)\n3. [PodInformer的背后的实现](#PodInformer)\n4. [聚焦Reflect结构](#Reflect)\n5. [本节小节](#Summary)\n\n\n\n## Informer\n\n什么是`Informer`？这一节，我将先抛开代码，重点讲一下这个Informer，因为它是理解k8s运行机制的核心概念。\n\n\n\n我没有在官方文档中找到`Informer`的明确定义，中文直译为`通知器`。从[这个链接](https://medium.com/@muhammet.arslan/write-your-own-kubernetes-controller-with-informers-9920e8ab6f84)中，我们可以看到一个自定义资源的的处理流程。\n\n\n\n我简单概况下，`Informer`的核心功能是 **获取并监听(ListAndWatch)对应资源的增删改，触发相应的事件操作(ResourceEventHandler)**\n\n\n\n## Shared Informer\n\n```go\n/*\nclient 是连接到 kube-apiserver 的客户端。\n我们要理解k8s的设计：\n1. etcd是核心的数据存储，对资源的修改会进行持久化\n2. 只有kube-apiserver可以访问etcd\n所以，kube-scheduler要了解资源的变化情况，只能通过kube-apiserver\n*/\n\n// 定义了 Shared Informer，其中这个client是用来连接kube-apiserver的\nc.InformerFactory = informers.NewSharedInformerFactory(client, 0)\n\n// 这里解答了为什么叫shared：一个资源会对应多个Informer，会导致效率低下，所以让一个资源对应一个sharedInformer，而一个sharedInformer内部自己维护多个Informer\ntype sharedInformerFactory struct {\n\tclient           kubernetes.Interface\n\tnamespace        string\n\ttweakListOptions internalinterfaces.TweakListOptionsFunc\n\tlock             sync.Mutex\n\tdefaultResync    time.Duration\n\tcustomResync     map[reflect.Type]time.Duration\n  // 这个map就是维护多个Informer的关键实现\n\tinformers map[reflect.Type]cache.SharedIndexInformer\n\tstartedInformers map[reflect.Type]bool\n}\n\n// 运行函数\nfunc (f *sharedInformerFactory) Start(stopCh <-chan struct{}) {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\tfor informerType, informer := range f.informers {\n\t\tif !f.startedInformers[informerType] {\n      // goroutine异步处理\n\t\t\tgo informer.Run(stopCh)\n      // 标记为已经运行，这样即使下次Start也不会重复运行\n\t\t\tf.startedInformers[informerType] = true\n\t\t}\n\t}\n}\n\n// 查找对应的informer\nfunc (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\t// 找到就直接返回\n\tinformerType := reflect.TypeOf(obj)\n\tinformer, exists := f.informers[informerType]\n\tif exists {\n\t\treturn informer\n\t}\n\n\tresyncPeriod, exists := f.customResync[informerType]\n\tif !exists {\n\t\tresyncPeriod = f.defaultResync\n\t}\n\t// 没找到就会新建\n\tinformer = newFunc(f.client, resyncPeriod)\n\tf.informers[informerType] = informer\n\treturn informer\n}\n\n// SharedInformerFactory 是 sharedInformerFactory 的接口定义\ntype SharedInformerFactory interface {\n  // 我们这一阶段关注的Pod的Informer，属于核心资源\n\tCore() core.Interface\n}\n\n// core.Interface的定义\ntype Interface interface {\n\t// V1 provides access to shared informers for resources in V1.\n\tV1() v1.Interface\n}\n\n// v1.Interface 的定义\ntype Interface interface {\n  // Pod的定义\n\tPods() PodInformer\n}\n\n// PodInformer 是对应的接口\ntype PodInformer interface {\n\tInformer() cache.SharedIndexInformer\n\tLister() v1.PodLister\n}\n// podInformer 是具体的实现\ntype podInformer struct {\n\tfactory          internalinterfaces.SharedInformerFactory\n\ttweakListOptions internalinterfaces.TweakListOptionsFunc\n\tnamespace        string\n}\n\n// 最后，我们可以看到podInformer调用了InformerFor函数进行了添加\nfunc (f *podInformer) Informer() cache.SharedIndexInformer {\n\treturn f.factory.InformerFor(&corev1.Pod{}, f.defaultInformer)\n}\n```\n\n\n\n## PodInformer\n\n```go\n// 实例化PodInformer，把对应的List/Watch操作方法传入到实例化函数，生成统一的SharedIndexInformer接口\nfunc NewFilteredPodInformer() cache.SharedIndexInformer {\n\treturn cache.NewSharedIndexInformer(\n    // List和Watch实现从PodInterface里面查询\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(options metav1.ListOptions) (runtime.Object, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.CoreV1().Pods(namespace).List(context.TODO(), options)\n\t\t\t},\n\t\t\tWatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.CoreV1().Pods(namespace).Watch(context.TODO(), options)\n\t\t\t},\n\t\t},\n\t\t&corev1.Pod{},\n\t\tresyncPeriod,\n\t\tindexers,\n\t)\n}\n\n// 我们先看看Pod基本的List和Watch是怎么定义的\n// Pod基本的增删改查等操作\ntype PodInterface interface {\n\tList(ctx context.Context, opts metav1.ListOptions) (*v1.PodList, error)\n\tWatch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)\n\t...\n}\n// pods 是PodInterface的实现\ntype pods struct {\n\tclient rest.Interface\n\tns     string\n}\n\n// List 和 Watch 是依赖客户端，也就是从kube-apiserver中查询的\nfunc (c *pods) List(ctx context.Context, opts metav1.ListOptions) (result *v1.PodList, err error) {\n\terr = c.client.Get().\n\t\tNamespace(c.ns).\n\t\tResource(\"pods\").\n\t\tVersionedParams(&opts, scheme.ParameterCodec).\n\t\tTimeout(timeout).\n\t\tDo(ctx).\n\t\tInto(result)\n\treturn\n}\nfunc (c *pods) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {\n\treturn c.client.Get().\n\t\tNamespace(c.ns).\n\t\tResource(\"pods\").\n\t\tVersionedParams(&opts, scheme.ParameterCodec).\n\t\tTimeout(timeout).\n\t\tWatch(ctx)\n}\n\n// 在上面，我们看到了异步运行Informer的代码 go informer.Run(stopCh)，我们看看是怎么run的\nfunc (s *sharedIndexInformer) Run(stopCh <-chan struct{}) {\n  // 这里有个 DeltaFIFO 的对象，\n  fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions{\n\t\tKnownObjects:          s.indexer,\n\t\tEmitDeltaTypeReplaced: true,\n\t})\n\t// 传入这个fifo到cfg\n\tcfg := &Config{\n\t\tQueue:            fifo,\n\t\t...\n\t}\n\t// 新建controller\n\tfunc() {\n\t\ts.startedLock.Lock()\n\t\tdefer s.startedLock.Unlock()\n\n\t\ts.controller = New(cfg)\n\t\ts.controller.(*controller).clock = s.clock\n\t\ts.started = true\n\t}()\n\t// 运行controller\n\ts.controller.Run(stopCh)\n}\n\n// Controller的运行\nfunc (c *controller) Run(stopCh <-chan struct{}) {\n\t// \n\tr := NewReflector(\n\t\tc.config.ListerWatcher,\n\t\tc.config.ObjectType,\n\t\tc.config.Queue,\n\t\tc.config.FullResyncPeriod,\n\t)\n\tr.ShouldResync = c.config.ShouldResync\n\tr.clock = c.clock\n\tif c.config.WatchErrorHandler != nil {\n\t\tr.watchErrorHandler = c.config.WatchErrorHandler\n\t}\n\n\tc.reflectorMutex.Lock()\n\tc.reflector = r\n\tc.reflectorMutex.Unlock()\n\n\tvar wg wait.Group\n  // 生产，往Queue里放数据\n\twg.StartWithChannel(stopCh, r.Run)\n  // 消费，从Queue消费数据\n\twait.Until(c.processLoop, time.Second, stopCh)\n\twg.Wait()\n}\n```\n\n\n\n## Reflect\n\n```go\n// 我们再回头看看这个Reflect结构\nr := NewReflector(\n  \t// ListerWatcher 我们已经有了解，就是通过client监听kube-apiserver暴露出来的Resource\n\t\tc.config.ListerWatcher,\n\t\tc.config.ObjectType,\n  \t// Queue 是我们前文看到的一个 DeltaFIFOQueue，认为这是一个先进先出的队列\n\t\tc.config.Queue,\n\t\tc.config.FullResyncPeriod,\n)\n\nfunc (r *Reflector) Run(stopCh <-chan struct{}) {\n\tklog.V(2).Infof(\"Starting reflector %s (%s) from %s\", r.expectedTypeName, r.resyncPeriod, r.name)\n\twait.BackoffUntil(func() {\n    // 调用了ListAndWatch\n\t\tif err := r.ListAndWatch(stopCh); err != nil {\n\t\t\tr.watchErrorHandler(r, err)\n\t\t}\n\t}, r.backoffManager, true, stopCh)\n\tklog.V(2).Infof(\"Stopping reflector %s (%s) from %s\", r.expectedTypeName, r.resyncPeriod, r.name)\n}\n\nfunc (r *Reflector) ListAndWatch(stopCh <-chan struct{}) error {\n\t\t// watchHandler顾名思义，就是Watch到对应的事件，调用对应的Handler\n\t\tif err := r.watchHandler(start, w, &resourceVersion, resyncerrc, stopCh); err != nil {\n\t\t\tif err != errorStopRequested {\n\t\t\t\tswitch {\n\t\t\t\tcase isExpiredError(err):\n\t\t\t\t\tklog.V(4).Infof(\"%s: watch of %v closed with: %v\", r.name, r.expectedTypeName, err)\n\t\t\t\tdefault:\n\t\t\t\t\tklog.Warningf(\"%s: watch of %v ended with: %v\", r.name, r.expectedTypeName, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (r *Reflector) watchHandler() error {\nloop:\n\tfor {\n    // 一个经典的GO语言select监听多channel的模式\n\t\tselect {\n    // 整体的step channel\n\t\tcase <-stopCh:\n\t\t\treturn errorStopRequested\n    // 错误相关的error channel\n\t\tcase err := <-errc:\n\t\t\treturn err\n    // 接收事件event的channel\n\t\tcase event, ok := <-w.ResultChan():\n      // channel被关闭，退出loop\n\t\t\tif !ok {\n\t\t\t\tbreak loop\n\t\t\t}\n      \n\t\t\t// 一系列的资源验证代码跳过\n      \n\t\t\tswitch event.Type {\n      // 增删改三种Event，分别对应到去store，即DeltaFIFO中，操作object\n\t\t\tcase watch.Added:\n\t\t\t\terr := r.store.Add(event.Object)\n\t\t\tcase watch.Modified:\n\t\t\t\terr := r.store.Update(event.Object)\n\t\t\tcase watch.Deleted:\n\t\t\t\terr := r.store.Delete(event.Object)\n\t\t\tcase watch.Bookmark:\n\t\t\tdefault:\n\t\t\t\tutilruntime.HandleError(fmt.Errorf(\"%s: unable to understand watch event %#v\", r.name, event))\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n\n\n## Summary\n\n1. `Informer` 依赖于 `Reflector` 模块，它有个组件为 xxxInformer，如 `podInformer` \n2. 具体资源的 `Informer` 包含了一个连接到`kube-apiserver`的`client`，通过`List`和`Watch`接口查询资源变更情况\n3. 检测到资源发生变化后，通过`Controller` 将数据放入队列`DeltaFIFOQueue`里，生产阶段完成","source":"_posts/k8s-009.md","raw":"---\ntitle: 【K8s源码品读】009：Phase 1 - kube-scheduler - Informer监听资源变化\ndate: 2021-02-18 16:55:55\ntags:\n---\n\n## 聚焦目标\n\n了解`Informer`是如何从kube-apiserver监听资源变化的情况\n\n\n\n## 目录\n\n1. [什么是Informer](#informer)\n2. [Shared Informer的实现](#Shared-Informer)\n3. [PodInformer的背后的实现](#PodInformer)\n4. [聚焦Reflect结构](#Reflect)\n5. [本节小节](#Summary)\n\n\n\n## Informer\n\n什么是`Informer`？这一节，我将先抛开代码，重点讲一下这个Informer，因为它是理解k8s运行机制的核心概念。\n\n\n\n我没有在官方文档中找到`Informer`的明确定义，中文直译为`通知器`。从[这个链接](https://medium.com/@muhammet.arslan/write-your-own-kubernetes-controller-with-informers-9920e8ab6f84)中，我们可以看到一个自定义资源的的处理流程。\n\n\n\n我简单概况下，`Informer`的核心功能是 **获取并监听(ListAndWatch)对应资源的增删改，触发相应的事件操作(ResourceEventHandler)**\n\n\n\n## Shared Informer\n\n```go\n/*\nclient 是连接到 kube-apiserver 的客户端。\n我们要理解k8s的设计：\n1. etcd是核心的数据存储，对资源的修改会进行持久化\n2. 只有kube-apiserver可以访问etcd\n所以，kube-scheduler要了解资源的变化情况，只能通过kube-apiserver\n*/\n\n// 定义了 Shared Informer，其中这个client是用来连接kube-apiserver的\nc.InformerFactory = informers.NewSharedInformerFactory(client, 0)\n\n// 这里解答了为什么叫shared：一个资源会对应多个Informer，会导致效率低下，所以让一个资源对应一个sharedInformer，而一个sharedInformer内部自己维护多个Informer\ntype sharedInformerFactory struct {\n\tclient           kubernetes.Interface\n\tnamespace        string\n\ttweakListOptions internalinterfaces.TweakListOptionsFunc\n\tlock             sync.Mutex\n\tdefaultResync    time.Duration\n\tcustomResync     map[reflect.Type]time.Duration\n  // 这个map就是维护多个Informer的关键实现\n\tinformers map[reflect.Type]cache.SharedIndexInformer\n\tstartedInformers map[reflect.Type]bool\n}\n\n// 运行函数\nfunc (f *sharedInformerFactory) Start(stopCh <-chan struct{}) {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\tfor informerType, informer := range f.informers {\n\t\tif !f.startedInformers[informerType] {\n      // goroutine异步处理\n\t\t\tgo informer.Run(stopCh)\n      // 标记为已经运行，这样即使下次Start也不会重复运行\n\t\t\tf.startedInformers[informerType] = true\n\t\t}\n\t}\n}\n\n// 查找对应的informer\nfunc (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\t// 找到就直接返回\n\tinformerType := reflect.TypeOf(obj)\n\tinformer, exists := f.informers[informerType]\n\tif exists {\n\t\treturn informer\n\t}\n\n\tresyncPeriod, exists := f.customResync[informerType]\n\tif !exists {\n\t\tresyncPeriod = f.defaultResync\n\t}\n\t// 没找到就会新建\n\tinformer = newFunc(f.client, resyncPeriod)\n\tf.informers[informerType] = informer\n\treturn informer\n}\n\n// SharedInformerFactory 是 sharedInformerFactory 的接口定义\ntype SharedInformerFactory interface {\n  // 我们这一阶段关注的Pod的Informer，属于核心资源\n\tCore() core.Interface\n}\n\n// core.Interface的定义\ntype Interface interface {\n\t// V1 provides access to shared informers for resources in V1.\n\tV1() v1.Interface\n}\n\n// v1.Interface 的定义\ntype Interface interface {\n  // Pod的定义\n\tPods() PodInformer\n}\n\n// PodInformer 是对应的接口\ntype PodInformer interface {\n\tInformer() cache.SharedIndexInformer\n\tLister() v1.PodLister\n}\n// podInformer 是具体的实现\ntype podInformer struct {\n\tfactory          internalinterfaces.SharedInformerFactory\n\ttweakListOptions internalinterfaces.TweakListOptionsFunc\n\tnamespace        string\n}\n\n// 最后，我们可以看到podInformer调用了InformerFor函数进行了添加\nfunc (f *podInformer) Informer() cache.SharedIndexInformer {\n\treturn f.factory.InformerFor(&corev1.Pod{}, f.defaultInformer)\n}\n```\n\n\n\n## PodInformer\n\n```go\n// 实例化PodInformer，把对应的List/Watch操作方法传入到实例化函数，生成统一的SharedIndexInformer接口\nfunc NewFilteredPodInformer() cache.SharedIndexInformer {\n\treturn cache.NewSharedIndexInformer(\n    // List和Watch实现从PodInterface里面查询\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(options metav1.ListOptions) (runtime.Object, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.CoreV1().Pods(namespace).List(context.TODO(), options)\n\t\t\t},\n\t\t\tWatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {\n\t\t\t\tif tweakListOptions != nil {\n\t\t\t\t\ttweakListOptions(&options)\n\t\t\t\t}\n\t\t\t\treturn client.CoreV1().Pods(namespace).Watch(context.TODO(), options)\n\t\t\t},\n\t\t},\n\t\t&corev1.Pod{},\n\t\tresyncPeriod,\n\t\tindexers,\n\t)\n}\n\n// 我们先看看Pod基本的List和Watch是怎么定义的\n// Pod基本的增删改查等操作\ntype PodInterface interface {\n\tList(ctx context.Context, opts metav1.ListOptions) (*v1.PodList, error)\n\tWatch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)\n\t...\n}\n// pods 是PodInterface的实现\ntype pods struct {\n\tclient rest.Interface\n\tns     string\n}\n\n// List 和 Watch 是依赖客户端，也就是从kube-apiserver中查询的\nfunc (c *pods) List(ctx context.Context, opts metav1.ListOptions) (result *v1.PodList, err error) {\n\terr = c.client.Get().\n\t\tNamespace(c.ns).\n\t\tResource(\"pods\").\n\t\tVersionedParams(&opts, scheme.ParameterCodec).\n\t\tTimeout(timeout).\n\t\tDo(ctx).\n\t\tInto(result)\n\treturn\n}\nfunc (c *pods) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {\n\treturn c.client.Get().\n\t\tNamespace(c.ns).\n\t\tResource(\"pods\").\n\t\tVersionedParams(&opts, scheme.ParameterCodec).\n\t\tTimeout(timeout).\n\t\tWatch(ctx)\n}\n\n// 在上面，我们看到了异步运行Informer的代码 go informer.Run(stopCh)，我们看看是怎么run的\nfunc (s *sharedIndexInformer) Run(stopCh <-chan struct{}) {\n  // 这里有个 DeltaFIFO 的对象，\n  fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions{\n\t\tKnownObjects:          s.indexer,\n\t\tEmitDeltaTypeReplaced: true,\n\t})\n\t// 传入这个fifo到cfg\n\tcfg := &Config{\n\t\tQueue:            fifo,\n\t\t...\n\t}\n\t// 新建controller\n\tfunc() {\n\t\ts.startedLock.Lock()\n\t\tdefer s.startedLock.Unlock()\n\n\t\ts.controller = New(cfg)\n\t\ts.controller.(*controller).clock = s.clock\n\t\ts.started = true\n\t}()\n\t// 运行controller\n\ts.controller.Run(stopCh)\n}\n\n// Controller的运行\nfunc (c *controller) Run(stopCh <-chan struct{}) {\n\t// \n\tr := NewReflector(\n\t\tc.config.ListerWatcher,\n\t\tc.config.ObjectType,\n\t\tc.config.Queue,\n\t\tc.config.FullResyncPeriod,\n\t)\n\tr.ShouldResync = c.config.ShouldResync\n\tr.clock = c.clock\n\tif c.config.WatchErrorHandler != nil {\n\t\tr.watchErrorHandler = c.config.WatchErrorHandler\n\t}\n\n\tc.reflectorMutex.Lock()\n\tc.reflector = r\n\tc.reflectorMutex.Unlock()\n\n\tvar wg wait.Group\n  // 生产，往Queue里放数据\n\twg.StartWithChannel(stopCh, r.Run)\n  // 消费，从Queue消费数据\n\twait.Until(c.processLoop, time.Second, stopCh)\n\twg.Wait()\n}\n```\n\n\n\n## Reflect\n\n```go\n// 我们再回头看看这个Reflect结构\nr := NewReflector(\n  \t// ListerWatcher 我们已经有了解，就是通过client监听kube-apiserver暴露出来的Resource\n\t\tc.config.ListerWatcher,\n\t\tc.config.ObjectType,\n  \t// Queue 是我们前文看到的一个 DeltaFIFOQueue，认为这是一个先进先出的队列\n\t\tc.config.Queue,\n\t\tc.config.FullResyncPeriod,\n)\n\nfunc (r *Reflector) Run(stopCh <-chan struct{}) {\n\tklog.V(2).Infof(\"Starting reflector %s (%s) from %s\", r.expectedTypeName, r.resyncPeriod, r.name)\n\twait.BackoffUntil(func() {\n    // 调用了ListAndWatch\n\t\tif err := r.ListAndWatch(stopCh); err != nil {\n\t\t\tr.watchErrorHandler(r, err)\n\t\t}\n\t}, r.backoffManager, true, stopCh)\n\tklog.V(2).Infof(\"Stopping reflector %s (%s) from %s\", r.expectedTypeName, r.resyncPeriod, r.name)\n}\n\nfunc (r *Reflector) ListAndWatch(stopCh <-chan struct{}) error {\n\t\t// watchHandler顾名思义，就是Watch到对应的事件，调用对应的Handler\n\t\tif err := r.watchHandler(start, w, &resourceVersion, resyncerrc, stopCh); err != nil {\n\t\t\tif err != errorStopRequested {\n\t\t\t\tswitch {\n\t\t\t\tcase isExpiredError(err):\n\t\t\t\t\tklog.V(4).Infof(\"%s: watch of %v closed with: %v\", r.name, r.expectedTypeName, err)\n\t\t\t\tdefault:\n\t\t\t\t\tklog.Warningf(\"%s: watch of %v ended with: %v\", r.name, r.expectedTypeName, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (r *Reflector) watchHandler() error {\nloop:\n\tfor {\n    // 一个经典的GO语言select监听多channel的模式\n\t\tselect {\n    // 整体的step channel\n\t\tcase <-stopCh:\n\t\t\treturn errorStopRequested\n    // 错误相关的error channel\n\t\tcase err := <-errc:\n\t\t\treturn err\n    // 接收事件event的channel\n\t\tcase event, ok := <-w.ResultChan():\n      // channel被关闭，退出loop\n\t\t\tif !ok {\n\t\t\t\tbreak loop\n\t\t\t}\n      \n\t\t\t// 一系列的资源验证代码跳过\n      \n\t\t\tswitch event.Type {\n      // 增删改三种Event，分别对应到去store，即DeltaFIFO中，操作object\n\t\t\tcase watch.Added:\n\t\t\t\terr := r.store.Add(event.Object)\n\t\t\tcase watch.Modified:\n\t\t\t\terr := r.store.Update(event.Object)\n\t\t\tcase watch.Deleted:\n\t\t\t\terr := r.store.Delete(event.Object)\n\t\t\tcase watch.Bookmark:\n\t\t\tdefault:\n\t\t\t\tutilruntime.HandleError(fmt.Errorf(\"%s: unable to understand watch event %#v\", r.name, event))\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n\n\n## Summary\n\n1. `Informer` 依赖于 `Reflector` 模块，它有个组件为 xxxInformer，如 `podInformer` \n2. 具体资源的 `Informer` 包含了一个连接到`kube-apiserver`的`client`，通过`List`和`Watch`接口查询资源变更情况\n3. 检测到资源发生变化后，通过`Controller` 将数据放入队列`DeltaFIFOQueue`里，生产阶段完成","slug":"k8s-009","published":1,"updated":"2021-02-18T09:00:07.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaogran0008a4qphggkc0rx","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>了解<code>Informer</code>是如何从kube-apiserver监听资源变化的情况</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#informer\">什么是Informer</a></li>\n<li><a href=\"#Shared-Informer\">Shared Informer的实现</a></li>\n<li><a href=\"#PodInformer\">PodInformer的背后的实现</a></li>\n<li><a href=\"#Reflect\">聚焦Reflect结构</a></li>\n<li><a href=\"#Summary\">本节小节</a></li>\n</ol>\n<h2 id=\"Informer\"><a href=\"#Informer\" class=\"headerlink\" title=\"Informer\"></a>Informer</h2><p>什么是<code>Informer</code>？这一节，我将先抛开代码，重点讲一下这个Informer，因为它是理解k8s运行机制的核心概念。</p>\n<p>我没有在官方文档中找到<code>Informer</code>的明确定义，中文直译为<code>通知器</code>。从<a href=\"https://medium.com/@muhammet.arslan/write-your-own-kubernetes-controller-with-informers-9920e8ab6f84\">这个链接</a>中，我们可以看到一个自定义资源的的处理流程。</p>\n<p>我简单概况下，<code>Informer</code>的核心功能是 <strong>获取并监听(ListAndWatch)对应资源的增删改，触发相应的事件操作(ResourceEventHandler)</strong></p>\n<h2 id=\"Shared-Informer\"><a href=\"#Shared-Informer\" class=\"headerlink\" title=\"Shared Informer\"></a>Shared Informer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">client 是连接到 kube-apiserver 的客户端。</span></span><br><span class=\"line\"><span class=\"comment\">我们要理解k8s的设计：</span></span><br><span class=\"line\"><span class=\"comment\">1. etcd是核心的数据存储，对资源的修改会进行持久化</span></span><br><span class=\"line\"><span class=\"comment\">2. 只有kube-apiserver可以访问etcd</span></span><br><span class=\"line\"><span class=\"comment\">所以，kube-scheduler要了解资源的变化情况，只能通过kube-apiserver</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义了 Shared Informer，其中这个client是用来连接kube-apiserver的</span></span><br><span class=\"line\">c.InformerFactory = informers.NewSharedInformerFactory(client, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里解答了为什么叫shared：一个资源会对应多个Informer，会导致效率低下，所以让一个资源对应一个sharedInformer，而一个sharedInformer内部自己维护多个Informer</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> sharedInformerFactory <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tclient           kubernetes.Interface</span><br><span class=\"line\">\tnamespace        <span class=\"keyword\">string</span></span><br><span class=\"line\">\ttweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class=\"line\">\tlock             sync.Mutex</span><br><span class=\"line\">\tdefaultResync    time.Duration</span><br><span class=\"line\">\tcustomResync     <span class=\"keyword\">map</span>[reflect.Type]time.Duration</span><br><span class=\"line\">  <span class=\"comment\">// 这个map就是维护多个Informer的关键实现</span></span><br><span class=\"line\">\tinformers <span class=\"keyword\">map</span>[reflect.Type]cache.SharedIndexInformer</span><br><span class=\"line\">\tstartedInformers <span class=\"keyword\">map</span>[reflect.Type]<span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *sharedInformerFactory)</span> <span class=\"title\">Start</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tf.lock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> f.lock.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> informerType, informer := <span class=\"keyword\">range</span> f.informers &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !f.startedInformers[informerType] &#123;</span><br><span class=\"line\">      <span class=\"comment\">// goroutine异步处理</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">go</span> informer.Run(stopCh)</span><br><span class=\"line\">      <span class=\"comment\">// 标记为已经运行，这样即使下次Start也不会重复运行</span></span><br><span class=\"line\">\t\t\tf.startedInformers[informerType] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找对应的informer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *sharedInformerFactory)</span> <span class=\"title\">InformerFor</span><span class=\"params\">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class=\"title\">cache</span>.<span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\tf.lock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> f.lock.Unlock()</span><br><span class=\"line\">\t<span class=\"comment\">// 找到就直接返回</span></span><br><span class=\"line\">\tinformerType := reflect.TypeOf(obj)</span><br><span class=\"line\">\tinformer, exists := f.informers[informerType]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> exists &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> informer</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tresyncPeriod, exists := f.customResync[informerType]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !exists &#123;</span><br><span class=\"line\">\t\tresyncPeriod = f.defaultResync</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 没找到就会新建</span></span><br><span class=\"line\">\tinformer = newFunc(f.client, resyncPeriod)</span><br><span class=\"line\">\tf.informers[informerType] = informer</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> informer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SharedInformerFactory 是 sharedInformerFactory 的接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SharedInformerFactory <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们这一阶段关注的Pod的Informer，属于核心资源</span></span><br><span class=\"line\">\tCore() core.Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// core.Interface的定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// V1 provides access to shared informers for resources in V1.</span></span><br><span class=\"line\">\tV1() v1.Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// v1.Interface 的定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Pod的定义</span></span><br><span class=\"line\">\tPods() PodInformer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PodInformer 是对应的接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PodInformer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tInformer() cache.SharedIndexInformer</span><br><span class=\"line\">\tLister() v1.PodLister</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// podInformer 是具体的实现</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> podInformer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tfactory          internalinterfaces.SharedInformerFactory</span><br><span class=\"line\">\ttweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class=\"line\">\tnamespace        <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最后，我们可以看到podInformer调用了InformerFor函数进行了添加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *podInformer)</span> <span class=\"title\">Informer</span><span class=\"params\">()</span> <span class=\"title\">cache</span>.<span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f.factory.InformerFor(&amp;corev1.Pod&#123;&#125;, f.defaultInformer)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PodInformer\"><a href=\"#PodInformer\" class=\"headerlink\" title=\"PodInformer\"></a>PodInformer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例化PodInformer，把对应的List/Watch操作方法传入到实例化函数，生成统一的SharedIndexInformer接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewFilteredPodInformer</span><span class=\"params\">()</span> <span class=\"title\">cache</span>.<span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cache.NewSharedIndexInformer(</span><br><span class=\"line\">    <span class=\"comment\">// List和Watch实现从PodInterface里面查询</span></span><br><span class=\"line\">\t\t&amp;cache.ListWatch&#123;</span><br><span class=\"line\">\t\t\tListFunc: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(options metav1.ListOptions)</span> <span class=\"params\">(runtime.Object, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> tweakListOptions != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\ttweakListOptions(&amp;options)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> client.CoreV1().Pods(namespace).List(context.TODO(), options)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tWatchFunc: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(options metav1.ListOptions)</span> <span class=\"params\">(watch.Interface, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> tweakListOptions != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\ttweakListOptions(&amp;options)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> client.CoreV1().Pods(namespace).Watch(context.TODO(), options)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&amp;corev1.Pod&#123;&#125;,</span><br><span class=\"line\">\t\tresyncPeriod,</span><br><span class=\"line\">\t\tindexers,</span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们先看看Pod基本的List和Watch是怎么定义的</span></span><br><span class=\"line\"><span class=\"comment\">// Pod基本的增删改查等操作</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PodInterface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tList(ctx context.Context, opts metav1.ListOptions) (*v1.PodList, error)</span><br><span class=\"line\">\tWatch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// pods 是PodInterface的实现</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> pods <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tclient rest.Interface</span><br><span class=\"line\">\tns     <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// List 和 Watch 是依赖客户端，也就是从kube-apiserver中查询的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *pods)</span> <span class=\"title\">List</span><span class=\"params\">(ctx context.Context, opts metav1.ListOptions)</span> <span class=\"params\">(result *v1.PodList, err error)</span></span> &#123;</span><br><span class=\"line\">\terr = c.client.Get().</span><br><span class=\"line\">\t\tNamespace(c.ns).</span><br><span class=\"line\">\t\tResource(<span class=\"string\">&quot;pods&quot;</span>).</span><br><span class=\"line\">\t\tVersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class=\"line\">\t\tTimeout(timeout).</span><br><span class=\"line\">\t\tDo(ctx).</span><br><span class=\"line\">\t\tInto(result)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *pods)</span> <span class=\"title\">Watch</span><span class=\"params\">(ctx context.Context, opts metav1.ListOptions)</span> <span class=\"params\">(watch.Interface, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.client.Get().</span><br><span class=\"line\">\t\tNamespace(c.ns).</span><br><span class=\"line\">\t\tResource(<span class=\"string\">&quot;pods&quot;</span>).</span><br><span class=\"line\">\t\tVersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class=\"line\">\t\tTimeout(timeout).</span><br><span class=\"line\">\t\tWatch(ctx)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在上面，我们看到了异步运行Informer的代码 go informer.Run(stopCh)，我们看看是怎么run的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *sharedIndexInformer)</span> <span class=\"title\">Run</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里有个 DeltaFIFO 的对象，</span></span><br><span class=\"line\">  fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;</span><br><span class=\"line\">\t\tKnownObjects:          s.indexer,</span><br><span class=\"line\">\t\tEmitDeltaTypeReplaced: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"comment\">// 传入这个fifo到cfg</span></span><br><span class=\"line\">\tcfg := &amp;Config&#123;</span><br><span class=\"line\">\t\tQueue:            fifo,</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 新建controller</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\ts.startedLock.Lock()</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> s.startedLock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts.controller = New(cfg)</span><br><span class=\"line\">\t\ts.controller.(*controller).clock = s.clock</span><br><span class=\"line\">\t\ts.started = <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// 运行controller</span></span><br><span class=\"line\">\ts.controller.Run(stopCh)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controller的运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *controller)</span> <span class=\"title\">Run</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// </span></span><br><span class=\"line\">\tr := NewReflector(</span><br><span class=\"line\">\t\tc.config.ListerWatcher,</span><br><span class=\"line\">\t\tc.config.ObjectType,</span><br><span class=\"line\">\t\tc.config.Queue,</span><br><span class=\"line\">\t\tc.config.FullResyncPeriod,</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tr.ShouldResync = c.config.ShouldResync</span><br><span class=\"line\">\tr.clock = c.clock</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.config.WatchErrorHandler != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tr.watchErrorHandler = c.config.WatchErrorHandler</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tc.reflectorMutex.Lock()</span><br><span class=\"line\">\tc.reflector = r</span><br><span class=\"line\">\tc.reflectorMutex.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg wait.Group</span><br><span class=\"line\">  <span class=\"comment\">// 生产，往Queue里放数据</span></span><br><span class=\"line\">\twg.StartWithChannel(stopCh, r.Run)</span><br><span class=\"line\">  <span class=\"comment\">// 消费，从Queue消费数据</span></span><br><span class=\"line\">\twait.Until(c.processLoop, time.Second, stopCh)</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们再回头看看这个Reflect结构</span></span><br><span class=\"line\">r := NewReflector(</span><br><span class=\"line\">  \t<span class=\"comment\">// ListerWatcher 我们已经有了解，就是通过client监听kube-apiserver暴露出来的Resource</span></span><br><span class=\"line\">\t\tc.config.ListerWatcher,</span><br><span class=\"line\">\t\tc.config.ObjectType,</span><br><span class=\"line\">  \t<span class=\"comment\">// Queue 是我们前文看到的一个 DeltaFIFOQueue，认为这是一个先进先出的队列</span></span><br><span class=\"line\">\t\tc.config.Queue,</span><br><span class=\"line\">\t\tc.config.FullResyncPeriod,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Reflector)</span> <span class=\"title\">Run</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;Starting reflector %s (%s) from %s&quot;</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class=\"line\">\twait.BackoffUntil(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用了ListAndWatch</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := r.ListAndWatch(stopCh); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tr.watchErrorHandler(r, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;, r.backoffManager, <span class=\"literal\">true</span>, stopCh)</span><br><span class=\"line\">\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;Stopping reflector %s (%s) from %s&quot;</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Reflector)</span> <span class=\"title\">ListAndWatch</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// watchHandler顾名思义，就是Watch到对应的事件，调用对应的Handler</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := r.watchHandler(start, w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != errorStopRequested &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> isExpiredError(err):</span><br><span class=\"line\">\t\t\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;%s: watch of %v closed with: %v&quot;</span>, r.name, r.expectedTypeName, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t\tklog.Warningf(<span class=\"string\">&quot;%s: watch of %v ended with: %v&quot;</span>, r.name, r.expectedTypeName, err)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Reflector)</span> <span class=\"title\">watchHandler</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一个经典的GO语言select监听多channel的模式</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 整体的step channel</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-stopCh:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> errorStopRequested</span><br><span class=\"line\">    <span class=\"comment\">// 错误相关的error channel</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> err := &lt;-errc:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">    <span class=\"comment\">// 接收事件event的channel</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class=\"line\">      <span class=\"comment\">// channel被关闭，退出loop</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span> loop</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 一系列的资源验证代码跳过</span></span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> event.Type &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 增删改三种Event，分别对应到去store，即DeltaFIFO中，操作object</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> watch.Added:</span><br><span class=\"line\">\t\t\t\terr := r.store.Add(event.Object)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> watch.Modified:</span><br><span class=\"line\">\t\t\t\terr := r.store.Update(event.Object)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> watch.Deleted:</span><br><span class=\"line\">\t\t\t\terr := r.store.Delete(event.Object)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> watch.Bookmark:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;%s: unable to understand watch event %#v&quot;</span>, r.name, event))</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><ol>\n<li><code>Informer</code> 依赖于 <code>Reflector</code> 模块，它有个组件为 xxxInformer，如 <code>podInformer</code> </li>\n<li>具体资源的 <code>Informer</code> 包含了一个连接到<code>kube-apiserver</code>的<code>client</code>，通过<code>List</code>和<code>Watch</code>接口查询资源变更情况</li>\n<li>检测到资源发生变化后，通过<code>Controller</code> 将数据放入队列<code>DeltaFIFOQueue</code>里，生产阶段完成</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>了解<code>Informer</code>是如何从kube-apiserver监听资源变化的情况</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#informer\">什么是Informer</a></li>\n<li><a href=\"#Shared-Informer\">Shared Informer的实现</a></li>\n<li><a href=\"#PodInformer\">PodInformer的背后的实现</a></li>\n<li><a href=\"#Reflect\">聚焦Reflect结构</a></li>\n<li><a href=\"#Summary\">本节小节</a></li>\n</ol>\n<h2 id=\"Informer\"><a href=\"#Informer\" class=\"headerlink\" title=\"Informer\"></a>Informer</h2><p>什么是<code>Informer</code>？这一节，我将先抛开代码，重点讲一下这个Informer，因为它是理解k8s运行机制的核心概念。</p>\n<p>我没有在官方文档中找到<code>Informer</code>的明确定义，中文直译为<code>通知器</code>。从<a href=\"https://medium.com/@muhammet.arslan/write-your-own-kubernetes-controller-with-informers-9920e8ab6f84\">这个链接</a>中，我们可以看到一个自定义资源的的处理流程。</p>\n<p>我简单概况下，<code>Informer</code>的核心功能是 <strong>获取并监听(ListAndWatch)对应资源的增删改，触发相应的事件操作(ResourceEventHandler)</strong></p>\n<h2 id=\"Shared-Informer\"><a href=\"#Shared-Informer\" class=\"headerlink\" title=\"Shared Informer\"></a>Shared Informer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">client 是连接到 kube-apiserver 的客户端。</span></span><br><span class=\"line\"><span class=\"comment\">我们要理解k8s的设计：</span></span><br><span class=\"line\"><span class=\"comment\">1. etcd是核心的数据存储，对资源的修改会进行持久化</span></span><br><span class=\"line\"><span class=\"comment\">2. 只有kube-apiserver可以访问etcd</span></span><br><span class=\"line\"><span class=\"comment\">所以，kube-scheduler要了解资源的变化情况，只能通过kube-apiserver</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义了 Shared Informer，其中这个client是用来连接kube-apiserver的</span></span><br><span class=\"line\">c.InformerFactory = informers.NewSharedInformerFactory(client, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里解答了为什么叫shared：一个资源会对应多个Informer，会导致效率低下，所以让一个资源对应一个sharedInformer，而一个sharedInformer内部自己维护多个Informer</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> sharedInformerFactory <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tclient           kubernetes.Interface</span><br><span class=\"line\">\tnamespace        <span class=\"keyword\">string</span></span><br><span class=\"line\">\ttweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class=\"line\">\tlock             sync.Mutex</span><br><span class=\"line\">\tdefaultResync    time.Duration</span><br><span class=\"line\">\tcustomResync     <span class=\"keyword\">map</span>[reflect.Type]time.Duration</span><br><span class=\"line\">  <span class=\"comment\">// 这个map就是维护多个Informer的关键实现</span></span><br><span class=\"line\">\tinformers <span class=\"keyword\">map</span>[reflect.Type]cache.SharedIndexInformer</span><br><span class=\"line\">\tstartedInformers <span class=\"keyword\">map</span>[reflect.Type]<span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *sharedInformerFactory)</span> <span class=\"title\">Start</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tf.lock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> f.lock.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> informerType, informer := <span class=\"keyword\">range</span> f.informers &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !f.startedInformers[informerType] &#123;</span><br><span class=\"line\">      <span class=\"comment\">// goroutine异步处理</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">go</span> informer.Run(stopCh)</span><br><span class=\"line\">      <span class=\"comment\">// 标记为已经运行，这样即使下次Start也不会重复运行</span></span><br><span class=\"line\">\t\t\tf.startedInformers[informerType] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找对应的informer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *sharedInformerFactory)</span> <span class=\"title\">InformerFor</span><span class=\"params\">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class=\"title\">cache</span>.<span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\tf.lock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> f.lock.Unlock()</span><br><span class=\"line\">\t<span class=\"comment\">// 找到就直接返回</span></span><br><span class=\"line\">\tinformerType := reflect.TypeOf(obj)</span><br><span class=\"line\">\tinformer, exists := f.informers[informerType]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> exists &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> informer</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tresyncPeriod, exists := f.customResync[informerType]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !exists &#123;</span><br><span class=\"line\">\t\tresyncPeriod = f.defaultResync</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 没找到就会新建</span></span><br><span class=\"line\">\tinformer = newFunc(f.client, resyncPeriod)</span><br><span class=\"line\">\tf.informers[informerType] = informer</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> informer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SharedInformerFactory 是 sharedInformerFactory 的接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SharedInformerFactory <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们这一阶段关注的Pod的Informer，属于核心资源</span></span><br><span class=\"line\">\tCore() core.Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// core.Interface的定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// V1 provides access to shared informers for resources in V1.</span></span><br><span class=\"line\">\tV1() v1.Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// v1.Interface 的定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Pod的定义</span></span><br><span class=\"line\">\tPods() PodInformer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PodInformer 是对应的接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PodInformer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tInformer() cache.SharedIndexInformer</span><br><span class=\"line\">\tLister() v1.PodLister</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// podInformer 是具体的实现</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> podInformer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tfactory          internalinterfaces.SharedInformerFactory</span><br><span class=\"line\">\ttweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class=\"line\">\tnamespace        <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最后，我们可以看到podInformer调用了InformerFor函数进行了添加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *podInformer)</span> <span class=\"title\">Informer</span><span class=\"params\">()</span> <span class=\"title\">cache</span>.<span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f.factory.InformerFor(&amp;corev1.Pod&#123;&#125;, f.defaultInformer)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PodInformer\"><a href=\"#PodInformer\" class=\"headerlink\" title=\"PodInformer\"></a>PodInformer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例化PodInformer，把对应的List/Watch操作方法传入到实例化函数，生成统一的SharedIndexInformer接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewFilteredPodInformer</span><span class=\"params\">()</span> <span class=\"title\">cache</span>.<span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cache.NewSharedIndexInformer(</span><br><span class=\"line\">    <span class=\"comment\">// List和Watch实现从PodInterface里面查询</span></span><br><span class=\"line\">\t\t&amp;cache.ListWatch&#123;</span><br><span class=\"line\">\t\t\tListFunc: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(options metav1.ListOptions)</span> <span class=\"params\">(runtime.Object, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> tweakListOptions != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\ttweakListOptions(&amp;options)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> client.CoreV1().Pods(namespace).List(context.TODO(), options)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tWatchFunc: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(options metav1.ListOptions)</span> <span class=\"params\">(watch.Interface, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> tweakListOptions != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\ttweakListOptions(&amp;options)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> client.CoreV1().Pods(namespace).Watch(context.TODO(), options)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&amp;corev1.Pod&#123;&#125;,</span><br><span class=\"line\">\t\tresyncPeriod,</span><br><span class=\"line\">\t\tindexers,</span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们先看看Pod基本的List和Watch是怎么定义的</span></span><br><span class=\"line\"><span class=\"comment\">// Pod基本的增删改查等操作</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PodInterface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tList(ctx context.Context, opts metav1.ListOptions) (*v1.PodList, error)</span><br><span class=\"line\">\tWatch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// pods 是PodInterface的实现</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> pods <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tclient rest.Interface</span><br><span class=\"line\">\tns     <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// List 和 Watch 是依赖客户端，也就是从kube-apiserver中查询的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *pods)</span> <span class=\"title\">List</span><span class=\"params\">(ctx context.Context, opts metav1.ListOptions)</span> <span class=\"params\">(result *v1.PodList, err error)</span></span> &#123;</span><br><span class=\"line\">\terr = c.client.Get().</span><br><span class=\"line\">\t\tNamespace(c.ns).</span><br><span class=\"line\">\t\tResource(<span class=\"string\">&quot;pods&quot;</span>).</span><br><span class=\"line\">\t\tVersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class=\"line\">\t\tTimeout(timeout).</span><br><span class=\"line\">\t\tDo(ctx).</span><br><span class=\"line\">\t\tInto(result)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *pods)</span> <span class=\"title\">Watch</span><span class=\"params\">(ctx context.Context, opts metav1.ListOptions)</span> <span class=\"params\">(watch.Interface, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.client.Get().</span><br><span class=\"line\">\t\tNamespace(c.ns).</span><br><span class=\"line\">\t\tResource(<span class=\"string\">&quot;pods&quot;</span>).</span><br><span class=\"line\">\t\tVersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class=\"line\">\t\tTimeout(timeout).</span><br><span class=\"line\">\t\tWatch(ctx)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在上面，我们看到了异步运行Informer的代码 go informer.Run(stopCh)，我们看看是怎么run的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *sharedIndexInformer)</span> <span class=\"title\">Run</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里有个 DeltaFIFO 的对象，</span></span><br><span class=\"line\">  fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;</span><br><span class=\"line\">\t\tKnownObjects:          s.indexer,</span><br><span class=\"line\">\t\tEmitDeltaTypeReplaced: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"comment\">// 传入这个fifo到cfg</span></span><br><span class=\"line\">\tcfg := &amp;Config&#123;</span><br><span class=\"line\">\t\tQueue:            fifo,</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 新建controller</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\ts.startedLock.Lock()</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> s.startedLock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts.controller = New(cfg)</span><br><span class=\"line\">\t\ts.controller.(*controller).clock = s.clock</span><br><span class=\"line\">\t\ts.started = <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// 运行controller</span></span><br><span class=\"line\">\ts.controller.Run(stopCh)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Controller的运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *controller)</span> <span class=\"title\">Run</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// </span></span><br><span class=\"line\">\tr := NewReflector(</span><br><span class=\"line\">\t\tc.config.ListerWatcher,</span><br><span class=\"line\">\t\tc.config.ObjectType,</span><br><span class=\"line\">\t\tc.config.Queue,</span><br><span class=\"line\">\t\tc.config.FullResyncPeriod,</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tr.ShouldResync = c.config.ShouldResync</span><br><span class=\"line\">\tr.clock = c.clock</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.config.WatchErrorHandler != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tr.watchErrorHandler = c.config.WatchErrorHandler</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tc.reflectorMutex.Lock()</span><br><span class=\"line\">\tc.reflector = r</span><br><span class=\"line\">\tc.reflectorMutex.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg wait.Group</span><br><span class=\"line\">  <span class=\"comment\">// 生产，往Queue里放数据</span></span><br><span class=\"line\">\twg.StartWithChannel(stopCh, r.Run)</span><br><span class=\"line\">  <span class=\"comment\">// 消费，从Queue消费数据</span></span><br><span class=\"line\">\twait.Until(c.processLoop, time.Second, stopCh)</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们再回头看看这个Reflect结构</span></span><br><span class=\"line\">r := NewReflector(</span><br><span class=\"line\">  \t<span class=\"comment\">// ListerWatcher 我们已经有了解，就是通过client监听kube-apiserver暴露出来的Resource</span></span><br><span class=\"line\">\t\tc.config.ListerWatcher,</span><br><span class=\"line\">\t\tc.config.ObjectType,</span><br><span class=\"line\">  \t<span class=\"comment\">// Queue 是我们前文看到的一个 DeltaFIFOQueue，认为这是一个先进先出的队列</span></span><br><span class=\"line\">\t\tc.config.Queue,</span><br><span class=\"line\">\t\tc.config.FullResyncPeriod,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Reflector)</span> <span class=\"title\">Run</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;Starting reflector %s (%s) from %s&quot;</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class=\"line\">\twait.BackoffUntil(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用了ListAndWatch</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := r.ListAndWatch(stopCh); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tr.watchErrorHandler(r, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;, r.backoffManager, <span class=\"literal\">true</span>, stopCh)</span><br><span class=\"line\">\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;Stopping reflector %s (%s) from %s&quot;</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Reflector)</span> <span class=\"title\">ListAndWatch</span><span class=\"params\">(stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// watchHandler顾名思义，就是Watch到对应的事件，调用对应的Handler</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := r.watchHandler(start, w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != errorStopRequested &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> isExpiredError(err):</span><br><span class=\"line\">\t\t\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;%s: watch of %v closed with: %v&quot;</span>, r.name, r.expectedTypeName, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t\tklog.Warningf(<span class=\"string\">&quot;%s: watch of %v ended with: %v&quot;</span>, r.name, r.expectedTypeName, err)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Reflector)</span> <span class=\"title\">watchHandler</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一个经典的GO语言select监听多channel的模式</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 整体的step channel</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-stopCh:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> errorStopRequested</span><br><span class=\"line\">    <span class=\"comment\">// 错误相关的error channel</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> err := &lt;-errc:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">    <span class=\"comment\">// 接收事件event的channel</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class=\"line\">      <span class=\"comment\">// channel被关闭，退出loop</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span> loop</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 一系列的资源验证代码跳过</span></span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> event.Type &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 增删改三种Event，分别对应到去store，即DeltaFIFO中，操作object</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> watch.Added:</span><br><span class=\"line\">\t\t\t\terr := r.store.Add(event.Object)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> watch.Modified:</span><br><span class=\"line\">\t\t\t\terr := r.store.Update(event.Object)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> watch.Deleted:</span><br><span class=\"line\">\t\t\t\terr := r.store.Delete(event.Object)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> watch.Bookmark:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;%s: unable to understand watch event %#v&quot;</span>, r.name, event))</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><ol>\n<li><code>Informer</code> 依赖于 <code>Reflector</code> 模块，它有个组件为 xxxInformer，如 <code>podInformer</code> </li>\n<li>具体资源的 <code>Informer</code> 包含了一个连接到<code>kube-apiserver</code>的<code>client</code>，通过<code>List</code>和<code>Watch</code>接口查询资源变更情况</li>\n<li>检测到资源发生变化后，通过<code>Controller</code> 将数据放入队列<code>DeltaFIFOQueue</code>里，生产阶段完成</li>\n</ol>\n"},{"title":"【K8s源码品读】010：Phase 1 - kube-scheduler - Informer是如何保存数据的","date":"2021-02-18T08:55:55.000Z","_content":"\n## 聚焦目标\n\n了解Informer在发现资源变化后，是怎么处理的\n\n\n\n## 目录\n\n5. [查看消费的过程](#Process)\n6. [掌握Index数据结构](#Index)\n7. [信息的分发distribute](#distribute)\n8. [Informer的综合思考](#Summary)\n\n\n\n## Process\n\n```go\nfunc (c *controller) processLoop() {\n\tfor {\n    // Pop出Object元素\n\t\tobj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))\n\t\tif err != nil {\n\t\t\tif err == ErrFIFOClosed {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif c.config.RetryOnError {\n\t\t\t\t// 重新进队列\n\t\t\t\tc.config.Queue.AddIfNotPresent(obj)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 去查看Pop的具体实现\nfunc (f *FIFO) Pop(process PopProcessFunc) (interface{}, error) {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\tfor {\n\t\t// 调用process去处理item，然后返回\n\t\titem, ok := f.items[id]\n\t\tdelete(f.items, id)\n\t\terr := process(item)\n\t\treturn item, err\n\t}\n}\n\n// 然后去查一下 PopProcessFunc 的定义，在创建controller前\ncfg := &Config{\n\t\tProcess:           s.HandleDeltas,\n\t}\n\nfunc (s *sharedIndexInformer) HandleDeltas(obj interface{}) error {\n\ts.blockDeltas.Lock()\n\tdefer s.blockDeltas.Unlock()\n\n\tfor _, d := range obj.(Deltas) {\n\t\tswitch d.Type {\n    // 增、改、替换、同步\n\t\tcase Sync, Replaced, Added, Updated:\n\t\t\ts.cacheMutationDetector.AddObject(d.Object)\n      // 先去indexer查询\n\t\t\tif old, exists, err := s.indexer.Get(d.Object); err == nil && exists {\n        // 如果数据已经存在，就执行Update逻辑\n\t\t\t\tif err := s.indexer.Update(d.Object); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tisSync := false\n\t\t\t\tswitch {\n\t\t\t\tcase d.Type == Sync:\n\t\t\t\t\tisSync = true\n\t\t\t\tcase d.Type == Replaced:\n\t\t\t\t\tif accessor, err := meta.Accessor(d.Object); err == nil {\n\t\t\t\t\t\t\tisSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n      \t// 分发Update事件\n\t\t\t\ts.processor.distribute(updateNotification{oldObj: old, newObj: d.Object}, isSync)\n\t\t\t} else {\n      \t// 没查到数据，就执行Add操作\n\t\t\t\tif err := s.indexer.Add(d.Object); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n      \t// 分发 Add 事件\n\t\t\t\ts.processor.distribute(addNotification{newObj: d.Object}, false)\n\t\t\t}\n   \t// 删除\n\t\tcase Deleted:\n    \t// 去indexer删除\n\t\t\tif err := s.indexer.Delete(d.Object); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n    \t// 分发 delete 事件\n\t\t\ts.processor.distribute(deleteNotification{oldObj: d.Object}, false)\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n\n\n## Index\n\n`Index` 的定义为资源的本地存储，保持与etcd中的资源信息一致。\n\n```go\n// 我们去看看Index是怎么创建的\nfunc NewSharedIndexInformer(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers) SharedIndexInformer {\n\trealClock := &clock.RealClock{}\n\tsharedIndexInformer := &sharedIndexInformer{\n\t\tprocessor:                       &sharedProcessor{clock: realClock},\n    // indexer 的初始化\n\t\tindexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),\n\t\tlisterWatcher:                   lw,\n\t\tobjectType:                      exampleObject,\n\t\tresyncCheckPeriod:               defaultEventHandlerResyncPeriod,\n\t\tdefaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,\n\t\tcacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(\"%T\", exampleObject)),\n\t\tclock:                           realClock,\n\t}\n\treturn sharedIndexInformer\n}\n\n// 生成一个map和func组合而成的Indexer\nfunc NewIndexer(keyFunc KeyFunc, indexers Indexers) Indexer {\n\treturn &cache{\n\t\tcacheStorage: NewThreadSafeStore(indexers, Indices{}),\n\t\tkeyFunc:      keyFunc,\n}\n\n// ThreadSafeStore的底层是一个并发安全的map，具体实现我们暂不考虑\nfunc NewThreadSafeStore(indexers Indexers, indices Indices) ThreadSafeStore {\n\treturn &threadSafeMap{\n\t\titems:    map[string]interface{}{},\n\t\tindexers: indexers,\n\t\tindices:  indices,\n\t}\n}\n```\n\n\n\n## distribute\n\n```go\n// 在上面的Process代码中，我们看到了将数据存储到Indexer后，调用了一个分发的函数\ns.processor.distribute()\n\n// 分发process的创建\nfunc NewSharedIndexInformer() SharedIndexInformer {\n\tsharedIndexInformer := &sharedIndexInformer{\n\t\tprocessor:                       &sharedProcessor{clock: realClock},\n\t}\n\treturn sharedIndexInformer\n}\n\n// sharedProcessor的结构\ntype sharedProcessor struct {\n\tlistenersStarted bool\n \t// 读写锁\n\tlistenersLock    sync.RWMutex\n  // 普通监听列表\n\tlisteners        []*processorListener\n  // 同步监听列表\n\tsyncingListeners []*processorListener\n\tclock            clock.Clock\n\twg               wait.Group\n}\n\n// 查看distribute函数\nfunc (p *sharedProcessor) distribute(obj interface{}, sync bool) {\n\tp.listenersLock.RLock()\n\tdefer p.listenersLock.RUnlock()\n\t// 将object分发到 同步监听 或者 普通监听 的列表\n\tif sync {\n\t\tfor _, listener := range p.syncingListeners {\n\t\t\tlistener.add(obj)\n\t\t}\n\t} else {\n\t\tfor _, listener := range p.listeners {\n\t\t\tlistener.add(obj)\n\t\t}\n\t}\n}\n\n// 这个add的操作是利用了channel\nfunc (p *processorListener) add(notification interface{}) {\n\tp.addCh <- notification\n}\n```\n\n\n\n## Summary\n\n1. `Informer` 依赖于 `Reflector` 模块，它有个组件为 xxxInformer，如 `podInformer` \n2. 具体资源的 `Informer` 包含了一个连接到`kube-apiserver`的`client`，通过`List`和`Watch`接口查询资源变更情况\n3. 检测到资源发生变化后，通过`Controller` 将数据放入队列`DeltaFIFOQueue`里，生产阶段完成\n4. 在`DeltaFIFOQueue`的另一端，有消费者在不停地处理资源变化的事件，处理逻辑主要分2步\n   1. 将数据保存到本地存储Indexer，它的底层实现是一个并发安全的threadSafeMap\n   2. 有些组件需要实时关注资源变化，会实时监听listen，就将事件分发到对应注册上来的listener上，自行处理","source":"_posts/k8s-010.md","raw":"---\ntitle: 【K8s源码品读】010：Phase 1 - kube-scheduler - Informer是如何保存数据的\ndate: 2021-02-18 16:55:55\ntags:\n---\n\n## 聚焦目标\n\n了解Informer在发现资源变化后，是怎么处理的\n\n\n\n## 目录\n\n5. [查看消费的过程](#Process)\n6. [掌握Index数据结构](#Index)\n7. [信息的分发distribute](#distribute)\n8. [Informer的综合思考](#Summary)\n\n\n\n## Process\n\n```go\nfunc (c *controller) processLoop() {\n\tfor {\n    // Pop出Object元素\n\t\tobj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))\n\t\tif err != nil {\n\t\t\tif err == ErrFIFOClosed {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif c.config.RetryOnError {\n\t\t\t\t// 重新进队列\n\t\t\t\tc.config.Queue.AddIfNotPresent(obj)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 去查看Pop的具体实现\nfunc (f *FIFO) Pop(process PopProcessFunc) (interface{}, error) {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\tfor {\n\t\t// 调用process去处理item，然后返回\n\t\titem, ok := f.items[id]\n\t\tdelete(f.items, id)\n\t\terr := process(item)\n\t\treturn item, err\n\t}\n}\n\n// 然后去查一下 PopProcessFunc 的定义，在创建controller前\ncfg := &Config{\n\t\tProcess:           s.HandleDeltas,\n\t}\n\nfunc (s *sharedIndexInformer) HandleDeltas(obj interface{}) error {\n\ts.blockDeltas.Lock()\n\tdefer s.blockDeltas.Unlock()\n\n\tfor _, d := range obj.(Deltas) {\n\t\tswitch d.Type {\n    // 增、改、替换、同步\n\t\tcase Sync, Replaced, Added, Updated:\n\t\t\ts.cacheMutationDetector.AddObject(d.Object)\n      // 先去indexer查询\n\t\t\tif old, exists, err := s.indexer.Get(d.Object); err == nil && exists {\n        // 如果数据已经存在，就执行Update逻辑\n\t\t\t\tif err := s.indexer.Update(d.Object); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tisSync := false\n\t\t\t\tswitch {\n\t\t\t\tcase d.Type == Sync:\n\t\t\t\t\tisSync = true\n\t\t\t\tcase d.Type == Replaced:\n\t\t\t\t\tif accessor, err := meta.Accessor(d.Object); err == nil {\n\t\t\t\t\t\t\tisSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n      \t// 分发Update事件\n\t\t\t\ts.processor.distribute(updateNotification{oldObj: old, newObj: d.Object}, isSync)\n\t\t\t} else {\n      \t// 没查到数据，就执行Add操作\n\t\t\t\tif err := s.indexer.Add(d.Object); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n      \t// 分发 Add 事件\n\t\t\t\ts.processor.distribute(addNotification{newObj: d.Object}, false)\n\t\t\t}\n   \t// 删除\n\t\tcase Deleted:\n    \t// 去indexer删除\n\t\t\tif err := s.indexer.Delete(d.Object); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n    \t// 分发 delete 事件\n\t\t\ts.processor.distribute(deleteNotification{oldObj: d.Object}, false)\n\t\t}\n\t}\n\treturn nil\n}\n```\n\n\n\n## Index\n\n`Index` 的定义为资源的本地存储，保持与etcd中的资源信息一致。\n\n```go\n// 我们去看看Index是怎么创建的\nfunc NewSharedIndexInformer(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers) SharedIndexInformer {\n\trealClock := &clock.RealClock{}\n\tsharedIndexInformer := &sharedIndexInformer{\n\t\tprocessor:                       &sharedProcessor{clock: realClock},\n    // indexer 的初始化\n\t\tindexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),\n\t\tlisterWatcher:                   lw,\n\t\tobjectType:                      exampleObject,\n\t\tresyncCheckPeriod:               defaultEventHandlerResyncPeriod,\n\t\tdefaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,\n\t\tcacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(\"%T\", exampleObject)),\n\t\tclock:                           realClock,\n\t}\n\treturn sharedIndexInformer\n}\n\n// 生成一个map和func组合而成的Indexer\nfunc NewIndexer(keyFunc KeyFunc, indexers Indexers) Indexer {\n\treturn &cache{\n\t\tcacheStorage: NewThreadSafeStore(indexers, Indices{}),\n\t\tkeyFunc:      keyFunc,\n}\n\n// ThreadSafeStore的底层是一个并发安全的map，具体实现我们暂不考虑\nfunc NewThreadSafeStore(indexers Indexers, indices Indices) ThreadSafeStore {\n\treturn &threadSafeMap{\n\t\titems:    map[string]interface{}{},\n\t\tindexers: indexers,\n\t\tindices:  indices,\n\t}\n}\n```\n\n\n\n## distribute\n\n```go\n// 在上面的Process代码中，我们看到了将数据存储到Indexer后，调用了一个分发的函数\ns.processor.distribute()\n\n// 分发process的创建\nfunc NewSharedIndexInformer() SharedIndexInformer {\n\tsharedIndexInformer := &sharedIndexInformer{\n\t\tprocessor:                       &sharedProcessor{clock: realClock},\n\t}\n\treturn sharedIndexInformer\n}\n\n// sharedProcessor的结构\ntype sharedProcessor struct {\n\tlistenersStarted bool\n \t// 读写锁\n\tlistenersLock    sync.RWMutex\n  // 普通监听列表\n\tlisteners        []*processorListener\n  // 同步监听列表\n\tsyncingListeners []*processorListener\n\tclock            clock.Clock\n\twg               wait.Group\n}\n\n// 查看distribute函数\nfunc (p *sharedProcessor) distribute(obj interface{}, sync bool) {\n\tp.listenersLock.RLock()\n\tdefer p.listenersLock.RUnlock()\n\t// 将object分发到 同步监听 或者 普通监听 的列表\n\tif sync {\n\t\tfor _, listener := range p.syncingListeners {\n\t\t\tlistener.add(obj)\n\t\t}\n\t} else {\n\t\tfor _, listener := range p.listeners {\n\t\t\tlistener.add(obj)\n\t\t}\n\t}\n}\n\n// 这个add的操作是利用了channel\nfunc (p *processorListener) add(notification interface{}) {\n\tp.addCh <- notification\n}\n```\n\n\n\n## Summary\n\n1. `Informer` 依赖于 `Reflector` 模块，它有个组件为 xxxInformer，如 `podInformer` \n2. 具体资源的 `Informer` 包含了一个连接到`kube-apiserver`的`client`，通过`List`和`Watch`接口查询资源变更情况\n3. 检测到资源发生变化后，通过`Controller` 将数据放入队列`DeltaFIFOQueue`里，生产阶段完成\n4. 在`DeltaFIFOQueue`的另一端，有消费者在不停地处理资源变化的事件，处理逻辑主要分2步\n   1. 将数据保存到本地存储Indexer，它的底层实现是一个并发安全的threadSafeMap\n   2. 有些组件需要实时关注资源变化，会实时监听listen，就将事件分发到对应注册上来的listener上，自行处理","slug":"k8s-010","published":1,"updated":"2021-02-18T09:00:19.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaograo0009a4qp7t5ka86m","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>了解Informer在发现资源变化后，是怎么处理的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol start=\"5\">\n<li><a href=\"#Process\">查看消费的过程</a></li>\n<li><a href=\"#Index\">掌握Index数据结构</a></li>\n<li><a href=\"#distribute\">信息的分发distribute</a></li>\n<li><a href=\"#Summary\">Informer的综合思考</a></li>\n</ol>\n<h2 id=\"Process\"><a href=\"#Process\" class=\"headerlink\" title=\"Process\"></a>Process</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *controller)</span> <span class=\"title\">processLoop</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Pop出Object元素</span></span><br><span class=\"line\">\t\tobj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err == ErrFIFOClosed &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> c.config.RetryOnError &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 重新进队列</span></span><br><span class=\"line\">\t\t\t\tc.config.Queue.AddIfNotPresent(obj)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 去查看Pop的具体实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FIFO)</span> <span class=\"title\">Pop</span><span class=\"params\">(process PopProcessFunc)</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">\tf.lock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> f.lock.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 调用process去处理item，然后返回</span></span><br><span class=\"line\">\t\titem, ok := f.items[id]</span><br><span class=\"line\">\t\t<span class=\"built_in\">delete</span>(f.items, id)</span><br><span class=\"line\">\t\terr := process(item)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> item, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后去查一下 PopProcessFunc 的定义，在创建controller前</span></span><br><span class=\"line\">cfg := &amp;Config&#123;</span><br><span class=\"line\">\t\tProcess:           s.HandleDeltas,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *sharedIndexInformer)</span> <span class=\"title\">HandleDeltas</span><span class=\"params\">(obj <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\ts.blockDeltas.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> s.blockDeltas.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, d := <span class=\"keyword\">range</span> obj.(Deltas) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> d.Type &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 增、改、替换、同步</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> Sync, Replaced, Added, Updated:</span><br><span class=\"line\">\t\t\ts.cacheMutationDetector.AddObject(d.Object)</span><br><span class=\"line\">      <span class=\"comment\">// 先去indexer查询</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class=\"literal\">nil</span> &amp;&amp; exists &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果数据已经存在，就执行Update逻辑</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := s.indexer.Update(d.Object); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tisSync := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> d.Type == Sync:</span><br><span class=\"line\">\t\t\t\t\tisSync = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> d.Type == Replaced:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> accessor, err := meta.Accessor(d.Object); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tisSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// 分发Update事件</span></span><br><span class=\"line\">\t\t\t\ts.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 没查到数据，就执行Add操作</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := s.indexer.Add(d.Object); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// 分发 Add 事件</span></span><br><span class=\"line\">\t\t\t\ts.processor.distribute(addNotification&#123;newObj: d.Object&#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">   \t<span class=\"comment\">// 删除</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> Deleted:</span><br><span class=\"line\">    \t<span class=\"comment\">// 去indexer删除</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := s.indexer.Delete(d.Object); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">    \t<span class=\"comment\">// 分发 delete 事件</span></span><br><span class=\"line\">\t\t\ts.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Index\"><a href=\"#Index\" class=\"headerlink\" title=\"Index\"></a>Index</h2><p><code>Index</code> 的定义为资源的本地存储，保持与etcd中的资源信息一致。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们去看看Index是怎么创建的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSharedIndexInformer</span><span class=\"params\">(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers)</span> <span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\trealClock := &amp;clock.RealClock&#123;&#125;</span><br><span class=\"line\">\tsharedIndexInformer := &amp;sharedIndexInformer&#123;</span><br><span class=\"line\">\t\tprocessor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// indexer 的初始化</span></span><br><span class=\"line\">\t\tindexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),</span><br><span class=\"line\">\t\tlisterWatcher:                   lw,</span><br><span class=\"line\">\t\tobjectType:                      exampleObject,</span><br><span class=\"line\">\t\tresyncCheckPeriod:               defaultEventHandlerResyncPeriod,</span><br><span class=\"line\">\t\tdefaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,</span><br><span class=\"line\">\t\tcacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(<span class=\"string\">&quot;%T&quot;</span>, exampleObject)),</span><br><span class=\"line\">\t\tclock:                           realClock,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sharedIndexInformer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成一个map和func组合而成的Indexer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewIndexer</span><span class=\"params\">(keyFunc KeyFunc, indexers Indexers)</span> <span class=\"title\">Indexer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;cache&#123;</span><br><span class=\"line\">\t\tcacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span><br><span class=\"line\">\t\tkeyFunc:      keyFunc,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ThreadSafeStore的底层是一个并发安全的map，具体实现我们暂不考虑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewThreadSafeStore</span><span class=\"params\">(indexers Indexers, indices Indices)</span> <span class=\"title\">ThreadSafeStore</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;threadSafeMap&#123;</span><br><span class=\"line\">\t\titems:    <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;&#125;,</span><br><span class=\"line\">\t\tindexers: indexers,</span><br><span class=\"line\">\t\tindices:  indices,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"distribute\"><a href=\"#distribute\" class=\"headerlink\" title=\"distribute\"></a>distribute</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在上面的Process代码中，我们看到了将数据存储到Indexer后，调用了一个分发的函数</span></span><br><span class=\"line\">s.processor.distribute()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分发process的创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSharedIndexInformer</span><span class=\"params\">()</span> <span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\tsharedIndexInformer := &amp;sharedIndexInformer&#123;</span><br><span class=\"line\">\t\tprocessor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sharedIndexInformer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sharedProcessor的结构</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> sharedProcessor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlistenersStarted <span class=\"keyword\">bool</span></span><br><span class=\"line\"> \t<span class=\"comment\">// 读写锁</span></span><br><span class=\"line\">\tlistenersLock    sync.RWMutex</span><br><span class=\"line\">  <span class=\"comment\">// 普通监听列表</span></span><br><span class=\"line\">\tlisteners        []*processorListener</span><br><span class=\"line\">  <span class=\"comment\">// 同步监听列表</span></span><br><span class=\"line\">\tsyncingListeners []*processorListener</span><br><span class=\"line\">\tclock            clock.Clock</span><br><span class=\"line\">\twg               wait.Group</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看distribute函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *sharedProcessor)</span> <span class=\"title\">distribute</span><span class=\"params\">(obj <span class=\"keyword\">interface</span>&#123;&#125;, sync <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tp.listenersLock.RLock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.listenersLock.RUnlock()</span><br><span class=\"line\">\t<span class=\"comment\">// 将object分发到 同步监听 或者 普通监听 的列表</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sync &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, listener := <span class=\"keyword\">range</span> p.syncingListeners &#123;</span><br><span class=\"line\">\t\t\tlistener.add(obj)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, listener := <span class=\"keyword\">range</span> p.listeners &#123;</span><br><span class=\"line\">\t\t\tlistener.add(obj)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个add的操作是利用了channel</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *processorListener)</span> <span class=\"title\">add</span><span class=\"params\">(notification <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tp.addCh &lt;- notification</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><ol>\n<li><code>Informer</code> 依赖于 <code>Reflector</code> 模块，它有个组件为 xxxInformer，如 <code>podInformer</code> </li>\n<li>具体资源的 <code>Informer</code> 包含了一个连接到<code>kube-apiserver</code>的<code>client</code>，通过<code>List</code>和<code>Watch</code>接口查询资源变更情况</li>\n<li>检测到资源发生变化后，通过<code>Controller</code> 将数据放入队列<code>DeltaFIFOQueue</code>里，生产阶段完成</li>\n<li>在<code>DeltaFIFOQueue</code>的另一端，有消费者在不停地处理资源变化的事件，处理逻辑主要分2步<ol>\n<li>将数据保存到本地存储Indexer，它的底层实现是一个并发安全的threadSafeMap</li>\n<li>有些组件需要实时关注资源变化，会实时监听listen，就将事件分发到对应注册上来的listener上，自行处理</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>了解Informer在发现资源变化后，是怎么处理的</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol start=\"5\">\n<li><a href=\"#Process\">查看消费的过程</a></li>\n<li><a href=\"#Index\">掌握Index数据结构</a></li>\n<li><a href=\"#distribute\">信息的分发distribute</a></li>\n<li><a href=\"#Summary\">Informer的综合思考</a></li>\n</ol>\n<h2 id=\"Process\"><a href=\"#Process\" class=\"headerlink\" title=\"Process\"></a>Process</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *controller)</span> <span class=\"title\">processLoop</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Pop出Object元素</span></span><br><span class=\"line\">\t\tobj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err == ErrFIFOClosed &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> c.config.RetryOnError &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 重新进队列</span></span><br><span class=\"line\">\t\t\t\tc.config.Queue.AddIfNotPresent(obj)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 去查看Pop的具体实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FIFO)</span> <span class=\"title\">Pop</span><span class=\"params\">(process PopProcessFunc)</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">\tf.lock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> f.lock.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 调用process去处理item，然后返回</span></span><br><span class=\"line\">\t\titem, ok := f.items[id]</span><br><span class=\"line\">\t\t<span class=\"built_in\">delete</span>(f.items, id)</span><br><span class=\"line\">\t\terr := process(item)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> item, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后去查一下 PopProcessFunc 的定义，在创建controller前</span></span><br><span class=\"line\">cfg := &amp;Config&#123;</span><br><span class=\"line\">\t\tProcess:           s.HandleDeltas,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *sharedIndexInformer)</span> <span class=\"title\">HandleDeltas</span><span class=\"params\">(obj <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\ts.blockDeltas.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> s.blockDeltas.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, d := <span class=\"keyword\">range</span> obj.(Deltas) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> d.Type &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 增、改、替换、同步</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> Sync, Replaced, Added, Updated:</span><br><span class=\"line\">\t\t\ts.cacheMutationDetector.AddObject(d.Object)</span><br><span class=\"line\">      <span class=\"comment\">// 先去indexer查询</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class=\"literal\">nil</span> &amp;&amp; exists &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果数据已经存在，就执行Update逻辑</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := s.indexer.Update(d.Object); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tisSync := <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> d.Type == Sync:</span><br><span class=\"line\">\t\t\t\t\tisSync = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> d.Type == Replaced:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> accessor, err := meta.Accessor(d.Object); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tisSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// 分发Update事件</span></span><br><span class=\"line\">\t\t\t\ts.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 没查到数据，就执行Add操作</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := s.indexer.Add(d.Object); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// 分发 Add 事件</span></span><br><span class=\"line\">\t\t\t\ts.processor.distribute(addNotification&#123;newObj: d.Object&#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">   \t<span class=\"comment\">// 删除</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> Deleted:</span><br><span class=\"line\">    \t<span class=\"comment\">// 去indexer删除</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := s.indexer.Delete(d.Object); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">    \t<span class=\"comment\">// 分发 delete 事件</span></span><br><span class=\"line\">\t\t\ts.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Index\"><a href=\"#Index\" class=\"headerlink\" title=\"Index\"></a>Index</h2><p><code>Index</code> 的定义为资源的本地存储，保持与etcd中的资源信息一致。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们去看看Index是怎么创建的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSharedIndexInformer</span><span class=\"params\">(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers)</span> <span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\trealClock := &amp;clock.RealClock&#123;&#125;</span><br><span class=\"line\">\tsharedIndexInformer := &amp;sharedIndexInformer&#123;</span><br><span class=\"line\">\t\tprocessor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// indexer 的初始化</span></span><br><span class=\"line\">\t\tindexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),</span><br><span class=\"line\">\t\tlisterWatcher:                   lw,</span><br><span class=\"line\">\t\tobjectType:                      exampleObject,</span><br><span class=\"line\">\t\tresyncCheckPeriod:               defaultEventHandlerResyncPeriod,</span><br><span class=\"line\">\t\tdefaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,</span><br><span class=\"line\">\t\tcacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(<span class=\"string\">&quot;%T&quot;</span>, exampleObject)),</span><br><span class=\"line\">\t\tclock:                           realClock,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sharedIndexInformer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成一个map和func组合而成的Indexer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewIndexer</span><span class=\"params\">(keyFunc KeyFunc, indexers Indexers)</span> <span class=\"title\">Indexer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;cache&#123;</span><br><span class=\"line\">\t\tcacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span><br><span class=\"line\">\t\tkeyFunc:      keyFunc,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ThreadSafeStore的底层是一个并发安全的map，具体实现我们暂不考虑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewThreadSafeStore</span><span class=\"params\">(indexers Indexers, indices Indices)</span> <span class=\"title\">ThreadSafeStore</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;threadSafeMap&#123;</span><br><span class=\"line\">\t\titems:    <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;&#125;,</span><br><span class=\"line\">\t\tindexers: indexers,</span><br><span class=\"line\">\t\tindices:  indices,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"distribute\"><a href=\"#distribute\" class=\"headerlink\" title=\"distribute\"></a>distribute</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在上面的Process代码中，我们看到了将数据存储到Indexer后，调用了一个分发的函数</span></span><br><span class=\"line\">s.processor.distribute()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分发process的创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSharedIndexInformer</span><span class=\"params\">()</span> <span class=\"title\">SharedIndexInformer</span></span> &#123;</span><br><span class=\"line\">\tsharedIndexInformer := &amp;sharedIndexInformer&#123;</span><br><span class=\"line\">\t\tprocessor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sharedIndexInformer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sharedProcessor的结构</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> sharedProcessor <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlistenersStarted <span class=\"keyword\">bool</span></span><br><span class=\"line\"> \t<span class=\"comment\">// 读写锁</span></span><br><span class=\"line\">\tlistenersLock    sync.RWMutex</span><br><span class=\"line\">  <span class=\"comment\">// 普通监听列表</span></span><br><span class=\"line\">\tlisteners        []*processorListener</span><br><span class=\"line\">  <span class=\"comment\">// 同步监听列表</span></span><br><span class=\"line\">\tsyncingListeners []*processorListener</span><br><span class=\"line\">\tclock            clock.Clock</span><br><span class=\"line\">\twg               wait.Group</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看distribute函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *sharedProcessor)</span> <span class=\"title\">distribute</span><span class=\"params\">(obj <span class=\"keyword\">interface</span>&#123;&#125;, sync <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tp.listenersLock.RLock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.listenersLock.RUnlock()</span><br><span class=\"line\">\t<span class=\"comment\">// 将object分发到 同步监听 或者 普通监听 的列表</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sync &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, listener := <span class=\"keyword\">range</span> p.syncingListeners &#123;</span><br><span class=\"line\">\t\t\tlistener.add(obj)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, listener := <span class=\"keyword\">range</span> p.listeners &#123;</span><br><span class=\"line\">\t\t\tlistener.add(obj)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个add的操作是利用了channel</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *processorListener)</span> <span class=\"title\">add</span><span class=\"params\">(notification <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tp.addCh &lt;- notification</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><ol>\n<li><code>Informer</code> 依赖于 <code>Reflector</code> 模块，它有个组件为 xxxInformer，如 <code>podInformer</code> </li>\n<li>具体资源的 <code>Informer</code> 包含了一个连接到<code>kube-apiserver</code>的<code>client</code>，通过<code>List</code>和<code>Watch</code>接口查询资源变更情况</li>\n<li>检测到资源发生变化后，通过<code>Controller</code> 将数据放入队列<code>DeltaFIFOQueue</code>里，生产阶段完成</li>\n<li>在<code>DeltaFIFOQueue</code>的另一端，有消费者在不停地处理资源变化的事件，处理逻辑主要分2步<ol>\n<li>将数据保存到本地存储Indexer，它的底层实现是一个并发安全的threadSafeMap</li>\n<li>有些组件需要实时关注资源变化，会实时监听listen，就将事件分发到对应注册上来的listener上，自行处理</li>\n</ol>\n</li>\n</ol>\n"},{"title":"【K8s源码品读】011：Phase 1 - kube-scheduler - 了解分配pod的大致流程","date":"2021-02-18T08:55:56.000Z","_content":"\n## 聚焦目标\n\n理解一个pod的被调度的大致流程 \n\n\n\n## 目录\n\n1. [分析Scheduler的结构体](#Scheduler)\n2. [往SchedulingQueue里](#SchedulingQueue)\n3. [调度一个pod对象](#scheduleOne)\n   1. [调度计算结果 - ScheduleResult](#ScheduleResult)\n   2. [初步推算 - Assume](#Assume)\n   3. [实际绑定 - Bind](#Bind)\n4. [将绑定成功后的数据更新到etcd](#update-to-etcd)\n5. [pod绑定Node的总结](#Summary)\n\n\n\n## Scheduler\n\n在前面，我们了解了`Pod调度算法的注册`和`Informer机制来监听kube-apiserver上的资源变化`，今天这一讲，我们就将两者串联起来，看看在kube-scheduler中，Informer监听到资源变化后，如何用调度算法将pod进行调度。\n\n```go\n// 在运行 kube-scheduler 的初期，我们创建了一个Scheduler的数据结构，回头再看看有什么和pod调度算法相关的\ntype Scheduler struct {\n\tSchedulerCache internalcache.Cache\n\tAlgorithm core.ScheduleAlgorithm\n\n\t// 获取下一个需要调度的Pod\n\tNextPod func() *framework.QueuedPodInfo\n\n\tError func(*framework.QueuedPodInfo, error)\n\tStopEverything <-chan struct{}\n\n\t// 等待调度的Pod队列，我们重点看看这个队列是什么\n\tSchedulingQueue internalqueue.SchedulingQueue\n\n\tProfiles profile.Map\n\tscheduledPodsHasSynced func() bool\n\tclient clientset.Interface\n}\n\n// Scheduler的实例化函数\nfunc New(){\n  var sched *Scheduler\n\tswitch {\n  // 从 Provider 创建\n\tcase source.Provider != nil:\n\t\tsc, err := configurator.createFromProvider(*source.Provider)\n\t\tsched = sc\n  // 从文件或者ConfigMap中创建\n\tcase source.Policy != nil:\n\t\tsc, err := configurator.createFromConfig(*policy)\n\t\tsched = sc\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported algorithm source: %v\", source)\n\t}\n}\n\n// 两个创建方式，底层都是调用的 create 函数\nfunc (c *Configurator) createFromProvider(providerName string) (*Scheduler, error) {\n\treturn c.create()\n}\nfunc (c *Configurator) createFromConfig(policy schedulerapi.Policy) (*Scheduler, error){\n\treturn c.create()\n}\n\nfunc (c *Configurator) create() (*Scheduler, error) {\n\t// 实例化 podQueue\n\tpodQueue := internalqueue.NewSchedulingQueue(\n\t\tlessFn,\n\t\tinternalqueue.WithPodInitialBackoffDuration(time.Duration(c.podInitialBackoffSeconds)*time.Second),\n\t\tinternalqueue.WithPodMaxBackoffDuration(time.Duration(c.podMaxBackoffSeconds)*time.Second),\n\t\tinternalqueue.WithPodNominator(nominator),\n\t)\n  \n\treturn &Scheduler{\n\t\tSchedulerCache:  c.schedulerCache,\n\t\tAlgorithm:       algo,\n\t\tProfiles:        profiles,\n    // NextPod 函数依赖于 podQueue\n\t\tNextPod:         internalqueue.MakeNextPodFunc(podQueue),\n\t\tError:           MakeDefaultErrorFunc(c.client, c.informerFactory.Core().V1().Pods().Lister(), podQueue, c.schedulerCache),\n\t\tStopEverything:  c.StopEverything,\n    // 调度队列被赋值为podQueue\n\t\tSchedulingQueue: podQueue,\n\t}, nil\n}\n\n// 再看看这个调度队列的初始化函数，从命名可以看到是一个优先队列，它的实现细节暂不细看\n// 结合实际情况思考下，pod会有重要程度的区分，所以调度的顺序需要考虑优先级的\nfunc NewSchedulingQueue(lessFn framework.LessFunc, opts ...Option) SchedulingQueue {\n\treturn NewPriorityQueue(lessFn, opts...)\n}\n```\n\n\n\n## SchedulingQueue\n\n```go\n// 在上面实例化Scheduler后，有个注册事件 Handler 的函数：addAllEventHandlers(sched, informerFactory, podInformer)\nfunc addAllEventHandlers(\n\tsched *Scheduler,\n\tinformerFactory informers.SharedInformerFactory,\n\tpodInformer coreinformers.PodInformer,\n) {\n\t/*\n\t函数前后有很多注册的Handler，但是和未调度pod添加到队列相关的，只有这个\n\t*/\n\tpodInformer.Informer().AddEventHandler(\n\t\tcache.FilteringResourceEventHandler{\n      // 定义过滤函数：必须为未调度的pod\n\t\t\tFilterFunc: func(obj interface{}) bool {\n\t\t\t\tswitch t := obj.(type) {\n\t\t\t\tcase *v1.Pod:\n\t\t\t\t\treturn !assignedPod(t) && responsibleForPod(t, sched.Profiles)\n\t\t\t\tcase cache.DeletedFinalStateUnknown:\n\t\t\t\t\tif pod, ok := t.Obj.(*v1.Pod); ok {\n\t\t\t\t\t\treturn !assignedPod(pod) && responsibleForPod(pod, sched.Profiles)\n\t\t\t\t\t}\n\t\t\t\t\tutilruntime.HandleError(fmt.Errorf(\"unable to convert object %T to *v1.Pod in %T\", obj, sched))\n\t\t\t\t\treturn false\n\t\t\t\tdefault:\n\t\t\t\t\tutilruntime.HandleError(fmt.Errorf(\"unable to handle object in %T: %T\", sched, obj))\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t},\n     \t// 增改删三个操作对应的Handler，操作到对应的Queue\n\t\t\tHandler: cache.ResourceEventHandlerFuncs{\n\t\t\t\tAddFunc:    sched.addPodToSchedulingQueue,\n\t\t\t\tUpdateFunc: sched.updatePodInSchedulingQueue,\n\t\t\t\tDeleteFunc: sched.deletePodFromSchedulingQueue,\n\t\t\t},\n\t\t},\n\t)\n}\n\n// 牢记我们第一阶段要分析的对象：create nginx pod，所以进入这个add的操作，对应加入到队列\nfunc (sched *Scheduler) addPodToSchedulingQueue(obj interface{}) {\n\tpod := obj.(*v1.Pod)\n\tklog.V(3).Infof(\"add event for unscheduled pod %s/%s\", pod.Namespace, pod.Name)\n  // 加入到队列\n\tif err := sched.SchedulingQueue.Add(pod); err != nil {\n\t\tutilruntime.HandleError(fmt.Errorf(\"unable to queue %T: %v\", obj, err))\n\t}\n}\n\n// 入队操作我们清楚了，那出队呢？我们回过头去看看上面定义的NextPod的方法实现\nfunc MakeNextPodFunc(queue SchedulingQueue) func() *framework.QueuedPodInfo {\n\treturn func() *framework.QueuedPodInfo {\n    // 从队列中弹出\n\t\tpodInfo, err := queue.Pop()\n\t\tif err == nil {\n\t\t\tklog.V(4).Infof(\"About to try and schedule pod %v/%v\", podInfo.Pod.Namespace, podInfo.Pod.Name)\n\t\t\treturn podInfo\n\t\t}\n\t\tklog.Errorf(\"Error while retrieving next pod from scheduling queue: %v\", err)\n\t\treturn nil\n\t}\n}\n```\n\n\n\n## scheduleOne\n\n```go\n// 了解入队和出队操作后，我们看一下Scheduler运行的过程\nfunc (sched *Scheduler) Run(ctx context.Context) {\n\tif !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) {\n\t\treturn\n\t}\n\tsched.SchedulingQueue.Run()\n  // 调度一个pod对象\n\twait.UntilWithContext(ctx, sched.scheduleOne, 0)\n\tsched.SchedulingQueue.Close()\n}\n\n// 接下来scheduleOne方法代码很长，我们一步一步来看\nfunc (sched *Scheduler) scheduleOne(ctx context.Context) {\n  // podInfo 就是从队列中获取到的pod对象\n\tpodInfo := sched.NextPod()\n\t// 检查pod的有效性\n\tif podInfo == nil || podInfo.Pod == nil {\n\t\treturn\n\t}\n\tpod := podInfo.Pod\n  // 根据定义的 pod.Spec.SchedulerName 查到对应的profile\n\tprof, err := sched.profileForPod(pod)\n\tif err != nil {\n\t\tklog.Error(err)\n\t\treturn\n\t}\n  // 可以跳过调度的情况，一般pod进不来\n\tif sched.skipPodSchedule(prof, pod) {\n\t\treturn\n\t}\n\n  // 调用调度算法，获取结果\n\tscheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)\n\tif err != nil {\n\t\t/*\n\t\t出现调度失败的情况：\n\t\t这个时候可能会触发抢占preempt，抢占是一套复杂的逻辑，后面我们专门会讲\n\t\t目前假设各类资源充足，能正常调度\n\t\t*/\n\t}\n\tmetrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInSeconds(start))\n\t\n  // assumePod 是假设这个Pod按照前面的调度算法分配后，进行验证\n\tassumedPodInfo := podInfo.DeepCopy()\n\tassumedPod := assumedPodInfo.Pod\n\t// SuggestedHost 为建议的分配的Host\n\terr = sched.assume(assumedPod, scheduleResult.SuggestedHost)\n\tif err != nil {\n\t\t// 失败就重新分配，不考虑这种情况\n\t}\n\n\t// 运行相关插件的代码先跳过\n\n\t// 异步绑定pod\n\tgo func() {\n    \n\t\t// 有一系列的检查工作\n    \n    // 真正做绑定的动作\n\t\terr := sched.bind(bindingCycleCtx, prof, assumedPod, scheduleResult.SuggestedHost, state)\n\t\tif err != nil {\n\t\t\t// 错误处理，清除状态并重试\n\t\t} else {\n\t\t\t// 打印结果，调试时将log level调整到2以上\n\t\t\tif klog.V(2).Enabled() {\n\t\t\t\tklog.InfoS(\"Successfully bound pod to node\", \"pod\", klog.KObj(pod), \"node\", scheduleResult.SuggestedHost, \"evaluatedNodes\", scheduleResult.EvaluatedNodes, \"feasibleNodes\", scheduleResult.FeasibleNodes)\n\t\t\t}\n      // metrics中记录相关的监控指标\n\t\t\tmetrics.PodScheduled(prof.Name, metrics.SinceInSeconds(start))\n\t\t\tmetrics.PodSchedulingAttempts.Observe(float64(podInfo.Attempts))\n      metrics.PodSchedulingDuration.WithLabelValues(getAttemptsLabel(podInfo)).Observe(metrics.SinceInSeconds(podInfo.InitialAttemptTimestamp))\n\n\t\t\t// 运行绑定后的插件\n\t\t\tprof.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)\n\t\t}\n\t}()\n}\n```\n\n\n\n### ScheduleResult\n\n```go\n// 调用算法下的Schedule\nfunc New(){\n  scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)\n}\n\nfunc (c *Configurator) create() (*Scheduler, error) {\n  algo := core.NewGenericScheduler(\n\t\tc.schedulerCache,\n\t\tc.nodeInfoSnapshot,\n\t\textenders,\n\t\tc.informerFactory.Core().V1().PersistentVolumeClaims().Lister(),\n\t\tc.disablePreemption,\n\t\tc.percentageOfNodesToScore,\n\t)\n  return &Scheduler{\n\t\tAlgorithm:       algo,\n\t}, nil\n}\n\n// genericScheduler 的 Schedule 的实现\nfunc (g *genericScheduler) Schedule(ctx context.Context, prof *profile.Profile, state *framework.CycleState, pod *v1.Pod) (result ScheduleResult, err error) {\n\t// 对 pod 进行 pvc 的信息检查\n\tif err := podPassesBasicChecks(pod, g.pvcLister); err != nil {\n\t\treturn result, err\n\t}\n\t// 对当前的信息做一个快照\n\tif err := g.snapshot(); err != nil {\n\t\treturn result, err\n\t}\n\t// Node 节点数量为0，表示无可用节点\n\tif g.nodeInfoSnapshot.NumNodes() == 0 {\n\t\treturn result, ErrNoNodesAvailable\n\t}\n  // Predict阶段：找到所有满足调度条件的节点feasibleNodes，不满足的就直接过滤\n\tfeasibleNodes, filteredNodesStatuses, err := g.findNodesThatFitPod(ctx, prof, state, pod)\n\t// 没有可用节点直接报错\n\tif len(feasibleNodes) == 0 {\n\t\treturn result, &FitError{\n\t\t\tPod:                   pod,\n\t\t\tNumAllNodes:           g.nodeInfoSnapshot.NumNodes(),\n\t\t\tFilteredNodesStatuses: filteredNodesStatuses,\n\t\t}\n\t}\n\t// 只有一个节点就直接选用\n\tif len(feasibleNodes) == 1 {\n\t\treturn ScheduleResult{\n\t\t\tSuggestedHost:  feasibleNodes[0].Name,\n\t\t\tEvaluatedNodes: 1 + len(filteredNodesStatuses),\n\t\t\tFeasibleNodes:  1,\n\t\t}, nil\n\t}\n\t// Priority阶段：通过打分，找到一个分数最高、也就是最优的节点\n\tpriorityList, err := g.prioritizeNodes(ctx, prof, state, pod, feasibleNodes)\n\thost, err := g.selectHost(priorityList)\n\n\treturn ScheduleResult{\n\t\tSuggestedHost:  host,\n\t\tEvaluatedNodes: len(feasibleNodes) + len(filteredNodesStatuses),\n\t\tFeasibleNodes:  len(feasibleNodes),\n\t}, err\n}\n\n/*\nPredict 和 Priority 是选择调度节点的两个关键性步骤， 它的底层调用了各种algorithm算法。我们暂时不细看。\n以我们前面讲到过的 NodeName 算法为例，节点必须与 NodeName 匹配，它是属于Predict阶段的。\n*/\n```\n\n\n\n### Assume\n\n```go\nfunc (sched *Scheduler) assume(assumed *v1.Pod, host string) error {\n  // 将 host 填入到 pod spec字段的nodename，假定分配到对应的节点上\n\tassumed.Spec.NodeName = host\n  // 调用 SchedulerCache 下的 AssumePod\n\tif err := sched.SchedulerCache.AssumePod(assumed); err != nil {\n\t\tklog.Errorf(\"scheduler cache AssumePod failed: %v\", err)\n\t\treturn err\n\t}\n\tif sched.SchedulingQueue != nil {\n\t\tsched.SchedulingQueue.DeleteNominatedPodIfExists(assumed)\n\t}\n\treturn nil\n}\n\n// 回头去找 SchedulerCache 初始化的地方\nfunc (c *Configurator) create() (*Scheduler, error) {\n\treturn &Scheduler{\n\t\tSchedulerCache:  c.schedulerCache,\n\t}, nil\n}\n\nfunc New() (*Scheduler, error) {\n  // 这里就是初始化的实例 schedulerCache\n\tschedulerCache := internalcache.New(30*time.Second, stopEverything)\n\tconfigurator := &Configurator{\n\t\tschedulerCache:           schedulerCache,\n\t}\n}\n\n// 看看AssumePod做了什么\nfunc (cache *schedulerCache) AssumePod(pod *v1.Pod) error {\n  // 获取 pod 的 uid\n\tkey, err := framework.GetPodKey(pod)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// 加锁操作，保证并发情况下的一致性\n\tcache.mu.Lock()\n\tdefer cache.mu.Unlock()\n  // 根据 uid 找不到 pod 当前的状态\n\tif _, ok := cache.podStates[key]; ok {\n\t\treturn fmt.Errorf(\"pod %v is in the cache, so can't be assumed\", key)\n\t}\n\n  // 把 Assume Pod 的信息放到对应 Node 节点中\n\tcache.addPod(pod)\n  // 把 pod 状态设置为 Assume 成功\n\tps := &podState{\n\t\tpod: pod,\n\t}\n\tcache.podStates[key] = ps\n\tcache.assumedPods[key] = true\n\treturn nil\n}\n```\n\n\n\n### Bind\n\n```go\nfunc (sched *Scheduler) bind(ctx context.Context, prof *profile.Profile, assumed *v1.Pod, targetNode string, state *framework.CycleState) (err error) {\n\tstart := time.Now()\n  // 把 assumed 的 pod 信息保存下来\n\tdefer func() {\n\t\tsched.finishBinding(prof, assumed, targetNode, start, err)\n\t}()\n\t// 阶段1： 运行扩展绑定进行验证，如果已经绑定报错\n\tbound, err := sched.extendersBinding(assumed, targetNode)\n\tif bound {\n\t\treturn err\n\t}\n  // 阶段2：运行绑定插件验证状态\n\tbindStatus := prof.RunBindPlugins(ctx, state, assumed, targetNode)\n\tif bindStatus.IsSuccess() {\n\t\treturn nil\n\t}\n\tif bindStatus.Code() == framework.Error {\n\t\treturn bindStatus.AsError()\n\t}\n\treturn fmt.Errorf(\"bind status: %s, %v\", bindStatus.Code().String(), bindStatus.Message())\n}\n```\n\n\n\n## Update To Etcd\n\n```go\n// 这块的代码我不做细致的逐层分析了，大家根据兴趣自行探索\nfunc (b DefaultBinder) Bind(ctx context.Context, state *framework.CycleState, p *v1.Pod, nodeName string) *framework.Status {\n\tklog.V(3).Infof(\"Attempting to bind %v/%v to %v\", p.Namespace, p.Name, nodeName)\n\tbinding := &v1.Binding{\n\t\tObjectMeta: metav1.ObjectMeta{Namespace: p.Namespace, Name: p.Name, UID: p.UID},\n\t\tTarget:     v1.ObjectReference{Kind: \"Node\", Name: nodeName},\n\t}\n  // ClientSet就是访问kube-apiserver的客户端，将数据更新上去\n\terr := b.handle.ClientSet().CoreV1().Pods(binding.Namespace).Bind(ctx, binding, metav1.CreateOptions{})\n\tif err != nil {\n\t\treturn framework.NewStatus(framework.Error, err.Error())\n\t}\n\treturn nil\n}\n\n```\n\n\n\n## Summary\n\n今天这一次分享比较长，我们一起来总结一下：\n\n1. Pod的调度是通过一个队列`SchedulingQueue`异步工作的\n   1. 监听到对应pod事件后，放入队列\n   2. 有个消费者从队列中获取pod，进行调度\n2. 单个pod的调度主要分为3个步骤：\n   1. 根据Predict和Priority两个阶段，调用各自的算法插件，选择最优的Node\n   2. Assume这个Pod被调度到对应的Node，保存到cache\n   3. 用extender和plugins进行验证，如果通过则绑定\n3. 绑定成功后，将数据通过client向kube-apiserver发送，更新etcd","source":"_posts/k8s-011.md","raw":"---\ntitle: 【K8s源码品读】011：Phase 1 - kube-scheduler - 了解分配pod的大致流程\ndate: 2021-02-18 16:55:56\ntags:\n---\n\n## 聚焦目标\n\n理解一个pod的被调度的大致流程 \n\n\n\n## 目录\n\n1. [分析Scheduler的结构体](#Scheduler)\n2. [往SchedulingQueue里](#SchedulingQueue)\n3. [调度一个pod对象](#scheduleOne)\n   1. [调度计算结果 - ScheduleResult](#ScheduleResult)\n   2. [初步推算 - Assume](#Assume)\n   3. [实际绑定 - Bind](#Bind)\n4. [将绑定成功后的数据更新到etcd](#update-to-etcd)\n5. [pod绑定Node的总结](#Summary)\n\n\n\n## Scheduler\n\n在前面，我们了解了`Pod调度算法的注册`和`Informer机制来监听kube-apiserver上的资源变化`，今天这一讲，我们就将两者串联起来，看看在kube-scheduler中，Informer监听到资源变化后，如何用调度算法将pod进行调度。\n\n```go\n// 在运行 kube-scheduler 的初期，我们创建了一个Scheduler的数据结构，回头再看看有什么和pod调度算法相关的\ntype Scheduler struct {\n\tSchedulerCache internalcache.Cache\n\tAlgorithm core.ScheduleAlgorithm\n\n\t// 获取下一个需要调度的Pod\n\tNextPod func() *framework.QueuedPodInfo\n\n\tError func(*framework.QueuedPodInfo, error)\n\tStopEverything <-chan struct{}\n\n\t// 等待调度的Pod队列，我们重点看看这个队列是什么\n\tSchedulingQueue internalqueue.SchedulingQueue\n\n\tProfiles profile.Map\n\tscheduledPodsHasSynced func() bool\n\tclient clientset.Interface\n}\n\n// Scheduler的实例化函数\nfunc New(){\n  var sched *Scheduler\n\tswitch {\n  // 从 Provider 创建\n\tcase source.Provider != nil:\n\t\tsc, err := configurator.createFromProvider(*source.Provider)\n\t\tsched = sc\n  // 从文件或者ConfigMap中创建\n\tcase source.Policy != nil:\n\t\tsc, err := configurator.createFromConfig(*policy)\n\t\tsched = sc\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported algorithm source: %v\", source)\n\t}\n}\n\n// 两个创建方式，底层都是调用的 create 函数\nfunc (c *Configurator) createFromProvider(providerName string) (*Scheduler, error) {\n\treturn c.create()\n}\nfunc (c *Configurator) createFromConfig(policy schedulerapi.Policy) (*Scheduler, error){\n\treturn c.create()\n}\n\nfunc (c *Configurator) create() (*Scheduler, error) {\n\t// 实例化 podQueue\n\tpodQueue := internalqueue.NewSchedulingQueue(\n\t\tlessFn,\n\t\tinternalqueue.WithPodInitialBackoffDuration(time.Duration(c.podInitialBackoffSeconds)*time.Second),\n\t\tinternalqueue.WithPodMaxBackoffDuration(time.Duration(c.podMaxBackoffSeconds)*time.Second),\n\t\tinternalqueue.WithPodNominator(nominator),\n\t)\n  \n\treturn &Scheduler{\n\t\tSchedulerCache:  c.schedulerCache,\n\t\tAlgorithm:       algo,\n\t\tProfiles:        profiles,\n    // NextPod 函数依赖于 podQueue\n\t\tNextPod:         internalqueue.MakeNextPodFunc(podQueue),\n\t\tError:           MakeDefaultErrorFunc(c.client, c.informerFactory.Core().V1().Pods().Lister(), podQueue, c.schedulerCache),\n\t\tStopEverything:  c.StopEverything,\n    // 调度队列被赋值为podQueue\n\t\tSchedulingQueue: podQueue,\n\t}, nil\n}\n\n// 再看看这个调度队列的初始化函数，从命名可以看到是一个优先队列，它的实现细节暂不细看\n// 结合实际情况思考下，pod会有重要程度的区分，所以调度的顺序需要考虑优先级的\nfunc NewSchedulingQueue(lessFn framework.LessFunc, opts ...Option) SchedulingQueue {\n\treturn NewPriorityQueue(lessFn, opts...)\n}\n```\n\n\n\n## SchedulingQueue\n\n```go\n// 在上面实例化Scheduler后，有个注册事件 Handler 的函数：addAllEventHandlers(sched, informerFactory, podInformer)\nfunc addAllEventHandlers(\n\tsched *Scheduler,\n\tinformerFactory informers.SharedInformerFactory,\n\tpodInformer coreinformers.PodInformer,\n) {\n\t/*\n\t函数前后有很多注册的Handler，但是和未调度pod添加到队列相关的，只有这个\n\t*/\n\tpodInformer.Informer().AddEventHandler(\n\t\tcache.FilteringResourceEventHandler{\n      // 定义过滤函数：必须为未调度的pod\n\t\t\tFilterFunc: func(obj interface{}) bool {\n\t\t\t\tswitch t := obj.(type) {\n\t\t\t\tcase *v1.Pod:\n\t\t\t\t\treturn !assignedPod(t) && responsibleForPod(t, sched.Profiles)\n\t\t\t\tcase cache.DeletedFinalStateUnknown:\n\t\t\t\t\tif pod, ok := t.Obj.(*v1.Pod); ok {\n\t\t\t\t\t\treturn !assignedPod(pod) && responsibleForPod(pod, sched.Profiles)\n\t\t\t\t\t}\n\t\t\t\t\tutilruntime.HandleError(fmt.Errorf(\"unable to convert object %T to *v1.Pod in %T\", obj, sched))\n\t\t\t\t\treturn false\n\t\t\t\tdefault:\n\t\t\t\t\tutilruntime.HandleError(fmt.Errorf(\"unable to handle object in %T: %T\", sched, obj))\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t},\n     \t// 增改删三个操作对应的Handler，操作到对应的Queue\n\t\t\tHandler: cache.ResourceEventHandlerFuncs{\n\t\t\t\tAddFunc:    sched.addPodToSchedulingQueue,\n\t\t\t\tUpdateFunc: sched.updatePodInSchedulingQueue,\n\t\t\t\tDeleteFunc: sched.deletePodFromSchedulingQueue,\n\t\t\t},\n\t\t},\n\t)\n}\n\n// 牢记我们第一阶段要分析的对象：create nginx pod，所以进入这个add的操作，对应加入到队列\nfunc (sched *Scheduler) addPodToSchedulingQueue(obj interface{}) {\n\tpod := obj.(*v1.Pod)\n\tklog.V(3).Infof(\"add event for unscheduled pod %s/%s\", pod.Namespace, pod.Name)\n  // 加入到队列\n\tif err := sched.SchedulingQueue.Add(pod); err != nil {\n\t\tutilruntime.HandleError(fmt.Errorf(\"unable to queue %T: %v\", obj, err))\n\t}\n}\n\n// 入队操作我们清楚了，那出队呢？我们回过头去看看上面定义的NextPod的方法实现\nfunc MakeNextPodFunc(queue SchedulingQueue) func() *framework.QueuedPodInfo {\n\treturn func() *framework.QueuedPodInfo {\n    // 从队列中弹出\n\t\tpodInfo, err := queue.Pop()\n\t\tif err == nil {\n\t\t\tklog.V(4).Infof(\"About to try and schedule pod %v/%v\", podInfo.Pod.Namespace, podInfo.Pod.Name)\n\t\t\treturn podInfo\n\t\t}\n\t\tklog.Errorf(\"Error while retrieving next pod from scheduling queue: %v\", err)\n\t\treturn nil\n\t}\n}\n```\n\n\n\n## scheduleOne\n\n```go\n// 了解入队和出队操作后，我们看一下Scheduler运行的过程\nfunc (sched *Scheduler) Run(ctx context.Context) {\n\tif !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) {\n\t\treturn\n\t}\n\tsched.SchedulingQueue.Run()\n  // 调度一个pod对象\n\twait.UntilWithContext(ctx, sched.scheduleOne, 0)\n\tsched.SchedulingQueue.Close()\n}\n\n// 接下来scheduleOne方法代码很长，我们一步一步来看\nfunc (sched *Scheduler) scheduleOne(ctx context.Context) {\n  // podInfo 就是从队列中获取到的pod对象\n\tpodInfo := sched.NextPod()\n\t// 检查pod的有效性\n\tif podInfo == nil || podInfo.Pod == nil {\n\t\treturn\n\t}\n\tpod := podInfo.Pod\n  // 根据定义的 pod.Spec.SchedulerName 查到对应的profile\n\tprof, err := sched.profileForPod(pod)\n\tif err != nil {\n\t\tklog.Error(err)\n\t\treturn\n\t}\n  // 可以跳过调度的情况，一般pod进不来\n\tif sched.skipPodSchedule(prof, pod) {\n\t\treturn\n\t}\n\n  // 调用调度算法，获取结果\n\tscheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)\n\tif err != nil {\n\t\t/*\n\t\t出现调度失败的情况：\n\t\t这个时候可能会触发抢占preempt，抢占是一套复杂的逻辑，后面我们专门会讲\n\t\t目前假设各类资源充足，能正常调度\n\t\t*/\n\t}\n\tmetrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInSeconds(start))\n\t\n  // assumePod 是假设这个Pod按照前面的调度算法分配后，进行验证\n\tassumedPodInfo := podInfo.DeepCopy()\n\tassumedPod := assumedPodInfo.Pod\n\t// SuggestedHost 为建议的分配的Host\n\terr = sched.assume(assumedPod, scheduleResult.SuggestedHost)\n\tif err != nil {\n\t\t// 失败就重新分配，不考虑这种情况\n\t}\n\n\t// 运行相关插件的代码先跳过\n\n\t// 异步绑定pod\n\tgo func() {\n    \n\t\t// 有一系列的检查工作\n    \n    // 真正做绑定的动作\n\t\terr := sched.bind(bindingCycleCtx, prof, assumedPod, scheduleResult.SuggestedHost, state)\n\t\tif err != nil {\n\t\t\t// 错误处理，清除状态并重试\n\t\t} else {\n\t\t\t// 打印结果，调试时将log level调整到2以上\n\t\t\tif klog.V(2).Enabled() {\n\t\t\t\tklog.InfoS(\"Successfully bound pod to node\", \"pod\", klog.KObj(pod), \"node\", scheduleResult.SuggestedHost, \"evaluatedNodes\", scheduleResult.EvaluatedNodes, \"feasibleNodes\", scheduleResult.FeasibleNodes)\n\t\t\t}\n      // metrics中记录相关的监控指标\n\t\t\tmetrics.PodScheduled(prof.Name, metrics.SinceInSeconds(start))\n\t\t\tmetrics.PodSchedulingAttempts.Observe(float64(podInfo.Attempts))\n      metrics.PodSchedulingDuration.WithLabelValues(getAttemptsLabel(podInfo)).Observe(metrics.SinceInSeconds(podInfo.InitialAttemptTimestamp))\n\n\t\t\t// 运行绑定后的插件\n\t\t\tprof.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)\n\t\t}\n\t}()\n}\n```\n\n\n\n### ScheduleResult\n\n```go\n// 调用算法下的Schedule\nfunc New(){\n  scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)\n}\n\nfunc (c *Configurator) create() (*Scheduler, error) {\n  algo := core.NewGenericScheduler(\n\t\tc.schedulerCache,\n\t\tc.nodeInfoSnapshot,\n\t\textenders,\n\t\tc.informerFactory.Core().V1().PersistentVolumeClaims().Lister(),\n\t\tc.disablePreemption,\n\t\tc.percentageOfNodesToScore,\n\t)\n  return &Scheduler{\n\t\tAlgorithm:       algo,\n\t}, nil\n}\n\n// genericScheduler 的 Schedule 的实现\nfunc (g *genericScheduler) Schedule(ctx context.Context, prof *profile.Profile, state *framework.CycleState, pod *v1.Pod) (result ScheduleResult, err error) {\n\t// 对 pod 进行 pvc 的信息检查\n\tif err := podPassesBasicChecks(pod, g.pvcLister); err != nil {\n\t\treturn result, err\n\t}\n\t// 对当前的信息做一个快照\n\tif err := g.snapshot(); err != nil {\n\t\treturn result, err\n\t}\n\t// Node 节点数量为0，表示无可用节点\n\tif g.nodeInfoSnapshot.NumNodes() == 0 {\n\t\treturn result, ErrNoNodesAvailable\n\t}\n  // Predict阶段：找到所有满足调度条件的节点feasibleNodes，不满足的就直接过滤\n\tfeasibleNodes, filteredNodesStatuses, err := g.findNodesThatFitPod(ctx, prof, state, pod)\n\t// 没有可用节点直接报错\n\tif len(feasibleNodes) == 0 {\n\t\treturn result, &FitError{\n\t\t\tPod:                   pod,\n\t\t\tNumAllNodes:           g.nodeInfoSnapshot.NumNodes(),\n\t\t\tFilteredNodesStatuses: filteredNodesStatuses,\n\t\t}\n\t}\n\t// 只有一个节点就直接选用\n\tif len(feasibleNodes) == 1 {\n\t\treturn ScheduleResult{\n\t\t\tSuggestedHost:  feasibleNodes[0].Name,\n\t\t\tEvaluatedNodes: 1 + len(filteredNodesStatuses),\n\t\t\tFeasibleNodes:  1,\n\t\t}, nil\n\t}\n\t// Priority阶段：通过打分，找到一个分数最高、也就是最优的节点\n\tpriorityList, err := g.prioritizeNodes(ctx, prof, state, pod, feasibleNodes)\n\thost, err := g.selectHost(priorityList)\n\n\treturn ScheduleResult{\n\t\tSuggestedHost:  host,\n\t\tEvaluatedNodes: len(feasibleNodes) + len(filteredNodesStatuses),\n\t\tFeasibleNodes:  len(feasibleNodes),\n\t}, err\n}\n\n/*\nPredict 和 Priority 是选择调度节点的两个关键性步骤， 它的底层调用了各种algorithm算法。我们暂时不细看。\n以我们前面讲到过的 NodeName 算法为例，节点必须与 NodeName 匹配，它是属于Predict阶段的。\n*/\n```\n\n\n\n### Assume\n\n```go\nfunc (sched *Scheduler) assume(assumed *v1.Pod, host string) error {\n  // 将 host 填入到 pod spec字段的nodename，假定分配到对应的节点上\n\tassumed.Spec.NodeName = host\n  // 调用 SchedulerCache 下的 AssumePod\n\tif err := sched.SchedulerCache.AssumePod(assumed); err != nil {\n\t\tklog.Errorf(\"scheduler cache AssumePod failed: %v\", err)\n\t\treturn err\n\t}\n\tif sched.SchedulingQueue != nil {\n\t\tsched.SchedulingQueue.DeleteNominatedPodIfExists(assumed)\n\t}\n\treturn nil\n}\n\n// 回头去找 SchedulerCache 初始化的地方\nfunc (c *Configurator) create() (*Scheduler, error) {\n\treturn &Scheduler{\n\t\tSchedulerCache:  c.schedulerCache,\n\t}, nil\n}\n\nfunc New() (*Scheduler, error) {\n  // 这里就是初始化的实例 schedulerCache\n\tschedulerCache := internalcache.New(30*time.Second, stopEverything)\n\tconfigurator := &Configurator{\n\t\tschedulerCache:           schedulerCache,\n\t}\n}\n\n// 看看AssumePod做了什么\nfunc (cache *schedulerCache) AssumePod(pod *v1.Pod) error {\n  // 获取 pod 的 uid\n\tkey, err := framework.GetPodKey(pod)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// 加锁操作，保证并发情况下的一致性\n\tcache.mu.Lock()\n\tdefer cache.mu.Unlock()\n  // 根据 uid 找不到 pod 当前的状态\n\tif _, ok := cache.podStates[key]; ok {\n\t\treturn fmt.Errorf(\"pod %v is in the cache, so can't be assumed\", key)\n\t}\n\n  // 把 Assume Pod 的信息放到对应 Node 节点中\n\tcache.addPod(pod)\n  // 把 pod 状态设置为 Assume 成功\n\tps := &podState{\n\t\tpod: pod,\n\t}\n\tcache.podStates[key] = ps\n\tcache.assumedPods[key] = true\n\treturn nil\n}\n```\n\n\n\n### Bind\n\n```go\nfunc (sched *Scheduler) bind(ctx context.Context, prof *profile.Profile, assumed *v1.Pod, targetNode string, state *framework.CycleState) (err error) {\n\tstart := time.Now()\n  // 把 assumed 的 pod 信息保存下来\n\tdefer func() {\n\t\tsched.finishBinding(prof, assumed, targetNode, start, err)\n\t}()\n\t// 阶段1： 运行扩展绑定进行验证，如果已经绑定报错\n\tbound, err := sched.extendersBinding(assumed, targetNode)\n\tif bound {\n\t\treturn err\n\t}\n  // 阶段2：运行绑定插件验证状态\n\tbindStatus := prof.RunBindPlugins(ctx, state, assumed, targetNode)\n\tif bindStatus.IsSuccess() {\n\t\treturn nil\n\t}\n\tif bindStatus.Code() == framework.Error {\n\t\treturn bindStatus.AsError()\n\t}\n\treturn fmt.Errorf(\"bind status: %s, %v\", bindStatus.Code().String(), bindStatus.Message())\n}\n```\n\n\n\n## Update To Etcd\n\n```go\n// 这块的代码我不做细致的逐层分析了，大家根据兴趣自行探索\nfunc (b DefaultBinder) Bind(ctx context.Context, state *framework.CycleState, p *v1.Pod, nodeName string) *framework.Status {\n\tklog.V(3).Infof(\"Attempting to bind %v/%v to %v\", p.Namespace, p.Name, nodeName)\n\tbinding := &v1.Binding{\n\t\tObjectMeta: metav1.ObjectMeta{Namespace: p.Namespace, Name: p.Name, UID: p.UID},\n\t\tTarget:     v1.ObjectReference{Kind: \"Node\", Name: nodeName},\n\t}\n  // ClientSet就是访问kube-apiserver的客户端，将数据更新上去\n\terr := b.handle.ClientSet().CoreV1().Pods(binding.Namespace).Bind(ctx, binding, metav1.CreateOptions{})\n\tif err != nil {\n\t\treturn framework.NewStatus(framework.Error, err.Error())\n\t}\n\treturn nil\n}\n\n```\n\n\n\n## Summary\n\n今天这一次分享比较长，我们一起来总结一下：\n\n1. Pod的调度是通过一个队列`SchedulingQueue`异步工作的\n   1. 监听到对应pod事件后，放入队列\n   2. 有个消费者从队列中获取pod，进行调度\n2. 单个pod的调度主要分为3个步骤：\n   1. 根据Predict和Priority两个阶段，调用各自的算法插件，选择最优的Node\n   2. Assume这个Pod被调度到对应的Node，保存到cache\n   3. 用extender和plugins进行验证，如果通过则绑定\n3. 绑定成功后，将数据通过client向kube-apiserver发送，更新etcd","slug":"k8s-011","published":1,"updated":"2021-02-18T09:00:34.687Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaograp000aa4qp8a6134fk","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解一个pod的被调度的大致流程 </p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#Scheduler\">分析Scheduler的结构体</a></li>\n<li><a href=\"#SchedulingQueue\">往SchedulingQueue里</a></li>\n<li><a href=\"#scheduleOne\">调度一个pod对象</a><ol>\n<li><a href=\"#ScheduleResult\">调度计算结果 - ScheduleResult</a></li>\n<li><a href=\"#Assume\">初步推算 - Assume</a></li>\n<li><a href=\"#Bind\">实际绑定 - Bind</a></li>\n</ol>\n</li>\n<li><a href=\"#update-to-etcd\">将绑定成功后的数据更新到etcd</a></li>\n<li><a href=\"#Summary\">pod绑定Node的总结</a></li>\n</ol>\n<h2 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h2><p>在前面，我们了解了<code>Pod调度算法的注册</code>和<code>Informer机制来监听kube-apiserver上的资源变化</code>，今天这一讲，我们就将两者串联起来，看看在kube-scheduler中，Informer监听到资源变化后，如何用调度算法将pod进行调度。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在运行 kube-scheduler 的初期，我们创建了一个Scheduler的数据结构，回头再看看有什么和pod调度算法相关的</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Scheduler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tSchedulerCache internalcache.Cache</span><br><span class=\"line\">\tAlgorithm core.ScheduleAlgorithm</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取下一个需要调度的Pod</span></span><br><span class=\"line\">\tNextPod <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> *<span class=\"title\">framework</span>.<span class=\"title\">QueuedPodInfo</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tError <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*framework.QueuedPodInfo, error)</span></span></span><br><span class=\"line\">\tStopEverything &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 等待调度的Pod队列，我们重点看看这个队列是什么</span></span><br><span class=\"line\">\tSchedulingQueue internalqueue.SchedulingQueue</span><br><span class=\"line\"></span><br><span class=\"line\">\tProfiles profile.Map</span><br><span class=\"line\">\tscheduledPodsHasSynced <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\">\tclient clientset.Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Scheduler的实例化函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sched *Scheduler</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从 Provider 创建</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> source.Provider != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\tsc, err := configurator.createFromProvider(*source.Provider)</span><br><span class=\"line\">\t\tsched = sc</span><br><span class=\"line\">  <span class=\"comment\">// 从文件或者ConfigMap中创建</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> source.Policy != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\tsc, err := configurator.createFromConfig(*policy)</span><br><span class=\"line\">\t\tsched = sc</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;unsupported algorithm source: %v&quot;</span>, source)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 两个创建方式，底层都是调用的 create 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">createFromProvider</span><span class=\"params\">(providerName <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">createFromConfig</span><span class=\"params\">(policy schedulerapi.Policy)</span> <span class=\"params\">(*Scheduler, error)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例化 podQueue</span></span><br><span class=\"line\">\tpodQueue := internalqueue.NewSchedulingQueue(</span><br><span class=\"line\">\t\tlessFn,</span><br><span class=\"line\">\t\tinternalqueue.WithPodInitialBackoffDuration(time.Duration(c.podInitialBackoffSeconds)*time.Second),</span><br><span class=\"line\">\t\tinternalqueue.WithPodMaxBackoffDuration(time.Duration(c.podMaxBackoffSeconds)*time.Second),</span><br><span class=\"line\">\t\tinternalqueue.WithPodNominator(nominator),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Scheduler&#123;</span><br><span class=\"line\">\t\tSchedulerCache:  c.schedulerCache,</span><br><span class=\"line\">\t\tAlgorithm:       algo,</span><br><span class=\"line\">\t\tProfiles:        profiles,</span><br><span class=\"line\">    <span class=\"comment\">// NextPod 函数依赖于 podQueue</span></span><br><span class=\"line\">\t\tNextPod:         internalqueue.MakeNextPodFunc(podQueue),</span><br><span class=\"line\">\t\tError:           MakeDefaultErrorFunc(c.client, c.informerFactory.Core().V1().Pods().Lister(), podQueue, c.schedulerCache),</span><br><span class=\"line\">\t\tStopEverything:  c.StopEverything,</span><br><span class=\"line\">    <span class=\"comment\">// 调度队列被赋值为podQueue</span></span><br><span class=\"line\">\t\tSchedulingQueue: podQueue,</span><br><span class=\"line\">\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再看看这个调度队列的初始化函数，从命名可以看到是一个优先队列，它的实现细节暂不细看</span></span><br><span class=\"line\"><span class=\"comment\">// 结合实际情况思考下，pod会有重要程度的区分，所以调度的顺序需要考虑优先级的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSchedulingQueue</span><span class=\"params\">(lessFn framework.LessFunc, opts ...Option)</span> <span class=\"title\">SchedulingQueue</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewPriorityQueue(lessFn, opts...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SchedulingQueue\"><a href=\"#SchedulingQueue\" class=\"headerlink\" title=\"SchedulingQueue\"></a>SchedulingQueue</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在上面实例化Scheduler后，有个注册事件 Handler 的函数：addAllEventHandlers(sched, informerFactory, podInformer)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addAllEventHandlers</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tsched *Scheduler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tinformerFactory informers.SharedInformerFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tpodInformer coreinformers.PodInformer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t函数前后有很多注册的Handler，但是和未调度pod添加到队列相关的，只有这个</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tpodInformer.Informer().AddEventHandler(</span><br><span class=\"line\">\t\tcache.FilteringResourceEventHandler&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 定义过滤函数：必须为未调度的pod</span></span><br><span class=\"line\">\t\t\tFilterFunc: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(obj <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> t := obj.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> *v1.Pod:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> !assignedPod(t) &amp;&amp; responsibleForPod(t, sched.Profiles)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> cache.DeletedFinalStateUnknown:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> pod, ok := t.Obj.(*v1.Pod); ok &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> !assignedPod(pod) &amp;&amp; responsibleForPod(pod, sched.Profiles)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;unable to convert object %T to *v1.Pod in %T&quot;</span>, obj, sched))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;unable to handle object in %T: %T&quot;</span>, sched, obj))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">     \t<span class=\"comment\">// 增改删三个操作对应的Handler，操作到对应的Queue</span></span><br><span class=\"line\">\t\t\tHandler: cache.ResourceEventHandlerFuncs&#123;</span><br><span class=\"line\">\t\t\t\tAddFunc:    sched.addPodToSchedulingQueue,</span><br><span class=\"line\">\t\t\t\tUpdateFunc: sched.updatePodInSchedulingQueue,</span><br><span class=\"line\">\t\t\t\tDeleteFunc: sched.deletePodFromSchedulingQueue,</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 牢记我们第一阶段要分析的对象：create nginx pod，所以进入这个add的操作，对应加入到队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">addPodToSchedulingQueue</span><span class=\"params\">(obj <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tpod := obj.(*v1.Pod)</span><br><span class=\"line\">\tklog.V(<span class=\"number\">3</span>).Infof(<span class=\"string\">&quot;add event for unscheduled pod %s/%s&quot;</span>, pod.Namespace, pod.Name)</span><br><span class=\"line\">  <span class=\"comment\">// 加入到队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := sched.SchedulingQueue.Add(pod); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;unable to queue %T: %v&quot;</span>, obj, err))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入队操作我们清楚了，那出队呢？我们回过头去看看上面定义的NextPod的方法实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MakeNextPodFunc</span><span class=\"params\">(queue SchedulingQueue)</span> <span class=\"title\">func</span><span class=\"params\">()</span> *<span class=\"title\">framework</span>.<span class=\"title\">QueuedPodInfo</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> *<span class=\"title\">framework</span>.<span class=\"title\">QueuedPodInfo</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从队列中弹出</span></span><br><span class=\"line\">\t\tpodInfo, err := queue.Pop()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;About to try and schedule pod %v/%v&quot;</span>, podInfo.Pod.Namespace, podInfo.Pod.Name)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> podInfo</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.Errorf(<span class=\"string\">&quot;Error while retrieving next pod from scheduling queue: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"scheduleOne\"><a href=\"#scheduleOne\" class=\"headerlink\" title=\"scheduleOne\"></a>scheduleOne</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 了解入队和出队操作后，我们看一下Scheduler运行的过程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">Run</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsched.SchedulingQueue.Run()</span><br><span class=\"line\">  <span class=\"comment\">// 调度一个pod对象</span></span><br><span class=\"line\">\twait.UntilWithContext(ctx, sched.scheduleOne, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tsched.SchedulingQueue.Close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下来scheduleOne方法代码很长，我们一步一步来看</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">scheduleOne</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// podInfo 就是从队列中获取到的pod对象</span></span><br><span class=\"line\">\tpodInfo := sched.NextPod()</span><br><span class=\"line\">\t<span class=\"comment\">// 检查pod的有效性</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> podInfo == <span class=\"literal\">nil</span> || podInfo.Pod == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpod := podInfo.Pod</span><br><span class=\"line\">  <span class=\"comment\">// 根据定义的 pod.Spec.SchedulerName 查到对应的profile</span></span><br><span class=\"line\">\tprof, err := sched.profileForPod(pod)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Error(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 可以跳过调度的情况，一般pod进不来</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.skipPodSchedule(prof, pod) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用调度算法，获取结果</span></span><br><span class=\"line\">\tscheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t出现调度失败的情况：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t这个时候可能会触发抢占preempt，抢占是一套复杂的逻辑，后面我们专门会讲</span></span><br><span class=\"line\"><span class=\"comment\">\t\t目前假设各类资源充足，能正常调度</span></span><br><span class=\"line\"><span class=\"comment\">\t\t*/</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmetrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInSeconds(start))</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// assumePod 是假设这个Pod按照前面的调度算法分配后，进行验证</span></span><br><span class=\"line\">\tassumedPodInfo := podInfo.DeepCopy()</span><br><span class=\"line\">\tassumedPod := assumedPodInfo.Pod</span><br><span class=\"line\">\t<span class=\"comment\">// SuggestedHost 为建议的分配的Host</span></span><br><span class=\"line\">\terr = sched.assume(assumedPod, scheduleResult.SuggestedHost)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 失败就重新分配，不考虑这种情况</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 运行相关插件的代码先跳过</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 异步绑定pod</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">// 有一系列的检查工作</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 真正做绑定的动作</span></span><br><span class=\"line\">\t\terr := sched.bind(bindingCycleCtx, prof, assumedPod, scheduleResult.SuggestedHost, state)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 错误处理，清除状态并重试</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 打印结果，调试时将log level调整到2以上</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> klog.V(<span class=\"number\">2</span>).Enabled() &#123;</span><br><span class=\"line\">\t\t\t\tklog.InfoS(<span class=\"string\">&quot;Successfully bound pod to node&quot;</span>, <span class=\"string\">&quot;pod&quot;</span>, klog.KObj(pod), <span class=\"string\">&quot;node&quot;</span>, scheduleResult.SuggestedHost, <span class=\"string\">&quot;evaluatedNodes&quot;</span>, scheduleResult.EvaluatedNodes, <span class=\"string\">&quot;feasibleNodes&quot;</span>, scheduleResult.FeasibleNodes)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// metrics中记录相关的监控指标</span></span><br><span class=\"line\">\t\t\tmetrics.PodScheduled(prof.Name, metrics.SinceInSeconds(start))</span><br><span class=\"line\">\t\t\tmetrics.PodSchedulingAttempts.Observe(<span class=\"keyword\">float64</span>(podInfo.Attempts))</span><br><span class=\"line\">      metrics.PodSchedulingDuration.WithLabelValues(getAttemptsLabel(podInfo)).Observe(metrics.SinceInSeconds(podInfo.InitialAttemptTimestamp))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 运行绑定后的插件</span></span><br><span class=\"line\">\t\t\tprof.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ScheduleResult\"><a href=\"#ScheduleResult\" class=\"headerlink\" title=\"ScheduleResult\"></a>ScheduleResult</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用算法下的Schedule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">  algo := core.NewGenericScheduler(</span><br><span class=\"line\">\t\tc.schedulerCache,</span><br><span class=\"line\">\t\tc.nodeInfoSnapshot,</span><br><span class=\"line\">\t\textenders,</span><br><span class=\"line\">\t\tc.informerFactory.Core().V1().PersistentVolumeClaims().Lister(),</span><br><span class=\"line\">\t\tc.disablePreemption,</span><br><span class=\"line\">\t\tc.percentageOfNodesToScore,</span><br><span class=\"line\">\t)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Scheduler&#123;</span><br><span class=\"line\">\t\tAlgorithm:       algo,</span><br><span class=\"line\">\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// genericScheduler 的 Schedule 的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *genericScheduler)</span> <span class=\"title\">Schedule</span><span class=\"params\">(ctx context.Context, prof *profile.Profile, state *framework.CycleState, pod *v1.Pod)</span> <span class=\"params\">(result ScheduleResult, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对 pod 进行 pvc 的信息检查</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := podPassesBasicChecks(pod, g.pvcLister); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 对当前的信息做一个快照</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := g.snapshot(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Node 节点数量为0，表示无可用节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.nodeInfoSnapshot.NumNodes() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result, ErrNoNodesAvailable</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// Predict阶段：找到所有满足调度条件的节点feasibleNodes，不满足的就直接过滤</span></span><br><span class=\"line\">\tfeasibleNodes, filteredNodesStatuses, err := g.findNodesThatFitPod(ctx, prof, state, pod)</span><br><span class=\"line\">\t<span class=\"comment\">// 没有可用节点直接报错</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(feasibleNodes) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result, &amp;FitError&#123;</span><br><span class=\"line\">\t\t\tPod:                   pod,</span><br><span class=\"line\">\t\t\tNumAllNodes:           g.nodeInfoSnapshot.NumNodes(),</span><br><span class=\"line\">\t\t\tFilteredNodesStatuses: filteredNodesStatuses,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 只有一个节点就直接选用</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(feasibleNodes) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ScheduleResult&#123;</span><br><span class=\"line\">\t\t\tSuggestedHost:  feasibleNodes[<span class=\"number\">0</span>].Name,</span><br><span class=\"line\">\t\t\tEvaluatedNodes: <span class=\"number\">1</span> + <span class=\"built_in\">len</span>(filteredNodesStatuses),</span><br><span class=\"line\">\t\t\tFeasibleNodes:  <span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Priority阶段：通过打分，找到一个分数最高、也就是最优的节点</span></span><br><span class=\"line\">\tpriorityList, err := g.prioritizeNodes(ctx, prof, state, pod, feasibleNodes)</span><br><span class=\"line\">\thost, err := g.selectHost(priorityList)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ScheduleResult&#123;</span><br><span class=\"line\">\t\tSuggestedHost:  host,</span><br><span class=\"line\">\t\tEvaluatedNodes: <span class=\"built_in\">len</span>(feasibleNodes) + <span class=\"built_in\">len</span>(filteredNodesStatuses),</span><br><span class=\"line\">\t\tFeasibleNodes:  <span class=\"built_in\">len</span>(feasibleNodes),</span><br><span class=\"line\">\t&#125;, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Predict 和 Priority 是选择调度节点的两个关键性步骤， 它的底层调用了各种algorithm算法。我们暂时不细看。</span></span><br><span class=\"line\"><span class=\"comment\">以我们前面讲到过的 NodeName 算法为例，节点必须与 NodeName 匹配，它是属于Predict阶段的。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Assume\"><a href=\"#Assume\" class=\"headerlink\" title=\"Assume\"></a>Assume</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">assume</span><span class=\"params\">(assumed *v1.Pod, host <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将 host 填入到 pod spec字段的nodename，假定分配到对应的节点上</span></span><br><span class=\"line\">\tassumed.Spec.NodeName = host</span><br><span class=\"line\">  <span class=\"comment\">// 调用 SchedulerCache 下的 AssumePod</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := sched.SchedulerCache.AssumePod(assumed); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Errorf(<span class=\"string\">&quot;scheduler cache AssumePod failed: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.SchedulingQueue != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tsched.SchedulingQueue.DeleteNominatedPodIfExists(assumed)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 回头去找 SchedulerCache 初始化的地方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Scheduler&#123;</span><br><span class=\"line\">\t\tSchedulerCache:  c.schedulerCache,</span><br><span class=\"line\">\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里就是初始化的实例 schedulerCache</span></span><br><span class=\"line\">\tschedulerCache := internalcache.New(<span class=\"number\">30</span>*time.Second, stopEverything)</span><br><span class=\"line\">\tconfigurator := &amp;Configurator&#123;</span><br><span class=\"line\">\t\tschedulerCache:           schedulerCache,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 看看AssumePod做了什么</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cache *schedulerCache)</span> <span class=\"title\">AssumePod</span><span class=\"params\">(pod *v1.Pod)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取 pod 的 uid</span></span><br><span class=\"line\">\tkey, err := framework.GetPodKey(pod)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 加锁操作，保证并发情况下的一致性</span></span><br><span class=\"line\">\tcache.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> cache.mu.Unlock()</span><br><span class=\"line\">  <span class=\"comment\">// 根据 uid 找不到 pod 当前的状态</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := cache.podStates[key]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;pod %v is in the cache, so can&#x27;t be assumed&quot;</span>, key)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 把 Assume Pod 的信息放到对应 Node 节点中</span></span><br><span class=\"line\">\tcache.addPod(pod)</span><br><span class=\"line\">  <span class=\"comment\">// 把 pod 状态设置为 Assume 成功</span></span><br><span class=\"line\">\tps := &amp;podState&#123;</span><br><span class=\"line\">\t\tpod: pod,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcache.podStates[key] = ps</span><br><span class=\"line\">\tcache.assumedPods[key] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Bind\"><a href=\"#Bind\" class=\"headerlink\" title=\"Bind\"></a>Bind</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">bind</span><span class=\"params\">(ctx context.Context, prof *profile.Profile, assumed *v1.Pod, targetNode <span class=\"keyword\">string</span>, state *framework.CycleState)</span> <span class=\"params\">(err error)</span></span> &#123;</span><br><span class=\"line\">\tstart := time.Now()</span><br><span class=\"line\">  <span class=\"comment\">// 把 assumed 的 pod 信息保存下来</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tsched.finishBinding(prof, assumed, targetNode, start, err)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// 阶段1： 运行扩展绑定进行验证，如果已经绑定报错</span></span><br><span class=\"line\">\tbound, err := sched.extendersBinding(assumed, targetNode)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bound &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 阶段2：运行绑定插件验证状态</span></span><br><span class=\"line\">\tbindStatus := prof.RunBindPlugins(ctx, state, assumed, targetNode)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bindStatus.IsSuccess() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bindStatus.Code() == framework.Error &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bindStatus.AsError()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;bind status: %s, %v&quot;</span>, bindStatus.Code().String(), bindStatus.Message())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Update-To-Etcd\"><a href=\"#Update-To-Etcd\" class=\"headerlink\" title=\"Update To Etcd\"></a>Update To Etcd</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这块的代码我不做细致的逐层分析了，大家根据兴趣自行探索</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b DefaultBinder)</span> <span class=\"title\">Bind</span><span class=\"params\">(ctx context.Context, state *framework.CycleState, p *v1.Pod, nodeName <span class=\"keyword\">string</span>)</span> *<span class=\"title\">framework</span>.<span class=\"title\">Status</span></span> &#123;</span><br><span class=\"line\">\tklog.V(<span class=\"number\">3</span>).Infof(<span class=\"string\">&quot;Attempting to bind %v/%v to %v&quot;</span>, p.Namespace, p.Name, nodeName)</span><br><span class=\"line\">\tbinding := &amp;v1.Binding&#123;</span><br><span class=\"line\">\t\tObjectMeta: metav1.ObjectMeta&#123;Namespace: p.Namespace, Name: p.Name, UID: p.UID&#125;,</span><br><span class=\"line\">\t\tTarget:     v1.ObjectReference&#123;Kind: <span class=\"string\">&quot;Node&quot;</span>, Name: nodeName&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// ClientSet就是访问kube-apiserver的客户端，将数据更新上去</span></span><br><span class=\"line\">\terr := b.handle.ClientSet().CoreV1().Pods(binding.Namespace).Bind(ctx, binding, metav1.CreateOptions&#123;&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> framework.NewStatus(framework.Error, err.Error())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>今天这一次分享比较长，我们一起来总结一下：</p>\n<ol>\n<li>Pod的调度是通过一个队列<code>SchedulingQueue</code>异步工作的<ol>\n<li>监听到对应pod事件后，放入队列</li>\n<li>有个消费者从队列中获取pod，进行调度</li>\n</ol>\n</li>\n<li>单个pod的调度主要分为3个步骤：<ol>\n<li>根据Predict和Priority两个阶段，调用各自的算法插件，选择最优的Node</li>\n<li>Assume这个Pod被调度到对应的Node，保存到cache</li>\n<li>用extender和plugins进行验证，如果通过则绑定</li>\n</ol>\n</li>\n<li>绑定成功后，将数据通过client向kube-apiserver发送，更新etcd</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解一个pod的被调度的大致流程 </p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#Scheduler\">分析Scheduler的结构体</a></li>\n<li><a href=\"#SchedulingQueue\">往SchedulingQueue里</a></li>\n<li><a href=\"#scheduleOne\">调度一个pod对象</a><ol>\n<li><a href=\"#ScheduleResult\">调度计算结果 - ScheduleResult</a></li>\n<li><a href=\"#Assume\">初步推算 - Assume</a></li>\n<li><a href=\"#Bind\">实际绑定 - Bind</a></li>\n</ol>\n</li>\n<li><a href=\"#update-to-etcd\">将绑定成功后的数据更新到etcd</a></li>\n<li><a href=\"#Summary\">pod绑定Node的总结</a></li>\n</ol>\n<h2 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h2><p>在前面，我们了解了<code>Pod调度算法的注册</code>和<code>Informer机制来监听kube-apiserver上的资源变化</code>，今天这一讲，我们就将两者串联起来，看看在kube-scheduler中，Informer监听到资源变化后，如何用调度算法将pod进行调度。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在运行 kube-scheduler 的初期，我们创建了一个Scheduler的数据结构，回头再看看有什么和pod调度算法相关的</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Scheduler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tSchedulerCache internalcache.Cache</span><br><span class=\"line\">\tAlgorithm core.ScheduleAlgorithm</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取下一个需要调度的Pod</span></span><br><span class=\"line\">\tNextPod <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> *<span class=\"title\">framework</span>.<span class=\"title\">QueuedPodInfo</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tError <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*framework.QueuedPodInfo, error)</span></span></span><br><span class=\"line\">\tStopEverything &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 等待调度的Pod队列，我们重点看看这个队列是什么</span></span><br><span class=\"line\">\tSchedulingQueue internalqueue.SchedulingQueue</span><br><span class=\"line\"></span><br><span class=\"line\">\tProfiles profile.Map</span><br><span class=\"line\">\tscheduledPodsHasSynced <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\">\tclient clientset.Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Scheduler的实例化函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sched *Scheduler</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从 Provider 创建</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> source.Provider != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\tsc, err := configurator.createFromProvider(*source.Provider)</span><br><span class=\"line\">\t\tsched = sc</span><br><span class=\"line\">  <span class=\"comment\">// 从文件或者ConfigMap中创建</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> source.Policy != <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\tsc, err := configurator.createFromConfig(*policy)</span><br><span class=\"line\">\t\tsched = sc</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;unsupported algorithm source: %v&quot;</span>, source)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 两个创建方式，底层都是调用的 create 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">createFromProvider</span><span class=\"params\">(providerName <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">createFromConfig</span><span class=\"params\">(policy schedulerapi.Policy)</span> <span class=\"params\">(*Scheduler, error)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例化 podQueue</span></span><br><span class=\"line\">\tpodQueue := internalqueue.NewSchedulingQueue(</span><br><span class=\"line\">\t\tlessFn,</span><br><span class=\"line\">\t\tinternalqueue.WithPodInitialBackoffDuration(time.Duration(c.podInitialBackoffSeconds)*time.Second),</span><br><span class=\"line\">\t\tinternalqueue.WithPodMaxBackoffDuration(time.Duration(c.podMaxBackoffSeconds)*time.Second),</span><br><span class=\"line\">\t\tinternalqueue.WithPodNominator(nominator),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Scheduler&#123;</span><br><span class=\"line\">\t\tSchedulerCache:  c.schedulerCache,</span><br><span class=\"line\">\t\tAlgorithm:       algo,</span><br><span class=\"line\">\t\tProfiles:        profiles,</span><br><span class=\"line\">    <span class=\"comment\">// NextPod 函数依赖于 podQueue</span></span><br><span class=\"line\">\t\tNextPod:         internalqueue.MakeNextPodFunc(podQueue),</span><br><span class=\"line\">\t\tError:           MakeDefaultErrorFunc(c.client, c.informerFactory.Core().V1().Pods().Lister(), podQueue, c.schedulerCache),</span><br><span class=\"line\">\t\tStopEverything:  c.StopEverything,</span><br><span class=\"line\">    <span class=\"comment\">// 调度队列被赋值为podQueue</span></span><br><span class=\"line\">\t\tSchedulingQueue: podQueue,</span><br><span class=\"line\">\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再看看这个调度队列的初始化函数，从命名可以看到是一个优先队列，它的实现细节暂不细看</span></span><br><span class=\"line\"><span class=\"comment\">// 结合实际情况思考下，pod会有重要程度的区分，所以调度的顺序需要考虑优先级的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSchedulingQueue</span><span class=\"params\">(lessFn framework.LessFunc, opts ...Option)</span> <span class=\"title\">SchedulingQueue</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NewPriorityQueue(lessFn, opts...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SchedulingQueue\"><a href=\"#SchedulingQueue\" class=\"headerlink\" title=\"SchedulingQueue\"></a>SchedulingQueue</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在上面实例化Scheduler后，有个注册事件 Handler 的函数：addAllEventHandlers(sched, informerFactory, podInformer)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addAllEventHandlers</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tsched *Scheduler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tinformerFactory informers.SharedInformerFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tpodInformer coreinformers.PodInformer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t函数前后有很多注册的Handler，但是和未调度pod添加到队列相关的，只有这个</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tpodInformer.Informer().AddEventHandler(</span><br><span class=\"line\">\t\tcache.FilteringResourceEventHandler&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 定义过滤函数：必须为未调度的pod</span></span><br><span class=\"line\">\t\t\tFilterFunc: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(obj <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> t := obj.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> *v1.Pod:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> !assignedPod(t) &amp;&amp; responsibleForPod(t, sched.Profiles)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> cache.DeletedFinalStateUnknown:</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> pod, ok := t.Obj.(*v1.Pod); ok &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> !assignedPod(pod) &amp;&amp; responsibleForPod(pod, sched.Profiles)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;unable to convert object %T to *v1.Pod in %T&quot;</span>, obj, sched))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;unable to handle object in %T: %T&quot;</span>, sched, obj))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">     \t<span class=\"comment\">// 增改删三个操作对应的Handler，操作到对应的Queue</span></span><br><span class=\"line\">\t\t\tHandler: cache.ResourceEventHandlerFuncs&#123;</span><br><span class=\"line\">\t\t\t\tAddFunc:    sched.addPodToSchedulingQueue,</span><br><span class=\"line\">\t\t\t\tUpdateFunc: sched.updatePodInSchedulingQueue,</span><br><span class=\"line\">\t\t\t\tDeleteFunc: sched.deletePodFromSchedulingQueue,</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 牢记我们第一阶段要分析的对象：create nginx pod，所以进入这个add的操作，对应加入到队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">addPodToSchedulingQueue</span><span class=\"params\">(obj <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tpod := obj.(*v1.Pod)</span><br><span class=\"line\">\tklog.V(<span class=\"number\">3</span>).Infof(<span class=\"string\">&quot;add event for unscheduled pod %s/%s&quot;</span>, pod.Namespace, pod.Name)</span><br><span class=\"line\">  <span class=\"comment\">// 加入到队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := sched.SchedulingQueue.Add(pod); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;unable to queue %T: %v&quot;</span>, obj, err))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入队操作我们清楚了，那出队呢？我们回过头去看看上面定义的NextPod的方法实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MakeNextPodFunc</span><span class=\"params\">(queue SchedulingQueue)</span> <span class=\"title\">func</span><span class=\"params\">()</span> *<span class=\"title\">framework</span>.<span class=\"title\">QueuedPodInfo</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> *<span class=\"title\">framework</span>.<span class=\"title\">QueuedPodInfo</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从队列中弹出</span></span><br><span class=\"line\">\t\tpodInfo, err := queue.Pop()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;About to try and schedule pod %v/%v&quot;</span>, podInfo.Pod.Namespace, podInfo.Pod.Name)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> podInfo</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.Errorf(<span class=\"string\">&quot;Error while retrieving next pod from scheduling queue: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"scheduleOne\"><a href=\"#scheduleOne\" class=\"headerlink\" title=\"scheduleOne\"></a>scheduleOne</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 了解入队和出队操作后，我们看一下Scheduler运行的过程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">Run</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsched.SchedulingQueue.Run()</span><br><span class=\"line\">  <span class=\"comment\">// 调度一个pod对象</span></span><br><span class=\"line\">\twait.UntilWithContext(ctx, sched.scheduleOne, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tsched.SchedulingQueue.Close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下来scheduleOne方法代码很长，我们一步一步来看</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">scheduleOne</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// podInfo 就是从队列中获取到的pod对象</span></span><br><span class=\"line\">\tpodInfo := sched.NextPod()</span><br><span class=\"line\">\t<span class=\"comment\">// 检查pod的有效性</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> podInfo == <span class=\"literal\">nil</span> || podInfo.Pod == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpod := podInfo.Pod</span><br><span class=\"line\">  <span class=\"comment\">// 根据定义的 pod.Spec.SchedulerName 查到对应的profile</span></span><br><span class=\"line\">\tprof, err := sched.profileForPod(pod)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Error(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 可以跳过调度的情况，一般pod进不来</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.skipPodSchedule(prof, pod) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用调度算法，获取结果</span></span><br><span class=\"line\">\tscheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t出现调度失败的情况：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t这个时候可能会触发抢占preempt，抢占是一套复杂的逻辑，后面我们专门会讲</span></span><br><span class=\"line\"><span class=\"comment\">\t\t目前假设各类资源充足，能正常调度</span></span><br><span class=\"line\"><span class=\"comment\">\t\t*/</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmetrics.SchedulingAlgorithmLatency.Observe(metrics.SinceInSeconds(start))</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// assumePod 是假设这个Pod按照前面的调度算法分配后，进行验证</span></span><br><span class=\"line\">\tassumedPodInfo := podInfo.DeepCopy()</span><br><span class=\"line\">\tassumedPod := assumedPodInfo.Pod</span><br><span class=\"line\">\t<span class=\"comment\">// SuggestedHost 为建议的分配的Host</span></span><br><span class=\"line\">\terr = sched.assume(assumedPod, scheduleResult.SuggestedHost)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 失败就重新分配，不考虑这种情况</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 运行相关插件的代码先跳过</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 异步绑定pod</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">// 有一系列的检查工作</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 真正做绑定的动作</span></span><br><span class=\"line\">\t\terr := sched.bind(bindingCycleCtx, prof, assumedPod, scheduleResult.SuggestedHost, state)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 错误处理，清除状态并重试</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 打印结果，调试时将log level调整到2以上</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> klog.V(<span class=\"number\">2</span>).Enabled() &#123;</span><br><span class=\"line\">\t\t\t\tklog.InfoS(<span class=\"string\">&quot;Successfully bound pod to node&quot;</span>, <span class=\"string\">&quot;pod&quot;</span>, klog.KObj(pod), <span class=\"string\">&quot;node&quot;</span>, scheduleResult.SuggestedHost, <span class=\"string\">&quot;evaluatedNodes&quot;</span>, scheduleResult.EvaluatedNodes, <span class=\"string\">&quot;feasibleNodes&quot;</span>, scheduleResult.FeasibleNodes)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// metrics中记录相关的监控指标</span></span><br><span class=\"line\">\t\t\tmetrics.PodScheduled(prof.Name, metrics.SinceInSeconds(start))</span><br><span class=\"line\">\t\t\tmetrics.PodSchedulingAttempts.Observe(<span class=\"keyword\">float64</span>(podInfo.Attempts))</span><br><span class=\"line\">      metrics.PodSchedulingDuration.WithLabelValues(getAttemptsLabel(podInfo)).Observe(metrics.SinceInSeconds(podInfo.InitialAttemptTimestamp))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 运行绑定后的插件</span></span><br><span class=\"line\">\t\t\tprof.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ScheduleResult\"><a href=\"#ScheduleResult\" class=\"headerlink\" title=\"ScheduleResult\"></a>ScheduleResult</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用算法下的Schedule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, prof, state, pod)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">  algo := core.NewGenericScheduler(</span><br><span class=\"line\">\t\tc.schedulerCache,</span><br><span class=\"line\">\t\tc.nodeInfoSnapshot,</span><br><span class=\"line\">\t\textenders,</span><br><span class=\"line\">\t\tc.informerFactory.Core().V1().PersistentVolumeClaims().Lister(),</span><br><span class=\"line\">\t\tc.disablePreemption,</span><br><span class=\"line\">\t\tc.percentageOfNodesToScore,</span><br><span class=\"line\">\t)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Scheduler&#123;</span><br><span class=\"line\">\t\tAlgorithm:       algo,</span><br><span class=\"line\">\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// genericScheduler 的 Schedule 的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *genericScheduler)</span> <span class=\"title\">Schedule</span><span class=\"params\">(ctx context.Context, prof *profile.Profile, state *framework.CycleState, pod *v1.Pod)</span> <span class=\"params\">(result ScheduleResult, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对 pod 进行 pvc 的信息检查</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := podPassesBasicChecks(pod, g.pvcLister); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 对当前的信息做一个快照</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := g.snapshot(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Node 节点数量为0，表示无可用节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.nodeInfoSnapshot.NumNodes() == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result, ErrNoNodesAvailable</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// Predict阶段：找到所有满足调度条件的节点feasibleNodes，不满足的就直接过滤</span></span><br><span class=\"line\">\tfeasibleNodes, filteredNodesStatuses, err := g.findNodesThatFitPod(ctx, prof, state, pod)</span><br><span class=\"line\">\t<span class=\"comment\">// 没有可用节点直接报错</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(feasibleNodes) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result, &amp;FitError&#123;</span><br><span class=\"line\">\t\t\tPod:                   pod,</span><br><span class=\"line\">\t\t\tNumAllNodes:           g.nodeInfoSnapshot.NumNodes(),</span><br><span class=\"line\">\t\t\tFilteredNodesStatuses: filteredNodesStatuses,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 只有一个节点就直接选用</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(feasibleNodes) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ScheduleResult&#123;</span><br><span class=\"line\">\t\t\tSuggestedHost:  feasibleNodes[<span class=\"number\">0</span>].Name,</span><br><span class=\"line\">\t\t\tEvaluatedNodes: <span class=\"number\">1</span> + <span class=\"built_in\">len</span>(filteredNodesStatuses),</span><br><span class=\"line\">\t\t\tFeasibleNodes:  <span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Priority阶段：通过打分，找到一个分数最高、也就是最优的节点</span></span><br><span class=\"line\">\tpriorityList, err := g.prioritizeNodes(ctx, prof, state, pod, feasibleNodes)</span><br><span class=\"line\">\thost, err := g.selectHost(priorityList)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ScheduleResult&#123;</span><br><span class=\"line\">\t\tSuggestedHost:  host,</span><br><span class=\"line\">\t\tEvaluatedNodes: <span class=\"built_in\">len</span>(feasibleNodes) + <span class=\"built_in\">len</span>(filteredNodesStatuses),</span><br><span class=\"line\">\t\tFeasibleNodes:  <span class=\"built_in\">len</span>(feasibleNodes),</span><br><span class=\"line\">\t&#125;, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Predict 和 Priority 是选择调度节点的两个关键性步骤， 它的底层调用了各种algorithm算法。我们暂时不细看。</span></span><br><span class=\"line\"><span class=\"comment\">以我们前面讲到过的 NodeName 算法为例，节点必须与 NodeName 匹配，它是属于Predict阶段的。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Assume\"><a href=\"#Assume\" class=\"headerlink\" title=\"Assume\"></a>Assume</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">assume</span><span class=\"params\">(assumed *v1.Pod, host <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将 host 填入到 pod spec字段的nodename，假定分配到对应的节点上</span></span><br><span class=\"line\">\tassumed.Spec.NodeName = host</span><br><span class=\"line\">  <span class=\"comment\">// 调用 SchedulerCache 下的 AssumePod</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := sched.SchedulerCache.AssumePod(assumed); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Errorf(<span class=\"string\">&quot;scheduler cache AssumePod failed: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.SchedulingQueue != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tsched.SchedulingQueue.DeleteNominatedPodIfExists(assumed)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 回头去找 SchedulerCache 初始化的地方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Configurator)</span> <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Scheduler&#123;</span><br><span class=\"line\">\t\tSchedulerCache:  c.schedulerCache,</span><br><span class=\"line\">\t&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> <span class=\"params\">(*Scheduler, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里就是初始化的实例 schedulerCache</span></span><br><span class=\"line\">\tschedulerCache := internalcache.New(<span class=\"number\">30</span>*time.Second, stopEverything)</span><br><span class=\"line\">\tconfigurator := &amp;Configurator&#123;</span><br><span class=\"line\">\t\tschedulerCache:           schedulerCache,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 看看AssumePod做了什么</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cache *schedulerCache)</span> <span class=\"title\">AssumePod</span><span class=\"params\">(pod *v1.Pod)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取 pod 的 uid</span></span><br><span class=\"line\">\tkey, err := framework.GetPodKey(pod)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 加锁操作，保证并发情况下的一致性</span></span><br><span class=\"line\">\tcache.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> cache.mu.Unlock()</span><br><span class=\"line\">  <span class=\"comment\">// 根据 uid 找不到 pod 当前的状态</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := cache.podStates[key]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;pod %v is in the cache, so can&#x27;t be assumed&quot;</span>, key)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 把 Assume Pod 的信息放到对应 Node 节点中</span></span><br><span class=\"line\">\tcache.addPod(pod)</span><br><span class=\"line\">  <span class=\"comment\">// 把 pod 状态设置为 Assume 成功</span></span><br><span class=\"line\">\tps := &amp;podState&#123;</span><br><span class=\"line\">\t\tpod: pod,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcache.podStates[key] = ps</span><br><span class=\"line\">\tcache.assumedPods[key] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Bind\"><a href=\"#Bind\" class=\"headerlink\" title=\"Bind\"></a>Bind</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sched *Scheduler)</span> <span class=\"title\">bind</span><span class=\"params\">(ctx context.Context, prof *profile.Profile, assumed *v1.Pod, targetNode <span class=\"keyword\">string</span>, state *framework.CycleState)</span> <span class=\"params\">(err error)</span></span> &#123;</span><br><span class=\"line\">\tstart := time.Now()</span><br><span class=\"line\">  <span class=\"comment\">// 把 assumed 的 pod 信息保存下来</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tsched.finishBinding(prof, assumed, targetNode, start, err)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"comment\">// 阶段1： 运行扩展绑定进行验证，如果已经绑定报错</span></span><br><span class=\"line\">\tbound, err := sched.extendersBinding(assumed, targetNode)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bound &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 阶段2：运行绑定插件验证状态</span></span><br><span class=\"line\">\tbindStatus := prof.RunBindPlugins(ctx, state, assumed, targetNode)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bindStatus.IsSuccess() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bindStatus.Code() == framework.Error &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bindStatus.AsError()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;bind status: %s, %v&quot;</span>, bindStatus.Code().String(), bindStatus.Message())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Update-To-Etcd\"><a href=\"#Update-To-Etcd\" class=\"headerlink\" title=\"Update To Etcd\"></a>Update To Etcd</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这块的代码我不做细致的逐层分析了，大家根据兴趣自行探索</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b DefaultBinder)</span> <span class=\"title\">Bind</span><span class=\"params\">(ctx context.Context, state *framework.CycleState, p *v1.Pod, nodeName <span class=\"keyword\">string</span>)</span> *<span class=\"title\">framework</span>.<span class=\"title\">Status</span></span> &#123;</span><br><span class=\"line\">\tklog.V(<span class=\"number\">3</span>).Infof(<span class=\"string\">&quot;Attempting to bind %v/%v to %v&quot;</span>, p.Namespace, p.Name, nodeName)</span><br><span class=\"line\">\tbinding := &amp;v1.Binding&#123;</span><br><span class=\"line\">\t\tObjectMeta: metav1.ObjectMeta&#123;Namespace: p.Namespace, Name: p.Name, UID: p.UID&#125;,</span><br><span class=\"line\">\t\tTarget:     v1.ObjectReference&#123;Kind: <span class=\"string\">&quot;Node&quot;</span>, Name: nodeName&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// ClientSet就是访问kube-apiserver的客户端，将数据更新上去</span></span><br><span class=\"line\">\terr := b.handle.ClientSet().CoreV1().Pods(binding.Namespace).Bind(ctx, binding, metav1.CreateOptions&#123;&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> framework.NewStatus(framework.Error, err.Error())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>今天这一次分享比较长，我们一起来总结一下：</p>\n<ol>\n<li>Pod的调度是通过一个队列<code>SchedulingQueue</code>异步工作的<ol>\n<li>监听到对应pod事件后，放入队列</li>\n<li>有个消费者从队列中获取pod，进行调度</li>\n</ol>\n</li>\n<li>单个pod的调度主要分为3个步骤：<ol>\n<li>根据Predict和Priority两个阶段，调用各自的算法插件，选择最优的Node</li>\n<li>Assume这个Pod被调度到对应的Node，保存到cache</li>\n<li>用extender和plugins进行验证，如果通过则绑定</li>\n</ol>\n</li>\n<li>绑定成功后，将数据通过client向kube-apiserver发送，更新etcd</li>\n</ol>\n"},{"title":"【K8s源码品读】012：Phase 1 - kube-controller-manager - 了解控制管理中心","date":"2021-02-18T08:55:57.000Z","_content":"\n## 聚焦目标\n\n理解 kube-controller-manager 的运行机制\n\n\n\n## 目录\n\n1. [运行的主函数](#Run)\n2. [控制器的启动函数](#StartControllers)\n3. [引入概念ReplicaSet](#ReplicaSet)\n4. [查看ReplicaSetController](#ReplicaSetController)\n5. [ReplicaSet的核心实现函数](#syncReplicaSet)\n6. [总结](#Summary)\n\n\n\n## Run\n\n我们找到了对应的主函数，看看其中的内容\n\n```go\nfunc Run(c *config.CompletedConfig, stopCh <-chan struct{}) error {\n\t// configz 模块，在kube-scheduler分析中已经了解\n\tif cfgz, err := configz.New(ConfigzName); err == nil {\n\t\tcfgz.Set(c.ComponentConfig)\n\t} else {\n\t\tklog.Errorf(\"unable to register configz: %v\", err)\n\t}\n\n\t// 健康监测与http服务，跳过\n\tvar checks []healthz.HealthChecker\n\tvar unsecuredMux *mux.PathRecorderMux\n\n\trun := func(ctx context.Context) {\n\t\trootClientBuilder := controller.SimpleControllerClientBuilder{\n\t\t\tClientConfig: c.Kubeconfig,\n\t\t}\n   \n    // client认证相关\n\t\tvar clientBuilder controller.ControllerClientBuilder\n\t\t\n    // 创建controller的上下文context\n\t\tcontrollerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())\n\t\tif err != nil {\n\t\t\tklog.Fatalf(\"error building controller context: %v\", err)\n\t\t}\n\t\tsaTokenControllerInitFunc := serviceAccountTokenControllerStarter{rootClientBuilder: rootClientBuilder}.startServiceAccountTokenController\n\n\t\tif err := StartControllers(controllerContext, saTokenControllerInitFunc, NewControllerInitializers(controllerContext.LoopMode), unsecuredMux); err != nil {\n\t\t\tklog.Fatalf(\"error starting controllers: %v\", err)\n\t\t}\n\n    // 这里的 InformerFactory 和我们在kube-scheduler中看的 SharedInformerFactory 基本一致\n\t\tcontrollerContext.InformerFactory.Start(controllerContext.Stop)\n\t\tcontrollerContext.ObjectOrMetadataInformerFactory.Start(controllerContext.Stop)\n\t\tclose(controllerContext.InformersStarted)\n\n\t\tselect {}\n\t}\n\n  // 是否进行选举\n\tif !c.ComponentConfig.Generic.LeaderElection.LeaderElect {\n\t\trun(context.TODO())\n\t\tpanic(\"unreachable\")\n\t}\n\n  // 拼接出一个全局唯一的id\n\tid, err := os.Hostname()\n\tif err != nil {\n\t\treturn err\n\t}\n\tid = id + \"_\" + string(uuid.NewUUID())\n\n\trl, err := resourcelock.New(c.ComponentConfig.Generic.LeaderElection.ResourceLock,\n\t\tc.ComponentConfig.Generic.LeaderElection.ResourceNamespace,\n\t\tc.ComponentConfig.Generic.LeaderElection.ResourceName,\n\t\tc.LeaderElectionClient.CoreV1(),\n\t\tc.LeaderElectionClient.CoordinationV1(),\n\t\tresourcelock.ResourceLockConfig{\n\t\t\tIdentity:      id,\n\t\t\tEventRecorder: c.EventRecorder,\n\t\t})\n\tif err != nil {\n\t\tklog.Fatalf(\"error creating lock: %v\", err)\n\t}\n\n  // 正常情况下都是阻塞在RunOrDie这个函数中，不停地进行选举相关的工作\n\tleaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig{\n\t\tLock:          rl,\n\t\tLeaseDuration: c.ComponentConfig.Generic.LeaderElection.LeaseDuration.Duration,\n\t\tRenewDeadline: c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration,\n\t\tRetryPeriod:   c.ComponentConfig.Generic.LeaderElection.RetryPeriod.Duration,\n\t\tCallbacks: leaderelection.LeaderCallbacks{\n      // 开始成为Leader的时候，调用run函数\n\t\t\tOnStartedLeading: run,\n\t\t\tOnStoppedLeading: func() {\n\t\t\t\tklog.Fatalf(\"leaderelection lost\")\n\t\t\t},\n\t\t},\n\t\tWatchDog: electionChecker,\n\t\tName:     \"kube-controller-manager\",\n\t})\n\tpanic(\"unreachable\")\n}\n```\n\n\n\n## StartControllers\n\n```go\nfunc StartControllers(ctx ControllerContext, startSATokenController InitFunc, controllers map[string]InitFunc, unsecuredMux *mux.PathRecorderMux) error {\n\t// 关键性的循环，启动每个controllers，key为控制器名字，value为初始化函数\n\tfor controllerName, initFn := range controllers {\n    // 是否允许启动\n\t\tif !ctx.IsControllerEnabled(controllerName) {\n\t\t\tklog.Warningf(\"%q is disabled\", controllerName)\n\t\t\tcontinue\n\t\t}\n\t\ttime.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))\n\t\tklog.V(1).Infof(\"Starting %q\", controllerName)\n    // 调用init函数进行启动\n\t\tdebugHandler, started, err := initFn(ctx)\n\t\tif err != nil {\n\t\t\tklog.Errorf(\"Error starting %q\", controllerName)\n\t\t\treturn err\n\t\t}\n\t\tif !started {\n\t\t\tklog.Warningf(\"Skipping %q\", controllerName)\n\t\t\tcontinue\n\t\t}\n    // 注册对应controller到debug的url中\n\t\tif debugHandler != nil && unsecuredMux != nil {\n\t\t\tbasePath := \"/debug/controllers/\" + controllerName\n\t\t\tunsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))\n\t\t\tunsecuredMux.UnlistedHandlePrefix(basePath+\"/\", http.StripPrefix(basePath, debugHandler))\n\t\t}\n\t\tklog.Infof(\"Started %q\", controllerName)\n\t}\n\n\treturn nil\n}\n\n// 我们再去传入controller的函数去看看，对应的controller有哪些，这里有我们很多常见的概念，今天不一一细讲\nfunc NewControllerInitializers(loopMode ControllerLoopMode) map[string]InitFunc {\n\tcontrollers := map[string]InitFunc{}\n\tcontrollers[\"endpoint\"] = startEndpointController\n\tcontrollers[\"endpointslice\"] = startEndpointSliceController\n\tcontrollers[\"endpointslicemirroring\"] = startEndpointSliceMirroringController\n\tcontrollers[\"replicationcontroller\"] = startReplicationController\n\tcontrollers[\"podgc\"] = startPodGCController\n\tcontrollers[\"resourcequota\"] = startResourceQuotaController\n\tcontrollers[\"namespace\"] = startNamespaceController\n\tcontrollers[\"serviceaccount\"] = startServiceAccountController\n\tcontrollers[\"garbagecollector\"] = startGarbageCollectorController\n\tcontrollers[\"daemonset\"] = startDaemonSetController\n\tcontrollers[\"job\"] = startJobController\n\tcontrollers[\"deployment\"] = startDeploymentController\n\tcontrollers[\"replicaset\"] = startReplicaSetController\n\tcontrollers[\"horizontalpodautoscaling\"] = startHPAController\n\tcontrollers[\"disruption\"] = startDisruptionController\n\tcontrollers[\"statefulset\"] = startStatefulSetController\n\tcontrollers[\"cronjob\"] = startCronJobController\n\tcontrollers[\"csrsigning\"] = startCSRSigningController\n\tcontrollers[\"csrapproving\"] = startCSRApprovingController\n\tcontrollers[\"csrcleaner\"] = startCSRCleanerController\n\tcontrollers[\"ttl\"] = startTTLController\n\tcontrollers[\"bootstrapsigner\"] = startBootstrapSignerController\n\tcontrollers[\"tokencleaner\"] = startTokenCleanerController\n\tcontrollers[\"nodeipam\"] = startNodeIpamController\n\tcontrollers[\"nodelifecycle\"] = startNodeLifecycleController\n\tif loopMode == IncludeCloudLoops {\n\t\tcontrollers[\"service\"] = startServiceController\n\t\tcontrollers[\"route\"] = startRouteController\n\t\tcontrollers[\"cloud-node-lifecycle\"] = startCloudNodeLifecycleController\n\t}\n\tcontrollers[\"persistentvolume-binder\"] = startPersistentVolumeBinderController\n\tcontrollers[\"attachdetach\"] = startAttachDetachController\n\tcontrollers[\"persistentvolume-expander\"] = startVolumeExpandController\n\tcontrollers[\"clusterrole-aggregation\"] = startClusterRoleAggregrationController\n\tcontrollers[\"pvc-protection\"] = startPVCProtectionController\n\tcontrollers[\"pv-protection\"] = startPVProtectionController\n\tcontrollers[\"ttl-after-finished\"] = startTTLAfterFinishedController\n\tcontrollers[\"root-ca-cert-publisher\"] = startRootCACertPublisher\n\tcontrollers[\"ephemeral-volume\"] = startEphemeralVolumeController\n\n\treturn controllers\n}\n```\n\n\n\n## ReplicaSet\n\n由于我们的示例是创建一个nginx的pod，涉及到kube-controller-manager的内容很少。\n\n但是，为了加深大家对 kube-controller-manager 的认识，我们引入一个新的概念 - ReplicaSet，下面是官方说明：\n\n> A ReplicaSet's purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.\n\n> ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。\n\n简单来说，ReplicaSet 就是用来生成指定个数的Pod。\n\n\n\n## ReplicaSetController\n\n```go\nfunc startReplicaSetController(ctx ControllerContext) (http.Handler, bool, error) {\n\tif !ctx.AvailableResources[schema.GroupVersionResource{Group: \"apps\", Version: \"v1\", Resource: \"replicasets\"}] {\n\t\treturn nil, false, nil\n\t}\n  \n  // 用goroutine异步运行，包含了 ReplicaSet和Pod 的两个Informer\n  // 这一点很好理解：我们是要控制ReplicaSet声明的数量和运行的Pod数量一致，需要同时观察者两种资源\n\tgo replicaset.NewReplicaSetController(\n\t\tctx.InformerFactory.Apps().V1().ReplicaSets(),\n\t\tctx.InformerFactory.Core().V1().Pods(),\n\t\tctx.ClientBuilder.ClientOrDie(\"replicaset-controller\"),\n\t\treplicaset.BurstReplicas,\n\t).Run(int(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)\n\treturn nil, true, nil\n}\n\n// 运行函数\nfunc (rsc *ReplicaSetController) Run(workers int, stopCh <-chan struct{}) {\n\tdefer utilruntime.HandleCrash()\n\tdefer rsc.queue.ShutDown()\n\n\tcontrollerName := strings.ToLower(rsc.Kind)\n\tklog.Infof(\"Starting %v controller\", controllerName)\n\tdefer klog.Infof(\"Shutting down %v controller\", controllerName)\n\n\tif !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) {\n\t\treturn\n\t}\n\n\tfor i := 0; i < workers; i++ {\n    // 工作的函数\n\t\tgo wait.Until(rsc.worker, time.Second, stopCh)\n\t}\n\n\t<-stopCh\n}\n\nfunc (rsc *ReplicaSetController) worker() {\n  // 继续查找实现\n\tfor rsc.processNextWorkItem() {\n\t}\n}\n\nfunc (rsc *ReplicaSetController) processNextWorkItem() bool {\n  // 这里也有个queue的概念，可以类比kube-scheduler中的实现\n  // 不同的是，这里的queue是 workqueue.RateLimitingInterface ，也就是限制速率的，具体实现今天不细看\n  \n  // 获取元素\n\tkey, quit := rsc.queue.Get()\n\tif quit {\n\t\treturn false\n\t}\n\tdefer rsc.queue.Done(key)\n\n  // 处理对应的元素\n\terr := rsc.syncHandler(key.(string))\n\tif err == nil {\n\t\trsc.queue.Forget(key)\n\t\treturn true\n\t}\n\n\tutilruntime.HandleError(fmt.Errorf(\"sync %q failed with %v\", key, err))\n\trsc.queue.AddRateLimited(key)\n\n\treturn true\n}\n\n// 再回过头，去查看syncHandler的具体实现\nfunc NewBaseController(rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas int,\n\tgvk schema.GroupVersionKind, metricOwnerName, queueName string, podControl controller.PodControlInterface) *ReplicaSetController {\n\t\n\trsc.syncHandler = rsc.syncReplicaSet\n\n\treturn rsc\n}\n```\n\n\n\n## syncReplicaSet\n\n```go\nfunc (rsc *ReplicaSetController) syncReplicaSet(key string) error {\n\tstartTime := time.Now()\n\tdefer func() {\n\t\tklog.V(4).Infof(\"Finished syncing %v %q (%v)\", rsc.Kind, key, time.Since(startTime))\n\t}()\n  \n\t// 从key中拆分出 namespace 和 name\n\tnamespace, name, err := cache.SplitMetaNamespaceKey(key)\n\tif err != nil {\n\t\treturn err\n\t}\n  \n  // 根据name，从 Lister 获取对应的 ReplicaSets 信息\n\trs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)\n\tif errors.IsNotFound(err) {\n\t\tklog.V(4).Infof(\"%v %v has been deleted\", rsc.Kind, key)\n\t\trsc.expectations.DeleteExpectations(key)\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trsNeedsSync := rsc.expectations.SatisfiedExpectations(key)\n  // 获取 selector (k8s 是根据selector中的label来匹配 ReplicaSets 和 Pod 的)\n\tselector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)\n\tif err != nil {\n\t\tutilruntime.HandleError(fmt.Errorf(\"error converting pod selector to selector: %v\", err))\n\t\treturn nil\n\t}\n\n\t// 根据namespace和labels获取所有的pod\n\tallPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n  // 过滤无效的pod\n\tfilteredPods := controller.FilterActivePods(allPods)\n\n\t// 根据selector再过滤pod\n\tfilteredPods, err = rsc.claimPods(rs, selector, filteredPods)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar manageReplicasErr error\n\tif rsNeedsSync && rs.DeletionTimestamp == nil {\n    // 管理 ReplicaSet，下面详细分析\n\t\tmanageReplicasErr = rsc.manageReplicas(filteredPods, rs)\n\t}\n\trs = rs.DeepCopy()\n\tnewStatus := calculateStatus(rs, filteredPods, manageReplicasErr)\n\n\t// 更新状态\n\tupdatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif manageReplicasErr == nil && updatedRS.Spec.MinReadySeconds > 0 &&\n\t\tupdatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &&\n\t\tupdatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) {\n\t\trsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)\n\t}\n\treturn manageReplicasErr\n}\n\n// 我们再一起看看，当Pod数量和ReplicaSet中声明的不同时，是怎么工作的\nfunc (rsc *ReplicaSetController) manageReplicas(filteredPods []*v1.Pod, rs *apps.ReplicaSet) error {\n\t// diff = 当前pod数 - 期望pod数\n  diff := len(filteredPods) - int(*(rs.Spec.Replicas))\n\trsKey, err := controller.KeyFunc(rs)\n\tif err != nil {\n\t\tutilruntime.HandleError(fmt.Errorf(\"couldn't get key for %v %#v: %v\", rsc.Kind, rs, err))\n\t\treturn nil\n\t}\n  \n  // diff小于0，表示需要扩容，即新增Pod\n\tif diff < 0 {\n\t\t\n    // 具体的实现暂时不细看\n    \n  // diff 大于0，即需要缩容\n\t} else if diff > 0 {\n\t\t\n\t}\n\n\treturn nil\n}\n```\n\n\n\n## Summary\n\nkube-controller-manager 的核心思想是： 根据`期望状态`和`当前状态`，管理Kubernetes中的资源。\n\n以ReplicaSet为例，它对比了`定义声明的Pod数`和`当前集群中满足条件的Pod数`，进行相对应的扩缩容。","source":"_posts/k8s-012.md","raw":"---\ntitle: 【K8s源码品读】012：Phase 1 - kube-controller-manager - 了解控制管理中心\ndate: 2021-02-18 16:55:57\ntags:\n---\n\n## 聚焦目标\n\n理解 kube-controller-manager 的运行机制\n\n\n\n## 目录\n\n1. [运行的主函数](#Run)\n2. [控制器的启动函数](#StartControllers)\n3. [引入概念ReplicaSet](#ReplicaSet)\n4. [查看ReplicaSetController](#ReplicaSetController)\n5. [ReplicaSet的核心实现函数](#syncReplicaSet)\n6. [总结](#Summary)\n\n\n\n## Run\n\n我们找到了对应的主函数，看看其中的内容\n\n```go\nfunc Run(c *config.CompletedConfig, stopCh <-chan struct{}) error {\n\t// configz 模块，在kube-scheduler分析中已经了解\n\tif cfgz, err := configz.New(ConfigzName); err == nil {\n\t\tcfgz.Set(c.ComponentConfig)\n\t} else {\n\t\tklog.Errorf(\"unable to register configz: %v\", err)\n\t}\n\n\t// 健康监测与http服务，跳过\n\tvar checks []healthz.HealthChecker\n\tvar unsecuredMux *mux.PathRecorderMux\n\n\trun := func(ctx context.Context) {\n\t\trootClientBuilder := controller.SimpleControllerClientBuilder{\n\t\t\tClientConfig: c.Kubeconfig,\n\t\t}\n   \n    // client认证相关\n\t\tvar clientBuilder controller.ControllerClientBuilder\n\t\t\n    // 创建controller的上下文context\n\t\tcontrollerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())\n\t\tif err != nil {\n\t\t\tklog.Fatalf(\"error building controller context: %v\", err)\n\t\t}\n\t\tsaTokenControllerInitFunc := serviceAccountTokenControllerStarter{rootClientBuilder: rootClientBuilder}.startServiceAccountTokenController\n\n\t\tif err := StartControllers(controllerContext, saTokenControllerInitFunc, NewControllerInitializers(controllerContext.LoopMode), unsecuredMux); err != nil {\n\t\t\tklog.Fatalf(\"error starting controllers: %v\", err)\n\t\t}\n\n    // 这里的 InformerFactory 和我们在kube-scheduler中看的 SharedInformerFactory 基本一致\n\t\tcontrollerContext.InformerFactory.Start(controllerContext.Stop)\n\t\tcontrollerContext.ObjectOrMetadataInformerFactory.Start(controllerContext.Stop)\n\t\tclose(controllerContext.InformersStarted)\n\n\t\tselect {}\n\t}\n\n  // 是否进行选举\n\tif !c.ComponentConfig.Generic.LeaderElection.LeaderElect {\n\t\trun(context.TODO())\n\t\tpanic(\"unreachable\")\n\t}\n\n  // 拼接出一个全局唯一的id\n\tid, err := os.Hostname()\n\tif err != nil {\n\t\treturn err\n\t}\n\tid = id + \"_\" + string(uuid.NewUUID())\n\n\trl, err := resourcelock.New(c.ComponentConfig.Generic.LeaderElection.ResourceLock,\n\t\tc.ComponentConfig.Generic.LeaderElection.ResourceNamespace,\n\t\tc.ComponentConfig.Generic.LeaderElection.ResourceName,\n\t\tc.LeaderElectionClient.CoreV1(),\n\t\tc.LeaderElectionClient.CoordinationV1(),\n\t\tresourcelock.ResourceLockConfig{\n\t\t\tIdentity:      id,\n\t\t\tEventRecorder: c.EventRecorder,\n\t\t})\n\tif err != nil {\n\t\tklog.Fatalf(\"error creating lock: %v\", err)\n\t}\n\n  // 正常情况下都是阻塞在RunOrDie这个函数中，不停地进行选举相关的工作\n\tleaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig{\n\t\tLock:          rl,\n\t\tLeaseDuration: c.ComponentConfig.Generic.LeaderElection.LeaseDuration.Duration,\n\t\tRenewDeadline: c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration,\n\t\tRetryPeriod:   c.ComponentConfig.Generic.LeaderElection.RetryPeriod.Duration,\n\t\tCallbacks: leaderelection.LeaderCallbacks{\n      // 开始成为Leader的时候，调用run函数\n\t\t\tOnStartedLeading: run,\n\t\t\tOnStoppedLeading: func() {\n\t\t\t\tklog.Fatalf(\"leaderelection lost\")\n\t\t\t},\n\t\t},\n\t\tWatchDog: electionChecker,\n\t\tName:     \"kube-controller-manager\",\n\t})\n\tpanic(\"unreachable\")\n}\n```\n\n\n\n## StartControllers\n\n```go\nfunc StartControllers(ctx ControllerContext, startSATokenController InitFunc, controllers map[string]InitFunc, unsecuredMux *mux.PathRecorderMux) error {\n\t// 关键性的循环，启动每个controllers，key为控制器名字，value为初始化函数\n\tfor controllerName, initFn := range controllers {\n    // 是否允许启动\n\t\tif !ctx.IsControllerEnabled(controllerName) {\n\t\t\tklog.Warningf(\"%q is disabled\", controllerName)\n\t\t\tcontinue\n\t\t}\n\t\ttime.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))\n\t\tklog.V(1).Infof(\"Starting %q\", controllerName)\n    // 调用init函数进行启动\n\t\tdebugHandler, started, err := initFn(ctx)\n\t\tif err != nil {\n\t\t\tklog.Errorf(\"Error starting %q\", controllerName)\n\t\t\treturn err\n\t\t}\n\t\tif !started {\n\t\t\tklog.Warningf(\"Skipping %q\", controllerName)\n\t\t\tcontinue\n\t\t}\n    // 注册对应controller到debug的url中\n\t\tif debugHandler != nil && unsecuredMux != nil {\n\t\t\tbasePath := \"/debug/controllers/\" + controllerName\n\t\t\tunsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))\n\t\t\tunsecuredMux.UnlistedHandlePrefix(basePath+\"/\", http.StripPrefix(basePath, debugHandler))\n\t\t}\n\t\tklog.Infof(\"Started %q\", controllerName)\n\t}\n\n\treturn nil\n}\n\n// 我们再去传入controller的函数去看看，对应的controller有哪些，这里有我们很多常见的概念，今天不一一细讲\nfunc NewControllerInitializers(loopMode ControllerLoopMode) map[string]InitFunc {\n\tcontrollers := map[string]InitFunc{}\n\tcontrollers[\"endpoint\"] = startEndpointController\n\tcontrollers[\"endpointslice\"] = startEndpointSliceController\n\tcontrollers[\"endpointslicemirroring\"] = startEndpointSliceMirroringController\n\tcontrollers[\"replicationcontroller\"] = startReplicationController\n\tcontrollers[\"podgc\"] = startPodGCController\n\tcontrollers[\"resourcequota\"] = startResourceQuotaController\n\tcontrollers[\"namespace\"] = startNamespaceController\n\tcontrollers[\"serviceaccount\"] = startServiceAccountController\n\tcontrollers[\"garbagecollector\"] = startGarbageCollectorController\n\tcontrollers[\"daemonset\"] = startDaemonSetController\n\tcontrollers[\"job\"] = startJobController\n\tcontrollers[\"deployment\"] = startDeploymentController\n\tcontrollers[\"replicaset\"] = startReplicaSetController\n\tcontrollers[\"horizontalpodautoscaling\"] = startHPAController\n\tcontrollers[\"disruption\"] = startDisruptionController\n\tcontrollers[\"statefulset\"] = startStatefulSetController\n\tcontrollers[\"cronjob\"] = startCronJobController\n\tcontrollers[\"csrsigning\"] = startCSRSigningController\n\tcontrollers[\"csrapproving\"] = startCSRApprovingController\n\tcontrollers[\"csrcleaner\"] = startCSRCleanerController\n\tcontrollers[\"ttl\"] = startTTLController\n\tcontrollers[\"bootstrapsigner\"] = startBootstrapSignerController\n\tcontrollers[\"tokencleaner\"] = startTokenCleanerController\n\tcontrollers[\"nodeipam\"] = startNodeIpamController\n\tcontrollers[\"nodelifecycle\"] = startNodeLifecycleController\n\tif loopMode == IncludeCloudLoops {\n\t\tcontrollers[\"service\"] = startServiceController\n\t\tcontrollers[\"route\"] = startRouteController\n\t\tcontrollers[\"cloud-node-lifecycle\"] = startCloudNodeLifecycleController\n\t}\n\tcontrollers[\"persistentvolume-binder\"] = startPersistentVolumeBinderController\n\tcontrollers[\"attachdetach\"] = startAttachDetachController\n\tcontrollers[\"persistentvolume-expander\"] = startVolumeExpandController\n\tcontrollers[\"clusterrole-aggregation\"] = startClusterRoleAggregrationController\n\tcontrollers[\"pvc-protection\"] = startPVCProtectionController\n\tcontrollers[\"pv-protection\"] = startPVProtectionController\n\tcontrollers[\"ttl-after-finished\"] = startTTLAfterFinishedController\n\tcontrollers[\"root-ca-cert-publisher\"] = startRootCACertPublisher\n\tcontrollers[\"ephemeral-volume\"] = startEphemeralVolumeController\n\n\treturn controllers\n}\n```\n\n\n\n## ReplicaSet\n\n由于我们的示例是创建一个nginx的pod，涉及到kube-controller-manager的内容很少。\n\n但是，为了加深大家对 kube-controller-manager 的认识，我们引入一个新的概念 - ReplicaSet，下面是官方说明：\n\n> A ReplicaSet's purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.\n\n> ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。\n\n简单来说，ReplicaSet 就是用来生成指定个数的Pod。\n\n\n\n## ReplicaSetController\n\n```go\nfunc startReplicaSetController(ctx ControllerContext) (http.Handler, bool, error) {\n\tif !ctx.AvailableResources[schema.GroupVersionResource{Group: \"apps\", Version: \"v1\", Resource: \"replicasets\"}] {\n\t\treturn nil, false, nil\n\t}\n  \n  // 用goroutine异步运行，包含了 ReplicaSet和Pod 的两个Informer\n  // 这一点很好理解：我们是要控制ReplicaSet声明的数量和运行的Pod数量一致，需要同时观察者两种资源\n\tgo replicaset.NewReplicaSetController(\n\t\tctx.InformerFactory.Apps().V1().ReplicaSets(),\n\t\tctx.InformerFactory.Core().V1().Pods(),\n\t\tctx.ClientBuilder.ClientOrDie(\"replicaset-controller\"),\n\t\treplicaset.BurstReplicas,\n\t).Run(int(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)\n\treturn nil, true, nil\n}\n\n// 运行函数\nfunc (rsc *ReplicaSetController) Run(workers int, stopCh <-chan struct{}) {\n\tdefer utilruntime.HandleCrash()\n\tdefer rsc.queue.ShutDown()\n\n\tcontrollerName := strings.ToLower(rsc.Kind)\n\tklog.Infof(\"Starting %v controller\", controllerName)\n\tdefer klog.Infof(\"Shutting down %v controller\", controllerName)\n\n\tif !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) {\n\t\treturn\n\t}\n\n\tfor i := 0; i < workers; i++ {\n    // 工作的函数\n\t\tgo wait.Until(rsc.worker, time.Second, stopCh)\n\t}\n\n\t<-stopCh\n}\n\nfunc (rsc *ReplicaSetController) worker() {\n  // 继续查找实现\n\tfor rsc.processNextWorkItem() {\n\t}\n}\n\nfunc (rsc *ReplicaSetController) processNextWorkItem() bool {\n  // 这里也有个queue的概念，可以类比kube-scheduler中的实现\n  // 不同的是，这里的queue是 workqueue.RateLimitingInterface ，也就是限制速率的，具体实现今天不细看\n  \n  // 获取元素\n\tkey, quit := rsc.queue.Get()\n\tif quit {\n\t\treturn false\n\t}\n\tdefer rsc.queue.Done(key)\n\n  // 处理对应的元素\n\terr := rsc.syncHandler(key.(string))\n\tif err == nil {\n\t\trsc.queue.Forget(key)\n\t\treturn true\n\t}\n\n\tutilruntime.HandleError(fmt.Errorf(\"sync %q failed with %v\", key, err))\n\trsc.queue.AddRateLimited(key)\n\n\treturn true\n}\n\n// 再回过头，去查看syncHandler的具体实现\nfunc NewBaseController(rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas int,\n\tgvk schema.GroupVersionKind, metricOwnerName, queueName string, podControl controller.PodControlInterface) *ReplicaSetController {\n\t\n\trsc.syncHandler = rsc.syncReplicaSet\n\n\treturn rsc\n}\n```\n\n\n\n## syncReplicaSet\n\n```go\nfunc (rsc *ReplicaSetController) syncReplicaSet(key string) error {\n\tstartTime := time.Now()\n\tdefer func() {\n\t\tklog.V(4).Infof(\"Finished syncing %v %q (%v)\", rsc.Kind, key, time.Since(startTime))\n\t}()\n  \n\t// 从key中拆分出 namespace 和 name\n\tnamespace, name, err := cache.SplitMetaNamespaceKey(key)\n\tif err != nil {\n\t\treturn err\n\t}\n  \n  // 根据name，从 Lister 获取对应的 ReplicaSets 信息\n\trs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)\n\tif errors.IsNotFound(err) {\n\t\tklog.V(4).Infof(\"%v %v has been deleted\", rsc.Kind, key)\n\t\trsc.expectations.DeleteExpectations(key)\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trsNeedsSync := rsc.expectations.SatisfiedExpectations(key)\n  // 获取 selector (k8s 是根据selector中的label来匹配 ReplicaSets 和 Pod 的)\n\tselector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)\n\tif err != nil {\n\t\tutilruntime.HandleError(fmt.Errorf(\"error converting pod selector to selector: %v\", err))\n\t\treturn nil\n\t}\n\n\t// 根据namespace和labels获取所有的pod\n\tallPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n  // 过滤无效的pod\n\tfilteredPods := controller.FilterActivePods(allPods)\n\n\t// 根据selector再过滤pod\n\tfilteredPods, err = rsc.claimPods(rs, selector, filteredPods)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar manageReplicasErr error\n\tif rsNeedsSync && rs.DeletionTimestamp == nil {\n    // 管理 ReplicaSet，下面详细分析\n\t\tmanageReplicasErr = rsc.manageReplicas(filteredPods, rs)\n\t}\n\trs = rs.DeepCopy()\n\tnewStatus := calculateStatus(rs, filteredPods, manageReplicasErr)\n\n\t// 更新状态\n\tupdatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif manageReplicasErr == nil && updatedRS.Spec.MinReadySeconds > 0 &&\n\t\tupdatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &&\n\t\tupdatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) {\n\t\trsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)\n\t}\n\treturn manageReplicasErr\n}\n\n// 我们再一起看看，当Pod数量和ReplicaSet中声明的不同时，是怎么工作的\nfunc (rsc *ReplicaSetController) manageReplicas(filteredPods []*v1.Pod, rs *apps.ReplicaSet) error {\n\t// diff = 当前pod数 - 期望pod数\n  diff := len(filteredPods) - int(*(rs.Spec.Replicas))\n\trsKey, err := controller.KeyFunc(rs)\n\tif err != nil {\n\t\tutilruntime.HandleError(fmt.Errorf(\"couldn't get key for %v %#v: %v\", rsc.Kind, rs, err))\n\t\treturn nil\n\t}\n  \n  // diff小于0，表示需要扩容，即新增Pod\n\tif diff < 0 {\n\t\t\n    // 具体的实现暂时不细看\n    \n  // diff 大于0，即需要缩容\n\t} else if diff > 0 {\n\t\t\n\t}\n\n\treturn nil\n}\n```\n\n\n\n## Summary\n\nkube-controller-manager 的核心思想是： 根据`期望状态`和`当前状态`，管理Kubernetes中的资源。\n\n以ReplicaSet为例，它对比了`定义声明的Pod数`和`当前集群中满足条件的Pod数`，进行相对应的扩缩容。","slug":"k8s-012","published":1,"updated":"2021-02-18T09:00:51.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklaograq000ba4qp74lgbfgp","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解 kube-controller-manager 的运行机制</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#Run\">运行的主函数</a></li>\n<li><a href=\"#StartControllers\">控制器的启动函数</a></li>\n<li><a href=\"#ReplicaSet\">引入概念ReplicaSet</a></li>\n<li><a href=\"#ReplicaSetController\">查看ReplicaSetController</a></li>\n<li><a href=\"#syncReplicaSet\">ReplicaSet的核心实现函数</a></li>\n<li><a href=\"#Summary\">总结</a></li>\n</ol>\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><p>我们找到了对应的主函数，看看其中的内容</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Run</span><span class=\"params\">(c *config.CompletedConfig, stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// configz 模块，在kube-scheduler分析中已经了解</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cfgz, err := configz.New(ConfigzName); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tcfgz.Set(c.ComponentConfig)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tklog.Errorf(<span class=\"string\">&quot;unable to register configz: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 健康监测与http服务，跳过</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> checks []healthz.HealthChecker</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> unsecuredMux *mux.PathRecorderMux</span><br><span class=\"line\"></span><br><span class=\"line\">\trun := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">\t\trootClientBuilder := controller.SimpleControllerClientBuilder&#123;</span><br><span class=\"line\">\t\t\tClientConfig: c.Kubeconfig,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// client认证相关</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> clientBuilder controller.ControllerClientBuilder</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    <span class=\"comment\">// 创建controller的上下文context</span></span><br><span class=\"line\">\t\tcontrollerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tklog.Fatalf(<span class=\"string\">&quot;error building controller context: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsaTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := StartControllers(controllerContext, saTokenControllerInitFunc, NewControllerInitializers(controllerContext.LoopMode), unsecuredMux); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tklog.Fatalf(<span class=\"string\">&quot;error starting controllers: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里的 InformerFactory 和我们在kube-scheduler中看的 SharedInformerFactory 基本一致</span></span><br><span class=\"line\">\t\tcontrollerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class=\"line\">\t\tcontrollerContext.ObjectOrMetadataInformerFactory.Start(controllerContext.Stop)</span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(controllerContext.InformersStarted)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是否进行选举</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !c.ComponentConfig.Generic.LeaderElection.LeaderElect &#123;</span><br><span class=\"line\">\t\trun(context.TODO())</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;unreachable&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 拼接出一个全局唯一的id</span></span><br><span class=\"line\">\tid, err := os.Hostname()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tid = id + <span class=\"string\">&quot;_&quot;</span> + <span class=\"keyword\">string</span>(uuid.NewUUID())</span><br><span class=\"line\"></span><br><span class=\"line\">\trl, err := resourcelock.New(c.ComponentConfig.Generic.LeaderElection.ResourceLock,</span><br><span class=\"line\">\t\tc.ComponentConfig.Generic.LeaderElection.ResourceNamespace,</span><br><span class=\"line\">\t\tc.ComponentConfig.Generic.LeaderElection.ResourceName,</span><br><span class=\"line\">\t\tc.LeaderElectionClient.CoreV1(),</span><br><span class=\"line\">\t\tc.LeaderElectionClient.CoordinationV1(),</span><br><span class=\"line\">\t\tresourcelock.ResourceLockConfig&#123;</span><br><span class=\"line\">\t\t\tIdentity:      id,</span><br><span class=\"line\">\t\t\tEventRecorder: c.EventRecorder,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Fatalf(<span class=\"string\">&quot;error creating lock: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 正常情况下都是阻塞在RunOrDie这个函数中，不停地进行选举相关的工作</span></span><br><span class=\"line\">\tleaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig&#123;</span><br><span class=\"line\">\t\tLock:          rl,</span><br><span class=\"line\">\t\tLeaseDuration: c.ComponentConfig.Generic.LeaderElection.LeaseDuration.Duration,</span><br><span class=\"line\">\t\tRenewDeadline: c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration,</span><br><span class=\"line\">\t\tRetryPeriod:   c.ComponentConfig.Generic.LeaderElection.RetryPeriod.Duration,</span><br><span class=\"line\">\t\tCallbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 开始成为Leader的时候，调用run函数</span></span><br><span class=\"line\">\t\t\tOnStartedLeading: run,</span><br><span class=\"line\">\t\t\tOnStoppedLeading: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\tklog.Fatalf(<span class=\"string\">&quot;leaderelection lost&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tWatchDog: electionChecker,</span><br><span class=\"line\">\t\tName:     <span class=\"string\">&quot;kube-controller-manager&quot;</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;unreachable&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"StartControllers\"><a href=\"#StartControllers\" class=\"headerlink\" title=\"StartControllers\"></a>StartControllers</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">StartControllers</span><span class=\"params\">(ctx ControllerContext, startSATokenController InitFunc, controllers <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]InitFunc, unsecuredMux *mux.PathRecorderMux)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关键性的循环，启动每个controllers，key为控制器名字，value为初始化函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> controllerName, initFn := <span class=\"keyword\">range</span> controllers &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否允许启动</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !ctx.IsControllerEnabled(controllerName) &#123;</span><br><span class=\"line\">\t\t\tklog.Warningf(<span class=\"string\">&quot;%q is disabled&quot;</span>, controllerName)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttime.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">1</span>).Infof(<span class=\"string\">&quot;Starting %q&quot;</span>, controllerName)</span><br><span class=\"line\">    <span class=\"comment\">// 调用init函数进行启动</span></span><br><span class=\"line\">\t\tdebugHandler, started, err := initFn(ctx)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">&quot;Error starting %q&quot;</span>, controllerName)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !started &#123;</span><br><span class=\"line\">\t\t\tklog.Warningf(<span class=\"string\">&quot;Skipping %q&quot;</span>, controllerName)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注册对应controller到debug的url中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> debugHandler != <span class=\"literal\">nil</span> &amp;&amp; unsecuredMux != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tbasePath := <span class=\"string\">&quot;/debug/controllers/&quot;</span> + controllerName</span><br><span class=\"line\">\t\t\tunsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))</span><br><span class=\"line\">\t\t\tunsecuredMux.UnlistedHandlePrefix(basePath+<span class=\"string\">&quot;/&quot;</span>, http.StripPrefix(basePath, debugHandler))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.Infof(<span class=\"string\">&quot;Started %q&quot;</span>, controllerName)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们再去传入controller的函数去看看，对应的controller有哪些，这里有我们很多常见的概念，今天不一一细讲</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewControllerInitializers</span><span class=\"params\">(loopMode ControllerLoopMode)</span> <span class=\"title\">map</span>[<span class=\"title\">string</span>]<span class=\"title\">InitFunc</span></span> &#123;</span><br><span class=\"line\">\tcontrollers := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]InitFunc&#123;&#125;</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;endpoint&quot;</span>] = startEndpointController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;endpointslice&quot;</span>] = startEndpointSliceController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;endpointslicemirroring&quot;</span>] = startEndpointSliceMirroringController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;replicationcontroller&quot;</span>] = startReplicationController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;podgc&quot;</span>] = startPodGCController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;resourcequota&quot;</span>] = startResourceQuotaController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;namespace&quot;</span>] = startNamespaceController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;serviceaccount&quot;</span>] = startServiceAccountController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;garbagecollector&quot;</span>] = startGarbageCollectorController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;daemonset&quot;</span>] = startDaemonSetController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;job&quot;</span>] = startJobController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;deployment&quot;</span>] = startDeploymentController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;replicaset&quot;</span>] = startReplicaSetController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;horizontalpodautoscaling&quot;</span>] = startHPAController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;disruption&quot;</span>] = startDisruptionController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;statefulset&quot;</span>] = startStatefulSetController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;cronjob&quot;</span>] = startCronJobController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;csrsigning&quot;</span>] = startCSRSigningController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;csrapproving&quot;</span>] = startCSRApprovingController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;csrcleaner&quot;</span>] = startCSRCleanerController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;ttl&quot;</span>] = startTTLController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;bootstrapsigner&quot;</span>] = startBootstrapSignerController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;tokencleaner&quot;</span>] = startTokenCleanerController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;nodeipam&quot;</span>] = startNodeIpamController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;nodelifecycle&quot;</span>] = startNodeLifecycleController</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class=\"line\">\t\tcontrollers[<span class=\"string\">&quot;service&quot;</span>] = startServiceController</span><br><span class=\"line\">\t\tcontrollers[<span class=\"string\">&quot;route&quot;</span>] = startRouteController</span><br><span class=\"line\">\t\tcontrollers[<span class=\"string\">&quot;cloud-node-lifecycle&quot;</span>] = startCloudNodeLifecycleController</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;persistentvolume-binder&quot;</span>] = startPersistentVolumeBinderController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;attachdetach&quot;</span>] = startAttachDetachController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;persistentvolume-expander&quot;</span>] = startVolumeExpandController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;clusterrole-aggregation&quot;</span>] = startClusterRoleAggregrationController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;pvc-protection&quot;</span>] = startPVCProtectionController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;pv-protection&quot;</span>] = startPVProtectionController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;ttl-after-finished&quot;</span>] = startTTLAfterFinishedController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;root-ca-cert-publisher&quot;</span>] = startRootCACertPublisher</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;ephemeral-volume&quot;</span>] = startEphemeralVolumeController</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> controllers</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ReplicaSet\"><a href=\"#ReplicaSet\" class=\"headerlink\" title=\"ReplicaSet\"></a>ReplicaSet</h2><p>由于我们的示例是创建一个nginx的pod，涉及到kube-controller-manager的内容很少。</p>\n<p>但是，为了加深大家对 kube-controller-manager 的认识，我们引入一个新的概念 - ReplicaSet，下面是官方说明：</p>\n<blockquote>\n<p>A ReplicaSet’s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.</p>\n</blockquote>\n<blockquote>\n<p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p>\n</blockquote>\n<p>简单来说，ReplicaSet 就是用来生成指定个数的Pod。</p>\n<h2 id=\"ReplicaSetController\"><a href=\"#ReplicaSetController\" class=\"headerlink\" title=\"ReplicaSetController\"></a>ReplicaSetController</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startReplicaSetController</span><span class=\"params\">(ctx ControllerContext)</span> <span class=\"params\">(http.Handler, <span class=\"keyword\">bool</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ctx.AvailableResources[schema.GroupVersionResource&#123;Group: <span class=\"string\">&quot;apps&quot;</span>, Version: <span class=\"string\">&quot;v1&quot;</span>, Resource: <span class=\"string\">&quot;replicasets&quot;</span>&#125;] &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">false</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 用goroutine异步运行，包含了 ReplicaSet和Pod 的两个Informer</span></span><br><span class=\"line\">  <span class=\"comment\">// 这一点很好理解：我们是要控制ReplicaSet声明的数量和运行的Pod数量一致，需要同时观察者两种资源</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> replicaset.NewReplicaSetController(</span><br><span class=\"line\">\t\tctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class=\"line\">\t\tctx.InformerFactory.Core().V1().Pods(),</span><br><span class=\"line\">\t\tctx.ClientBuilder.ClientOrDie(<span class=\"string\">&quot;replicaset-controller&quot;</span>),</span><br><span class=\"line\">\t\treplicaset.BurstReplicas,</span><br><span class=\"line\">\t).Run(<span class=\"keyword\">int</span>(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">true</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">Run</span><span class=\"params\">(workers <span class=\"keyword\">int</span>, stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> utilruntime.HandleCrash()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> rsc.queue.ShutDown()</span><br><span class=\"line\"></span><br><span class=\"line\">\tcontrollerName := strings.ToLower(rsc.Kind)</span><br><span class=\"line\">\tklog.Infof(<span class=\"string\">&quot;Starting %v controller&quot;</span>, controllerName)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> klog.Infof(<span class=\"string\">&quot;Shutting down %v controller&quot;</span>, controllerName)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; workers; i++ &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 工作的函数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> wait.Until(rsc.worker, time.Second, stopCh)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-stopCh</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">worker</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 继续查找实现</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> rsc.processNextWorkItem() &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">processNextWorkItem</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里也有个queue的概念，可以类比kube-scheduler中的实现</span></span><br><span class=\"line\">  <span class=\"comment\">// 不同的是，这里的queue是 workqueue.RateLimitingInterface ，也就是限制速率的，具体实现今天不细看</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 获取元素</span></span><br><span class=\"line\">\tkey, quit := rsc.queue.Get()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> quit &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> rsc.queue.Done(key)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 处理对应的元素</span></span><br><span class=\"line\">\terr := rsc.syncHandler(key.(<span class=\"keyword\">string</span>))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\trsc.queue.Forget(key)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;sync %q failed with %v&quot;</span>, key, err))</span><br><span class=\"line\">\trsc.queue.AddRateLimited(key)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再回过头，去查看syncHandler的具体实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBaseController</span><span class=\"params\">(rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas <span class=\"keyword\">int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tgvk schema.GroupVersionKind, metricOwnerName, queueName <span class=\"keyword\">string</span>, podControl controller.PodControlInterface)</span> *<span class=\"title\">ReplicaSetController</span></span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trsc.syncHandler = rsc.syncReplicaSet</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rsc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"syncReplicaSet\"><a href=\"#syncReplicaSet\" class=\"headerlink\" title=\"syncReplicaSet\"></a>syncReplicaSet</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">syncReplicaSet</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tstartTime := time.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;Finished syncing %v %q (%v)&quot;</span>, rsc.Kind, key, time.Since(startTime))</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// 从key中拆分出 namespace 和 name</span></span><br><span class=\"line\">\tnamespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 根据name，从 Lister 获取对应的 ReplicaSets 信息</span></span><br><span class=\"line\">\trs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> errors.IsNotFound(err) &#123;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;%v %v has been deleted&quot;</span>, rsc.Kind, key)</span><br><span class=\"line\">\t\trsc.expectations.DeleteExpectations(key)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class=\"line\">  <span class=\"comment\">// 获取 selector (k8s 是根据selector中的label来匹配 ReplicaSets 和 Pod 的)</span></span><br><span class=\"line\">\tselector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;error converting pod selector to selector: %v&quot;</span>, err))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 根据namespace和labels获取所有的pod</span></span><br><span class=\"line\">\tallPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// 过滤无效的pod</span></span><br><span class=\"line\">\tfilteredPods := controller.FilterActivePods(allPods)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 根据selector再过滤pod</span></span><br><span class=\"line\">\tfilteredPods, err = rsc.claimPods(rs, selector, filteredPods)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> manageReplicasErr error</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管理 ReplicaSet，下面详细分析</span></span><br><span class=\"line\">\t\tmanageReplicasErr = rsc.manageReplicas(filteredPods, rs)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trs = rs.DeepCopy()</span><br><span class=\"line\">\tnewStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 更新状态</span></span><br><span class=\"line\">\tupdatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> manageReplicasErr == <span class=\"literal\">nil</span> &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t\tupdatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class=\"line\">\t\tupdatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class=\"line\">\t\trsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> manageReplicasErr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们再一起看看，当Pod数量和ReplicaSet中声明的不同时，是怎么工作的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">manageReplicas</span><span class=\"params\">(filteredPods []*v1.Pod, rs *apps.ReplicaSet)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// diff = 当前pod数 - 期望pod数</span></span><br><span class=\"line\">  diff := <span class=\"built_in\">len</span>(filteredPods) - <span class=\"keyword\">int</span>(*(rs.Spec.Replicas))</span><br><span class=\"line\">\trsKey, err := controller.KeyFunc(rs)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;couldn&#x27;t get key for %v %#v: %v&quot;</span>, rsc.Kind, rs, err))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// diff小于0，表示需要扩容，即新增Pod</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> diff &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    <span class=\"comment\">// 具体的实现暂时不细看</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// diff 大于0，即需要缩容</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> diff &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>kube-controller-manager 的核心思想是： 根据<code>期望状态</code>和<code>当前状态</code>，管理Kubernetes中的资源。</p>\n<p>以ReplicaSet为例，它对比了<code>定义声明的Pod数</code>和<code>当前集群中满足条件的Pod数</code>，进行相对应的扩缩容。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解 kube-controller-manager 的运行机制</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#Run\">运行的主函数</a></li>\n<li><a href=\"#StartControllers\">控制器的启动函数</a></li>\n<li><a href=\"#ReplicaSet\">引入概念ReplicaSet</a></li>\n<li><a href=\"#ReplicaSetController\">查看ReplicaSetController</a></li>\n<li><a href=\"#syncReplicaSet\">ReplicaSet的核心实现函数</a></li>\n<li><a href=\"#Summary\">总结</a></li>\n</ol>\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><p>我们找到了对应的主函数，看看其中的内容</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Run</span><span class=\"params\">(c *config.CompletedConfig, stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// configz 模块，在kube-scheduler分析中已经了解</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cfgz, err := configz.New(ConfigzName); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tcfgz.Set(c.ComponentConfig)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tklog.Errorf(<span class=\"string\">&quot;unable to register configz: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 健康监测与http服务，跳过</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> checks []healthz.HealthChecker</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> unsecuredMux *mux.PathRecorderMux</span><br><span class=\"line\"></span><br><span class=\"line\">\trun := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">\t\trootClientBuilder := controller.SimpleControllerClientBuilder&#123;</span><br><span class=\"line\">\t\t\tClientConfig: c.Kubeconfig,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// client认证相关</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> clientBuilder controller.ControllerClientBuilder</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    <span class=\"comment\">// 创建controller的上下文context</span></span><br><span class=\"line\">\t\tcontrollerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tklog.Fatalf(<span class=\"string\">&quot;error building controller context: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsaTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := StartControllers(controllerContext, saTokenControllerInitFunc, NewControllerInitializers(controllerContext.LoopMode), unsecuredMux); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tklog.Fatalf(<span class=\"string\">&quot;error starting controllers: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里的 InformerFactory 和我们在kube-scheduler中看的 SharedInformerFactory 基本一致</span></span><br><span class=\"line\">\t\tcontrollerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class=\"line\">\t\tcontrollerContext.ObjectOrMetadataInformerFactory.Start(controllerContext.Stop)</span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(controllerContext.InformersStarted)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 是否进行选举</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !c.ComponentConfig.Generic.LeaderElection.LeaderElect &#123;</span><br><span class=\"line\">\t\trun(context.TODO())</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;unreachable&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 拼接出一个全局唯一的id</span></span><br><span class=\"line\">\tid, err := os.Hostname()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tid = id + <span class=\"string\">&quot;_&quot;</span> + <span class=\"keyword\">string</span>(uuid.NewUUID())</span><br><span class=\"line\"></span><br><span class=\"line\">\trl, err := resourcelock.New(c.ComponentConfig.Generic.LeaderElection.ResourceLock,</span><br><span class=\"line\">\t\tc.ComponentConfig.Generic.LeaderElection.ResourceNamespace,</span><br><span class=\"line\">\t\tc.ComponentConfig.Generic.LeaderElection.ResourceName,</span><br><span class=\"line\">\t\tc.LeaderElectionClient.CoreV1(),</span><br><span class=\"line\">\t\tc.LeaderElectionClient.CoordinationV1(),</span><br><span class=\"line\">\t\tresourcelock.ResourceLockConfig&#123;</span><br><span class=\"line\">\t\t\tIdentity:      id,</span><br><span class=\"line\">\t\t\tEventRecorder: c.EventRecorder,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Fatalf(<span class=\"string\">&quot;error creating lock: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 正常情况下都是阻塞在RunOrDie这个函数中，不停地进行选举相关的工作</span></span><br><span class=\"line\">\tleaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig&#123;</span><br><span class=\"line\">\t\tLock:          rl,</span><br><span class=\"line\">\t\tLeaseDuration: c.ComponentConfig.Generic.LeaderElection.LeaseDuration.Duration,</span><br><span class=\"line\">\t\tRenewDeadline: c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration,</span><br><span class=\"line\">\t\tRetryPeriod:   c.ComponentConfig.Generic.LeaderElection.RetryPeriod.Duration,</span><br><span class=\"line\">\t\tCallbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 开始成为Leader的时候，调用run函数</span></span><br><span class=\"line\">\t\t\tOnStartedLeading: run,</span><br><span class=\"line\">\t\t\tOnStoppedLeading: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\tklog.Fatalf(<span class=\"string\">&quot;leaderelection lost&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tWatchDog: electionChecker,</span><br><span class=\"line\">\t\tName:     <span class=\"string\">&quot;kube-controller-manager&quot;</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;unreachable&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"StartControllers\"><a href=\"#StartControllers\" class=\"headerlink\" title=\"StartControllers\"></a>StartControllers</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">StartControllers</span><span class=\"params\">(ctx ControllerContext, startSATokenController InitFunc, controllers <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]InitFunc, unsecuredMux *mux.PathRecorderMux)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关键性的循环，启动每个controllers，key为控制器名字，value为初始化函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> controllerName, initFn := <span class=\"keyword\">range</span> controllers &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否允许启动</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !ctx.IsControllerEnabled(controllerName) &#123;</span><br><span class=\"line\">\t\t\tklog.Warningf(<span class=\"string\">&quot;%q is disabled&quot;</span>, controllerName)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttime.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">1</span>).Infof(<span class=\"string\">&quot;Starting %q&quot;</span>, controllerName)</span><br><span class=\"line\">    <span class=\"comment\">// 调用init函数进行启动</span></span><br><span class=\"line\">\t\tdebugHandler, started, err := initFn(ctx)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">&quot;Error starting %q&quot;</span>, controllerName)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !started &#123;</span><br><span class=\"line\">\t\t\tklog.Warningf(<span class=\"string\">&quot;Skipping %q&quot;</span>, controllerName)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注册对应controller到debug的url中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> debugHandler != <span class=\"literal\">nil</span> &amp;&amp; unsecuredMux != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tbasePath := <span class=\"string\">&quot;/debug/controllers/&quot;</span> + controllerName</span><br><span class=\"line\">\t\t\tunsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))</span><br><span class=\"line\">\t\t\tunsecuredMux.UnlistedHandlePrefix(basePath+<span class=\"string\">&quot;/&quot;</span>, http.StripPrefix(basePath, debugHandler))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.Infof(<span class=\"string\">&quot;Started %q&quot;</span>, controllerName)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们再去传入controller的函数去看看，对应的controller有哪些，这里有我们很多常见的概念，今天不一一细讲</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewControllerInitializers</span><span class=\"params\">(loopMode ControllerLoopMode)</span> <span class=\"title\">map</span>[<span class=\"title\">string</span>]<span class=\"title\">InitFunc</span></span> &#123;</span><br><span class=\"line\">\tcontrollers := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]InitFunc&#123;&#125;</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;endpoint&quot;</span>] = startEndpointController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;endpointslice&quot;</span>] = startEndpointSliceController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;endpointslicemirroring&quot;</span>] = startEndpointSliceMirroringController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;replicationcontroller&quot;</span>] = startReplicationController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;podgc&quot;</span>] = startPodGCController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;resourcequota&quot;</span>] = startResourceQuotaController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;namespace&quot;</span>] = startNamespaceController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;serviceaccount&quot;</span>] = startServiceAccountController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;garbagecollector&quot;</span>] = startGarbageCollectorController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;daemonset&quot;</span>] = startDaemonSetController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;job&quot;</span>] = startJobController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;deployment&quot;</span>] = startDeploymentController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;replicaset&quot;</span>] = startReplicaSetController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;horizontalpodautoscaling&quot;</span>] = startHPAController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;disruption&quot;</span>] = startDisruptionController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;statefulset&quot;</span>] = startStatefulSetController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;cronjob&quot;</span>] = startCronJobController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;csrsigning&quot;</span>] = startCSRSigningController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;csrapproving&quot;</span>] = startCSRApprovingController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;csrcleaner&quot;</span>] = startCSRCleanerController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;ttl&quot;</span>] = startTTLController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;bootstrapsigner&quot;</span>] = startBootstrapSignerController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;tokencleaner&quot;</span>] = startTokenCleanerController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;nodeipam&quot;</span>] = startNodeIpamController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;nodelifecycle&quot;</span>] = startNodeLifecycleController</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class=\"line\">\t\tcontrollers[<span class=\"string\">&quot;service&quot;</span>] = startServiceController</span><br><span class=\"line\">\t\tcontrollers[<span class=\"string\">&quot;route&quot;</span>] = startRouteController</span><br><span class=\"line\">\t\tcontrollers[<span class=\"string\">&quot;cloud-node-lifecycle&quot;</span>] = startCloudNodeLifecycleController</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;persistentvolume-binder&quot;</span>] = startPersistentVolumeBinderController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;attachdetach&quot;</span>] = startAttachDetachController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;persistentvolume-expander&quot;</span>] = startVolumeExpandController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;clusterrole-aggregation&quot;</span>] = startClusterRoleAggregrationController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;pvc-protection&quot;</span>] = startPVCProtectionController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;pv-protection&quot;</span>] = startPVProtectionController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;ttl-after-finished&quot;</span>] = startTTLAfterFinishedController</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;root-ca-cert-publisher&quot;</span>] = startRootCACertPublisher</span><br><span class=\"line\">\tcontrollers[<span class=\"string\">&quot;ephemeral-volume&quot;</span>] = startEphemeralVolumeController</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> controllers</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ReplicaSet\"><a href=\"#ReplicaSet\" class=\"headerlink\" title=\"ReplicaSet\"></a>ReplicaSet</h2><p>由于我们的示例是创建一个nginx的pod，涉及到kube-controller-manager的内容很少。</p>\n<p>但是，为了加深大家对 kube-controller-manager 的认识，我们引入一个新的概念 - ReplicaSet，下面是官方说明：</p>\n<blockquote>\n<p>A ReplicaSet’s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.</p>\n</blockquote>\n<blockquote>\n<p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p>\n</blockquote>\n<p>简单来说，ReplicaSet 就是用来生成指定个数的Pod。</p>\n<h2 id=\"ReplicaSetController\"><a href=\"#ReplicaSetController\" class=\"headerlink\" title=\"ReplicaSetController\"></a>ReplicaSetController</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startReplicaSetController</span><span class=\"params\">(ctx ControllerContext)</span> <span class=\"params\">(http.Handler, <span class=\"keyword\">bool</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ctx.AvailableResources[schema.GroupVersionResource&#123;Group: <span class=\"string\">&quot;apps&quot;</span>, Version: <span class=\"string\">&quot;v1&quot;</span>, Resource: <span class=\"string\">&quot;replicasets&quot;</span>&#125;] &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">false</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 用goroutine异步运行，包含了 ReplicaSet和Pod 的两个Informer</span></span><br><span class=\"line\">  <span class=\"comment\">// 这一点很好理解：我们是要控制ReplicaSet声明的数量和运行的Pod数量一致，需要同时观察者两种资源</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> replicaset.NewReplicaSetController(</span><br><span class=\"line\">\t\tctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class=\"line\">\t\tctx.InformerFactory.Core().V1().Pods(),</span><br><span class=\"line\">\t\tctx.ClientBuilder.ClientOrDie(<span class=\"string\">&quot;replicaset-controller&quot;</span>),</span><br><span class=\"line\">\t\treplicaset.BurstReplicas,</span><br><span class=\"line\">\t).Run(<span class=\"keyword\">int</span>(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">true</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">Run</span><span class=\"params\">(workers <span class=\"keyword\">int</span>, stopCh &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> utilruntime.HandleCrash()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> rsc.queue.ShutDown()</span><br><span class=\"line\"></span><br><span class=\"line\">\tcontrollerName := strings.ToLower(rsc.Kind)</span><br><span class=\"line\">\tklog.Infof(<span class=\"string\">&quot;Starting %v controller&quot;</span>, controllerName)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> klog.Infof(<span class=\"string\">&quot;Shutting down %v controller&quot;</span>, controllerName)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; workers; i++ &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 工作的函数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> wait.Until(rsc.worker, time.Second, stopCh)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-stopCh</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">worker</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 继续查找实现</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> rsc.processNextWorkItem() &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">processNextWorkItem</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里也有个queue的概念，可以类比kube-scheduler中的实现</span></span><br><span class=\"line\">  <span class=\"comment\">// 不同的是，这里的queue是 workqueue.RateLimitingInterface ，也就是限制速率的，具体实现今天不细看</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 获取元素</span></span><br><span class=\"line\">\tkey, quit := rsc.queue.Get()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> quit &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> rsc.queue.Done(key)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 处理对应的元素</span></span><br><span class=\"line\">\terr := rsc.syncHandler(key.(<span class=\"keyword\">string</span>))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\trsc.queue.Forget(key)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;sync %q failed with %v&quot;</span>, key, err))</span><br><span class=\"line\">\trsc.queue.AddRateLimited(key)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再回过头，去查看syncHandler的具体实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBaseController</span><span class=\"params\">(rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas <span class=\"keyword\">int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tgvk schema.GroupVersionKind, metricOwnerName, queueName <span class=\"keyword\">string</span>, podControl controller.PodControlInterface)</span> *<span class=\"title\">ReplicaSetController</span></span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trsc.syncHandler = rsc.syncReplicaSet</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rsc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"syncReplicaSet\"><a href=\"#syncReplicaSet\" class=\"headerlink\" title=\"syncReplicaSet\"></a>syncReplicaSet</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">syncReplicaSet</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tstartTime := time.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;Finished syncing %v %q (%v)&quot;</span>, rsc.Kind, key, time.Since(startTime))</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// 从key中拆分出 namespace 和 name</span></span><br><span class=\"line\">\tnamespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 根据name，从 Lister 获取对应的 ReplicaSets 信息</span></span><br><span class=\"line\">\trs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> errors.IsNotFound(err) &#123;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;%v %v has been deleted&quot;</span>, rsc.Kind, key)</span><br><span class=\"line\">\t\trsc.expectations.DeleteExpectations(key)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class=\"line\">  <span class=\"comment\">// 获取 selector (k8s 是根据selector中的label来匹配 ReplicaSets 和 Pod 的)</span></span><br><span class=\"line\">\tselector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;error converting pod selector to selector: %v&quot;</span>, err))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 根据namespace和labels获取所有的pod</span></span><br><span class=\"line\">\tallPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// 过滤无效的pod</span></span><br><span class=\"line\">\tfilteredPods := controller.FilterActivePods(allPods)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 根据selector再过滤pod</span></span><br><span class=\"line\">\tfilteredPods, err = rsc.claimPods(rs, selector, filteredPods)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> manageReplicasErr error</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 管理 ReplicaSet，下面详细分析</span></span><br><span class=\"line\">\t\tmanageReplicasErr = rsc.manageReplicas(filteredPods, rs)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trs = rs.DeepCopy()</span><br><span class=\"line\">\tnewStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 更新状态</span></span><br><span class=\"line\">\tupdatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> manageReplicasErr == <span class=\"literal\">nil</span> &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t\tupdatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class=\"line\">\t\tupdatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class=\"line\">\t\trsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> manageReplicasErr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们再一起看看，当Pod数量和ReplicaSet中声明的不同时，是怎么工作的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rsc *ReplicaSetController)</span> <span class=\"title\">manageReplicas</span><span class=\"params\">(filteredPods []*v1.Pod, rs *apps.ReplicaSet)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// diff = 当前pod数 - 期望pod数</span></span><br><span class=\"line\">  diff := <span class=\"built_in\">len</span>(filteredPods) - <span class=\"keyword\">int</span>(*(rs.Spec.Replicas))</span><br><span class=\"line\">\trsKey, err := controller.KeyFunc(rs)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tutilruntime.HandleError(fmt.Errorf(<span class=\"string\">&quot;couldn&#x27;t get key for %v %#v: %v&quot;</span>, rsc.Kind, rs, err))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// diff小于0，表示需要扩容，即新增Pod</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> diff &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    <span class=\"comment\">// 具体的实现暂时不细看</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// diff 大于0，即需要缩容</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> diff &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>kube-controller-manager 的核心思想是： 根据<code>期望状态</code>和<code>当前状态</code>，管理Kubernetes中的资源。</p>\n<p>以ReplicaSet为例，它对比了<code>定义声明的Pod数</code>和<code>当前集群中满足条件的Pod数</code>，进行相对应的扩缩容。</p>\n"},{"title":"【K8s源码品读】013：Phase 1 - kubelet - 节点上控制容器生命周期的管理者","date":"2021-02-18T08:55:58.000Z","_content":"\n## 聚焦目标\n\n理解 kubelet 的运行机制\n\n\n\n## 目录\n\n1. [运行的主函数](#Run)\n2. [运行kubelet](#RunKubelet)\n3. [核心数据管理Kubelet](#Kubelet)\n4. [同步循环](#syncLoop)\n5. [处理pod的同步工作](#handler)\n6. [总结](#Summary)\n\n\n\n## Run\n\n从主函数找到run函数，代码较长，我精简了一下\n\n```go\nfunc run(ctx context.Context, s *options.KubeletServer, kubeDeps *kubelet.Dependencies, featureGate featuregate.FeatureGate) (err error) {\n\t// 一长串的配置初始化与验证\n\n  // done channel，用来通知运行结束\n\tdone := make(chan struct{})\n\t\n\t// 注册到configz模块\n\terr = initConfigz(&s.KubeletConfiguration)\n\tif err != nil {\n\t\tklog.Errorf(\"unable to register KubeletConfiguration with configz, error: %v\", err)\n\t}\n\n  // 获取节点的相关信息\n\thostName, err := nodeutil.GetHostname(s.HostnameOverride)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnodeName, err := getNodeName(kubeDeps.Cloud, hostName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch {\n  // 独立运行模式\n\tcase standaloneMode:\n\t// 对客户端进行初始化\n\tcase kubeDeps.KubeClient == nil, kubeDeps.EventClient == nil, kubeDeps.HeartbeatClient == nil:\n\t}\n\n  // cgroup 相关初始化\n\tvar cgroupRoots []string\n\tnodeAllocatableRoot := cm.NodeAllocatableRoot(s.CgroupRoot, s.CgroupsPerQOS, s.CgroupDriver)\n\tcgroupRoots = append(cgroupRoots, nodeAllocatableRoot)\n\tkubeletCgroup, err := cm.GetKubeletContainer(s.KubeletCgroups)\n\tif err != nil {\n\t\tklog.Warningf(\"failed to get the kubelet's cgroup: %v.  Kubelet system container metrics may be missing.\", err)\n\t} else if kubeletCgroup != \"\" {\n\t\tcgroupRoots = append(cgroupRoots, kubeletCgroup)\n\t}\n\n\truntimeCgroup, err := cm.GetRuntimeContainer(s.ContainerRuntime, s.RuntimeCgroups)\n\tif err != nil {\n\t\tklog.Warningf(\"failed to get the container runtime's cgroup: %v. Runtime system container metrics may be missing.\", err)\n\t} else if runtimeCgroup != \"\" {\n\t\tcgroupRoots = append(cgroupRoots, runtimeCgroup)\n\t}\n\n\tif s.SystemCgroups != \"\" {\n\t\tcgroupRoots = append(cgroupRoots, s.SystemCgroups)\n\t}\n\n  // 下面一大块都是对 ContainerManager 的初始化\n\tif kubeDeps.ContainerManager == nil {\n\t\tif s.CgroupsPerQOS && s.CgroupRoot == \"\" {\n\t\t\tklog.Info(\"--cgroups-per-qos enabled, but --cgroup-root was not specified.  defaulting to /\")\n\t\t\ts.CgroupRoot = \"/\"\n\t\t}\n    \n\t\t// cpu相关信息\n\t\tvar reservedSystemCPUs cpuset.CPUSet\n\n    // ContainerManager的实例化\n\t\tkubeDeps.ContainerManager, err = cm.NewContainerManager(\n\t\t\tkubeDeps.Mounter,\n\t\t\tkubeDeps.CAdvisorInterface,\n      // Node 相关配置\n\t\t\tcm.NodeConfig{},\n\t\t\ts.FailSwapOn,\n\t\t\tdevicePluginEnabled,\n\t\t\tkubeDeps.Recorder)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// 内存OOM相关\n\toomAdjuster := kubeDeps.OOMAdjuster\n\tif err := oomAdjuster.ApplyOOMScoreAdj(0, int(s.OOMScoreAdj)); err != nil {\n\t\tklog.Warning(err)\n\t}\n\n\t// 预初始化Runtime\n\terr = kubelet.PreInitRuntimeService(&s.KubeletConfiguration,\n\t\tkubeDeps, &s.ContainerRuntimeOptions,\n\t\ts.ContainerRuntime,\n\t\ts.RuntimeCgroups,\n\t\ts.RemoteRuntimeEndpoint,\n\t\ts.RemoteImageEndpoint,\n\t\ts.NonMasqueradeCIDR)\n\tif err != nil {\n\t\treturn err\n\t}\n\n  // 运行Kubelet\n\tif err := RunKubelet(s, kubeDeps, s.RunOnce); err != nil {\n\t\treturn err\n\t}\n\n\t// 通知deamon的systemd\n\tgo daemon.SdNotify(false, \"READY=1\")\n\n  // 阻塞\n\tselect {\n\tcase <-done:\n\t\tbreak\n\tcase <-ctx.Done():\n\t\tbreak\n\t}\n\n\treturn nil\n}\n```\n\n\n\n## RunKubelet\n\n```go\nfunc RunKubelet(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce bool) error {\n\t// 获取节点信息\n  hostname, err := nodeutil.GetHostname(kubeServer.HostnameOverride)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnodeName, err := getNodeName(kubeDeps.Cloud, hostname)\n\tif err != nil {\n\t\treturn err\n\t}\n\thostnameOverridden := len(kubeServer.HostnameOverride) > 0\n\n  // 创建并初始化 kubelet\n\tk, err := createAndInitKubelet()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create kubelet: %v\", err)\n\t}\n\n\tif runOnce {\n\t\tif _, err := k.RunOnce(podCfg.Updates()); err != nil {\n\t\t\treturn fmt.Errorf(\"runonce failed: %v\", err)\n\t\t}\n\t\tklog.Info(\"Started kubelet as runonce\")\n\t} else {\n    // 开始kubelet\n\t\tstartKubelet(k, podCfg, &kubeServer.KubeletConfiguration, kubeDeps, kubeServer.EnableCAdvisorJSONEndpoints, kubeServer.EnableServer)\n\t\tklog.Info(\"Started kubelet\")\n\t}\n\treturn nil\n}\n\n// 开始运行，都是并发的\nfunc startKubelet(k kubelet.Bootstrap, podCfg *config.PodConfig, kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *kubelet.Dependencies, enableCAdvisorJSONEndpoints, enableServer bool) {\n\t// 运行\n\tgo k.Run(podCfg.Updates())\n\n\t// 开启kubelet的http服务端\n\tif enableServer {\n\t\tgo k.ListenAndServe(net.ParseIP(kubeCfg.Address), uint(kubeCfg.Port), kubeDeps.TLSOptions, kubeDeps.Auth,\n\t\t\tenableCAdvisorJSONEndpoints, kubeCfg.EnableDebuggingHandlers, kubeCfg.EnableContentionProfiling, kubeCfg.EnableSystemLogHandler)\n\n\t}\n  // 只读端口\n\tif kubeCfg.ReadOnlyPort > 0 {\n\t\tgo k.ListenAndServeReadOnly(net.ParseIP(kubeCfg.Address), uint(kubeCfg.ReadOnlyPort), enableCAdvisorJSONEndpoints)\n\t}\n\tif utilfeature.DefaultFeatureGate.Enabled(features.KubeletPodResources) {\n\t\tgo k.ListenAndServePodResources()\n\t}\n}\n```\n\n\n\n## Kubelet\n\n```go\n// 这里的k是一个interface定义，我们需要回头看看\ntype Bootstrap interface {\n\tGetConfiguration() kubeletconfiginternal.KubeletConfiguration\n\tBirthCry()\n\tStartGarbageCollection()\n\tListenAndServe(address net.IP, port uint, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler bool)\n\tListenAndServeReadOnly(address net.IP, port uint, enableCAdvisorJSONEndpoints bool)\n\tListenAndServePodResources()\n\tRun(<-chan kubetypes.PodUpdate)\n\tRunOnce(<-chan kubetypes.PodUpdate) ([]RunPodResult, error)\n}\n\n// 查看对应的实例化函数\nfunc createAndInitKubelet() (k kubelet.Bootstrap, err error) {\n\tk, err = kubelet.NewMainKubelet()\n\treturn k, nil\n}\n\nfunc NewMainKubelet() (*Kubelet, error) {\n\t// 参数的初始化\n\t\n  // klet 的实例化结构\n\tklet := &Kubelet{}\n\n  // 下面是klet中各种参数的填充\n\treturn klet, nil\n}\n\nfunc (kl *Kubelet) Run(updates <-chan kubetypes.PodUpdate) {\n\t// 内部模块的初始化\n\tif err := kl.initializeModules(); err != nil {\n\t\tkl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())\n\t\tklog.Fatal(err)\n\t}\n\n\tgo kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)\n\n\tif kl.kubeClient != nil {\n    // 与kube-apiserver同步节点状态\n\t\tgo wait.Until(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, wait.NeverStop)\n\t\tgo kl.fastStatusUpdateOnce()\n\t\tgo kl.nodeLeaseController.Run(wait.NeverStop)\n\t}\n\tgo wait.Until(kl.updateRuntimeUp, 5*time.Second, wait.NeverStop)\n\n\tif kl.makeIPTablesUtilChains {\n\t\tkl.initNetworkUtil()\n\t}\n\n  // 一个kill pod的goroutine\n\tgo wait.Until(kl.podKiller.PerformPodKillingWork, 1*time.Second, wait.NeverStop)\n\n\tkl.statusManager.Start()\n\tkl.probeManager.Start()\n\n\tif kl.runtimeClassManager != nil {\n\t\tkl.runtimeClassManager.Start(wait.NeverStop)\n\t}\n\n\tkl.pleg.Start()\n  // 同步的主逻辑\n\tkl.syncLoop(updates, kl)\n}\n```\n\n\n\n## syncLoop\n\n```go\nfunc (kl *Kubelet) syncLoop(updates <-chan kubetypes.PodUpdate, handler SyncHandler) {\n  // 开始运行kubelet的主同步循环\n\tklog.Info(\"Starting kubelet main sync loop.\")\n  \n  // ticker每秒一次\n\tsyncTicker := time.NewTicker(time.Second)\n\tdefer syncTicker.Stop()\n  // housekeeping 清理周期\n\thousekeepingTicker := time.NewTicker(housekeepingPeriod)\n\tdefer housekeepingTicker.Stop()\n\t\n\tfor {\n\t\tkl.syncLoopMonitor.Store(kl.clock.Now())\n    // 同步\n\t\tif !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) {\n\t\t\tbreak\n\t\t}\n\t\tkl.syncLoopMonitor.Store(kl.clock.Now())\n\t}\n}\n\n// 这里的3个channel比较重要：configCh用于配置，syncCh用于触发同步，housekeepingCh用于触发清理\nfunc (kl *Kubelet) syncLoopIteration(configCh <-chan kubetypes.PodUpdate, handler SyncHandler,\n\tsyncCh <-chan time.Time, housekeepingCh <-chan time.Time, plegCh <-chan *pleg.PodLifecycleEvent) bool {\n\tselect {\n\tcase u, open := <-configCh:\n    // config channel关闭\n\t\tif !open {\n\t\t\tklog.Errorf(\"Update channel is closed. Exiting the sync loop.\")\n\t\t\treturn false\n\t\t}\n\t\t// 对应不同的操作\n\t\tswitch u.Op {\n\t\tcase kubetypes.ADD:\n\t\t\tklog.V(2).Infof(\"SyncLoop (ADD, %q): %q\", u.Source, format.Pods(u.Pods))\n\t\t\thandler.HandlePodAdditions(u.Pods)\n\t\tcase kubetypes.UPDATE:\n\t\t\tklog.V(2).Infof(\"SyncLoop (UPDATE, %q): %q\", u.Source, format.PodsWithDeletionTimestamps(u.Pods))\n\t\t\thandler.HandlePodUpdates(u.Pods)\n\t\tcase kubetypes.REMOVE:\n\t\t\tklog.V(2).Infof(\"SyncLoop (REMOVE, %q): %q\", u.Source, format.Pods(u.Pods))\n\t\t\thandler.HandlePodRemoves(u.Pods)\n\t\tcase kubetypes.RECONCILE:\n\t\t\tklog.V(4).Infof(\"SyncLoop (RECONCILE, %q): %q\", u.Source, format.Pods(u.Pods))\n\t\t\thandler.HandlePodReconcile(u.Pods)\n\t\tcase kubetypes.DELETE:\n\t\t\tklog.V(2).Infof(\"SyncLoop (DELETE, %q): %q\", u.Source, format.Pods(u.Pods))\n\t\t\thandler.HandlePodUpdates(u.Pods)\n\t\tcase kubetypes.SET:\n\t\t\tklog.Errorf(\"Kubelet does not support snapshot update\")\n\t\tdefault:\n\t\t\tklog.Errorf(\"Invalid event type received: %d.\", u.Op)\n\t\t}\n\n\t\tkl.sourcesReady.AddSource(u.Source)\n\n\tcase e := <-plegCh:\n\t\t\n\tcase <-syncCh:\n\t\t// 获取需要同步的pod，里面的逻辑暂不细看\n    // 我们在这里接收到示例中要创建的nginx pod\n\t\tpodsToSync := kl.getPodsToSync()\n\t\tif len(podsToSync) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tklog.V(4).Infof(\"SyncLoop (SYNC): %d pods; %s\", len(podsToSync), format.Pods(podsToSync))\n    // 开始处理\n\t\thandler.HandlePodSyncs(podsToSync)\n\tcase update := <-kl.livenessManager.Updates():\n\n\tcase <-housekeepingCh:\n\t\tif !kl.sourcesReady.AllReady() {\n      // 清理没有ready，直接跳过\n\t\t\tklog.V(4).Infof(\"SyncLoop (housekeeping, skipped): sources aren't ready yet.\")\n\t\t} else {\n      // 开始清理pod\n\t\t\tklog.V(4).Infof(\"SyncLoop (housekeeping)\")\n\t\t\tif err := handler.HandlePodCleanups(); err != nil {\n\t\t\t\tklog.Errorf(\"Failed cleaning pods: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n```\n\n\n\n## handler\n\n往前查找代码，handler就是Kubelet\n\n```go\nfunc (kl *Kubelet) HandlePodSyncs(pods []*v1.Pod) {\n\tstart := kl.clock.Now()\n\tfor _, pod := range pods {\n    // 获取pod，然后分发\n\t\tmirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)\n\t\tkl.dispatchWork(pod, kubetypes.SyncPodSync, mirrorPod, start)\n\t}\n}\n\nfunc (kl *Kubelet) dispatchWork(pod *v1.Pod, syncType kubetypes.SyncPodType, mirrorPod *v1.Pod, start time.Time) {\n\t// 调用UpdatePod的函数\n\tkl.podWorkers.UpdatePod(&UpdatePodOptions{\n\t\tPod:        pod,\n\t\tMirrorPod:  mirrorPod,\n\t\tUpdateType: syncType,\n\t\tOnCompleteFunc: func(err error) {\n\t\t\tif err != nil {\n\t\t\t\tmetrics.PodWorkerDuration.WithLabelValues(syncType.String()).Observe(metrics.SinceInSeconds(start))\n\t\t\t}\n\t\t},\n\t})\n}\n\n// 查到初始化的地方 \tklet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)\nfunc (p *podWorkers) UpdatePod(options *UpdatePodOptions) {\n\tpod := options.Pod\n\tuid := pod.UID\n\tvar podUpdates chan UpdatePodOptions\n\tvar exists bool\n\n\tp.podLock.Lock()\n\tdefer p.podLock.Unlock()\n  // 当pod不存在时，满足示例，是新建的pod\n\tif podUpdates, exists = p.podUpdates[uid]; !exists {\n\t\tpodUpdates = make(chan UpdatePodOptions, 1)\n\t\tp.podUpdates[uid] = podUpdates\n\n    // 并发处理\n\t\tgo func() {\n\t\t\tdefer runtime.HandleCrash()\n\t\t\tp.managePodLoop(podUpdates)\n\t\t}()\n\t}\n\tif !p.isWorking[pod.UID] {\n\t\tp.isWorking[pod.UID] = true\n\t\tpodUpdates <- *options\n\t} else {\n\t\tupdate, found := p.lastUndeliveredWorkUpdate[pod.UID]\n\t\tif !found || update.UpdateType != kubetypes.SyncPodKill {\n\t\t\tp.lastUndeliveredWorkUpdate[pod.UID] = *options\n\t\t}\n\t}\n}\n\nfunc (p *podWorkers) managePodLoop(podUpdates <-chan UpdatePodOptions) {\n\tvar lastSyncTime time.Time\n\tfor update := range podUpdates {\n\t\terr := func() error {\n      // 同步pod的函数\n\t\t\terr = p.syncPodFn(syncPodOptions{\n\t\t\t\tmirrorPod:      update.MirrorPod,\n\t\t\t\tpod:            update.Pod,\n\t\t\t\tpodStatus:      status,\n\t\t\t\tkillPodOptions: update.KillPodOptions,\n\t\t\t\tupdateType:     update.UpdateType,\n\t\t\t})\n\t\t\tlastSyncTime = time.Now()\n\t\t\treturn err\n\t\t}()\n\t\t\n\t\tp.wrapUp(update.Pod.UID, err)\n\t}\n}\n\n// 找到syncPodFn被实例化的函数\nfunc (kl *Kubelet) syncPod(o syncPodOptions) error {\n  \n  // 这里有一长串逻辑，不方便阅读，我们只关注最核心的部分\n  \n  // 调用 container runtime进行创建pod，再往下就是容器相关了\n\tresult := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)\n\tkl.reasonCache.Update(pod.UID, result)\n\tif err := result.Error(); err != nil {\n\t\tfor _, r := range result.SyncResults {\n\t\t\tif r.Error != kubecontainer.ErrCrashLoopBackOff && r.Error != images.ErrImagePullBackOff {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn nil\n}\n```\n\n\n\n## Summary\n\n1. `kubelet`是kubernetes的`Node`节点上的管理者\n\n2. `kubelet`接收来自`kube-apiserver`上的pod消息，用`Ticker`这种周期性的方式触发同步函数\n3. `kubelet`会异步地对容器进行管理，调用对应容器的接口（Container Runtime Interface）","source":"_posts/k8s-013.md","raw":"---\ntitle: 【K8s源码品读】013：Phase 1 - kubelet - 节点上控制容器生命周期的管理者\ndate: 2021-02-18 16:55:58\ncategories: \n- 源码阅读\ntags:\n- Kubernetes\n---\n\n## 聚焦目标\n\n理解 kubelet 的运行机制\n\n\n\n## 目录\n\n1. [运行的主函数](#Run)\n2. [运行kubelet](#RunKubelet)\n3. [核心数据管理Kubelet](#Kubelet)\n4. [同步循环](#syncLoop)\n5. [处理pod的同步工作](#handler)\n6. [总结](#Summary)\n\n\n\n## Run\n\n从主函数找到run函数，代码较长，我精简了一下\n\n```go\nfunc run(ctx context.Context, s *options.KubeletServer, kubeDeps *kubelet.Dependencies, featureGate featuregate.FeatureGate) (err error) {\n\t// 一长串的配置初始化与验证\n\n  // done channel，用来通知运行结束\n\tdone := make(chan struct{})\n\t\n\t// 注册到configz模块\n\terr = initConfigz(&s.KubeletConfiguration)\n\tif err != nil {\n\t\tklog.Errorf(\"unable to register KubeletConfiguration with configz, error: %v\", err)\n\t}\n\n  // 获取节点的相关信息\n\thostName, err := nodeutil.GetHostname(s.HostnameOverride)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnodeName, err := getNodeName(kubeDeps.Cloud, hostName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch {\n  // 独立运行模式\n\tcase standaloneMode:\n\t// 对客户端进行初始化\n\tcase kubeDeps.KubeClient == nil, kubeDeps.EventClient == nil, kubeDeps.HeartbeatClient == nil:\n\t}\n\n  // cgroup 相关初始化\n\tvar cgroupRoots []string\n\tnodeAllocatableRoot := cm.NodeAllocatableRoot(s.CgroupRoot, s.CgroupsPerQOS, s.CgroupDriver)\n\tcgroupRoots = append(cgroupRoots, nodeAllocatableRoot)\n\tkubeletCgroup, err := cm.GetKubeletContainer(s.KubeletCgroups)\n\tif err != nil {\n\t\tklog.Warningf(\"failed to get the kubelet's cgroup: %v.  Kubelet system container metrics may be missing.\", err)\n\t} else if kubeletCgroup != \"\" {\n\t\tcgroupRoots = append(cgroupRoots, kubeletCgroup)\n\t}\n\n\truntimeCgroup, err := cm.GetRuntimeContainer(s.ContainerRuntime, s.RuntimeCgroups)\n\tif err != nil {\n\t\tklog.Warningf(\"failed to get the container runtime's cgroup: %v. Runtime system container metrics may be missing.\", err)\n\t} else if runtimeCgroup != \"\" {\n\t\tcgroupRoots = append(cgroupRoots, runtimeCgroup)\n\t}\n\n\tif s.SystemCgroups != \"\" {\n\t\tcgroupRoots = append(cgroupRoots, s.SystemCgroups)\n\t}\n\n  // 下面一大块都是对 ContainerManager 的初始化\n\tif kubeDeps.ContainerManager == nil {\n\t\tif s.CgroupsPerQOS && s.CgroupRoot == \"\" {\n\t\t\tklog.Info(\"--cgroups-per-qos enabled, but --cgroup-root was not specified.  defaulting to /\")\n\t\t\ts.CgroupRoot = \"/\"\n\t\t}\n    \n\t\t// cpu相关信息\n\t\tvar reservedSystemCPUs cpuset.CPUSet\n\n    // ContainerManager的实例化\n\t\tkubeDeps.ContainerManager, err = cm.NewContainerManager(\n\t\t\tkubeDeps.Mounter,\n\t\t\tkubeDeps.CAdvisorInterface,\n      // Node 相关配置\n\t\t\tcm.NodeConfig{},\n\t\t\ts.FailSwapOn,\n\t\t\tdevicePluginEnabled,\n\t\t\tkubeDeps.Recorder)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// 内存OOM相关\n\toomAdjuster := kubeDeps.OOMAdjuster\n\tif err := oomAdjuster.ApplyOOMScoreAdj(0, int(s.OOMScoreAdj)); err != nil {\n\t\tklog.Warning(err)\n\t}\n\n\t// 预初始化Runtime\n\terr = kubelet.PreInitRuntimeService(&s.KubeletConfiguration,\n\t\tkubeDeps, &s.ContainerRuntimeOptions,\n\t\ts.ContainerRuntime,\n\t\ts.RuntimeCgroups,\n\t\ts.RemoteRuntimeEndpoint,\n\t\ts.RemoteImageEndpoint,\n\t\ts.NonMasqueradeCIDR)\n\tif err != nil {\n\t\treturn err\n\t}\n\n  // 运行Kubelet\n\tif err := RunKubelet(s, kubeDeps, s.RunOnce); err != nil {\n\t\treturn err\n\t}\n\n\t// 通知deamon的systemd\n\tgo daemon.SdNotify(false, \"READY=1\")\n\n  // 阻塞\n\tselect {\n\tcase <-done:\n\t\tbreak\n\tcase <-ctx.Done():\n\t\tbreak\n\t}\n\n\treturn nil\n}\n```\n\n\n\n## RunKubelet\n\n```go\nfunc RunKubelet(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce bool) error {\n\t// 获取节点信息\n  hostname, err := nodeutil.GetHostname(kubeServer.HostnameOverride)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnodeName, err := getNodeName(kubeDeps.Cloud, hostname)\n\tif err != nil {\n\t\treturn err\n\t}\n\thostnameOverridden := len(kubeServer.HostnameOverride) > 0\n\n  // 创建并初始化 kubelet\n\tk, err := createAndInitKubelet()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create kubelet: %v\", err)\n\t}\n\n\tif runOnce {\n\t\tif _, err := k.RunOnce(podCfg.Updates()); err != nil {\n\t\t\treturn fmt.Errorf(\"runonce failed: %v\", err)\n\t\t}\n\t\tklog.Info(\"Started kubelet as runonce\")\n\t} else {\n    // 开始kubelet\n\t\tstartKubelet(k, podCfg, &kubeServer.KubeletConfiguration, kubeDeps, kubeServer.EnableCAdvisorJSONEndpoints, kubeServer.EnableServer)\n\t\tklog.Info(\"Started kubelet\")\n\t}\n\treturn nil\n}\n\n// 开始运行，都是并发的\nfunc startKubelet(k kubelet.Bootstrap, podCfg *config.PodConfig, kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *kubelet.Dependencies, enableCAdvisorJSONEndpoints, enableServer bool) {\n\t// 运行\n\tgo k.Run(podCfg.Updates())\n\n\t// 开启kubelet的http服务端\n\tif enableServer {\n\t\tgo k.ListenAndServe(net.ParseIP(kubeCfg.Address), uint(kubeCfg.Port), kubeDeps.TLSOptions, kubeDeps.Auth,\n\t\t\tenableCAdvisorJSONEndpoints, kubeCfg.EnableDebuggingHandlers, kubeCfg.EnableContentionProfiling, kubeCfg.EnableSystemLogHandler)\n\n\t}\n  // 只读端口\n\tif kubeCfg.ReadOnlyPort > 0 {\n\t\tgo k.ListenAndServeReadOnly(net.ParseIP(kubeCfg.Address), uint(kubeCfg.ReadOnlyPort), enableCAdvisorJSONEndpoints)\n\t}\n\tif utilfeature.DefaultFeatureGate.Enabled(features.KubeletPodResources) {\n\t\tgo k.ListenAndServePodResources()\n\t}\n}\n```\n\n\n\n## Kubelet\n\n```go\n// 这里的k是一个interface定义，我们需要回头看看\ntype Bootstrap interface {\n\tGetConfiguration() kubeletconfiginternal.KubeletConfiguration\n\tBirthCry()\n\tStartGarbageCollection()\n\tListenAndServe(address net.IP, port uint, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler bool)\n\tListenAndServeReadOnly(address net.IP, port uint, enableCAdvisorJSONEndpoints bool)\n\tListenAndServePodResources()\n\tRun(<-chan kubetypes.PodUpdate)\n\tRunOnce(<-chan kubetypes.PodUpdate) ([]RunPodResult, error)\n}\n\n// 查看对应的实例化函数\nfunc createAndInitKubelet() (k kubelet.Bootstrap, err error) {\n\tk, err = kubelet.NewMainKubelet()\n\treturn k, nil\n}\n\nfunc NewMainKubelet() (*Kubelet, error) {\n\t// 参数的初始化\n\t\n  // klet 的实例化结构\n\tklet := &Kubelet{}\n\n  // 下面是klet中各种参数的填充\n\treturn klet, nil\n}\n\nfunc (kl *Kubelet) Run(updates <-chan kubetypes.PodUpdate) {\n\t// 内部模块的初始化\n\tif err := kl.initializeModules(); err != nil {\n\t\tkl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())\n\t\tklog.Fatal(err)\n\t}\n\n\tgo kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)\n\n\tif kl.kubeClient != nil {\n    // 与kube-apiserver同步节点状态\n\t\tgo wait.Until(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, wait.NeverStop)\n\t\tgo kl.fastStatusUpdateOnce()\n\t\tgo kl.nodeLeaseController.Run(wait.NeverStop)\n\t}\n\tgo wait.Until(kl.updateRuntimeUp, 5*time.Second, wait.NeverStop)\n\n\tif kl.makeIPTablesUtilChains {\n\t\tkl.initNetworkUtil()\n\t}\n\n  // 一个kill pod的goroutine\n\tgo wait.Until(kl.podKiller.PerformPodKillingWork, 1*time.Second, wait.NeverStop)\n\n\tkl.statusManager.Start()\n\tkl.probeManager.Start()\n\n\tif kl.runtimeClassManager != nil {\n\t\tkl.runtimeClassManager.Start(wait.NeverStop)\n\t}\n\n\tkl.pleg.Start()\n  // 同步的主逻辑\n\tkl.syncLoop(updates, kl)\n}\n```\n\n\n\n## syncLoop\n\n```go\nfunc (kl *Kubelet) syncLoop(updates <-chan kubetypes.PodUpdate, handler SyncHandler) {\n  // 开始运行kubelet的主同步循环\n\tklog.Info(\"Starting kubelet main sync loop.\")\n  \n  // ticker每秒一次\n\tsyncTicker := time.NewTicker(time.Second)\n\tdefer syncTicker.Stop()\n  // housekeeping 清理周期\n\thousekeepingTicker := time.NewTicker(housekeepingPeriod)\n\tdefer housekeepingTicker.Stop()\n\t\n\tfor {\n\t\tkl.syncLoopMonitor.Store(kl.clock.Now())\n    // 同步\n\t\tif !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) {\n\t\t\tbreak\n\t\t}\n\t\tkl.syncLoopMonitor.Store(kl.clock.Now())\n\t}\n}\n\n// 这里的3个channel比较重要：configCh用于配置，syncCh用于触发同步，housekeepingCh用于触发清理\nfunc (kl *Kubelet) syncLoopIteration(configCh <-chan kubetypes.PodUpdate, handler SyncHandler,\n\tsyncCh <-chan time.Time, housekeepingCh <-chan time.Time, plegCh <-chan *pleg.PodLifecycleEvent) bool {\n\tselect {\n\tcase u, open := <-configCh:\n    // config channel关闭\n\t\tif !open {\n\t\t\tklog.Errorf(\"Update channel is closed. Exiting the sync loop.\")\n\t\t\treturn false\n\t\t}\n\t\t// 对应不同的操作\n\t\tswitch u.Op {\n\t\tcase kubetypes.ADD:\n\t\t\tklog.V(2).Infof(\"SyncLoop (ADD, %q): %q\", u.Source, format.Pods(u.Pods))\n\t\t\thandler.HandlePodAdditions(u.Pods)\n\t\tcase kubetypes.UPDATE:\n\t\t\tklog.V(2).Infof(\"SyncLoop (UPDATE, %q): %q\", u.Source, format.PodsWithDeletionTimestamps(u.Pods))\n\t\t\thandler.HandlePodUpdates(u.Pods)\n\t\tcase kubetypes.REMOVE:\n\t\t\tklog.V(2).Infof(\"SyncLoop (REMOVE, %q): %q\", u.Source, format.Pods(u.Pods))\n\t\t\thandler.HandlePodRemoves(u.Pods)\n\t\tcase kubetypes.RECONCILE:\n\t\t\tklog.V(4).Infof(\"SyncLoop (RECONCILE, %q): %q\", u.Source, format.Pods(u.Pods))\n\t\t\thandler.HandlePodReconcile(u.Pods)\n\t\tcase kubetypes.DELETE:\n\t\t\tklog.V(2).Infof(\"SyncLoop (DELETE, %q): %q\", u.Source, format.Pods(u.Pods))\n\t\t\thandler.HandlePodUpdates(u.Pods)\n\t\tcase kubetypes.SET:\n\t\t\tklog.Errorf(\"Kubelet does not support snapshot update\")\n\t\tdefault:\n\t\t\tklog.Errorf(\"Invalid event type received: %d.\", u.Op)\n\t\t}\n\n\t\tkl.sourcesReady.AddSource(u.Source)\n\n\tcase e := <-plegCh:\n\t\t\n\tcase <-syncCh:\n\t\t// 获取需要同步的pod，里面的逻辑暂不细看\n    // 我们在这里接收到示例中要创建的nginx pod\n\t\tpodsToSync := kl.getPodsToSync()\n\t\tif len(podsToSync) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tklog.V(4).Infof(\"SyncLoop (SYNC): %d pods; %s\", len(podsToSync), format.Pods(podsToSync))\n    // 开始处理\n\t\thandler.HandlePodSyncs(podsToSync)\n\tcase update := <-kl.livenessManager.Updates():\n\n\tcase <-housekeepingCh:\n\t\tif !kl.sourcesReady.AllReady() {\n      // 清理没有ready，直接跳过\n\t\t\tklog.V(4).Infof(\"SyncLoop (housekeeping, skipped): sources aren't ready yet.\")\n\t\t} else {\n      // 开始清理pod\n\t\t\tklog.V(4).Infof(\"SyncLoop (housekeeping)\")\n\t\t\tif err := handler.HandlePodCleanups(); err != nil {\n\t\t\t\tklog.Errorf(\"Failed cleaning pods: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n```\n\n\n\n## handler\n\n往前查找代码，handler就是Kubelet\n\n```go\nfunc (kl *Kubelet) HandlePodSyncs(pods []*v1.Pod) {\n\tstart := kl.clock.Now()\n\tfor _, pod := range pods {\n    // 获取pod，然后分发\n\t\tmirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)\n\t\tkl.dispatchWork(pod, kubetypes.SyncPodSync, mirrorPod, start)\n\t}\n}\n\nfunc (kl *Kubelet) dispatchWork(pod *v1.Pod, syncType kubetypes.SyncPodType, mirrorPod *v1.Pod, start time.Time) {\n\t// 调用UpdatePod的函数\n\tkl.podWorkers.UpdatePod(&UpdatePodOptions{\n\t\tPod:        pod,\n\t\tMirrorPod:  mirrorPod,\n\t\tUpdateType: syncType,\n\t\tOnCompleteFunc: func(err error) {\n\t\t\tif err != nil {\n\t\t\t\tmetrics.PodWorkerDuration.WithLabelValues(syncType.String()).Observe(metrics.SinceInSeconds(start))\n\t\t\t}\n\t\t},\n\t})\n}\n\n// 查到初始化的地方 \tklet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)\nfunc (p *podWorkers) UpdatePod(options *UpdatePodOptions) {\n\tpod := options.Pod\n\tuid := pod.UID\n\tvar podUpdates chan UpdatePodOptions\n\tvar exists bool\n\n\tp.podLock.Lock()\n\tdefer p.podLock.Unlock()\n  // 当pod不存在时，满足示例，是新建的pod\n\tif podUpdates, exists = p.podUpdates[uid]; !exists {\n\t\tpodUpdates = make(chan UpdatePodOptions, 1)\n\t\tp.podUpdates[uid] = podUpdates\n\n    // 并发处理\n\t\tgo func() {\n\t\t\tdefer runtime.HandleCrash()\n\t\t\tp.managePodLoop(podUpdates)\n\t\t}()\n\t}\n\tif !p.isWorking[pod.UID] {\n\t\tp.isWorking[pod.UID] = true\n\t\tpodUpdates <- *options\n\t} else {\n\t\tupdate, found := p.lastUndeliveredWorkUpdate[pod.UID]\n\t\tif !found || update.UpdateType != kubetypes.SyncPodKill {\n\t\t\tp.lastUndeliveredWorkUpdate[pod.UID] = *options\n\t\t}\n\t}\n}\n\nfunc (p *podWorkers) managePodLoop(podUpdates <-chan UpdatePodOptions) {\n\tvar lastSyncTime time.Time\n\tfor update := range podUpdates {\n\t\terr := func() error {\n      // 同步pod的函数\n\t\t\terr = p.syncPodFn(syncPodOptions{\n\t\t\t\tmirrorPod:      update.MirrorPod,\n\t\t\t\tpod:            update.Pod,\n\t\t\t\tpodStatus:      status,\n\t\t\t\tkillPodOptions: update.KillPodOptions,\n\t\t\t\tupdateType:     update.UpdateType,\n\t\t\t})\n\t\t\tlastSyncTime = time.Now()\n\t\t\treturn err\n\t\t}()\n\t\t\n\t\tp.wrapUp(update.Pod.UID, err)\n\t}\n}\n\n// 找到syncPodFn被实例化的函数\nfunc (kl *Kubelet) syncPod(o syncPodOptions) error {\n  \n  // 这里有一长串逻辑，不方便阅读，我们只关注最核心的部分\n  \n  // 调用 container runtime进行创建pod，再往下就是容器相关了\n\tresult := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)\n\tkl.reasonCache.Update(pod.UID, result)\n\tif err := result.Error(); err != nil {\n\t\tfor _, r := range result.SyncResults {\n\t\t\tif r.Error != kubecontainer.ErrCrashLoopBackOff && r.Error != images.ErrImagePullBackOff {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn nil\n}\n```\n\n\n\n## Summary\n\n1. `kubelet`是kubernetes的`Node`节点上的管理者\n\n2. `kubelet`接收来自`kube-apiserver`上的pod消息，用`Ticker`这种周期性的方式触发同步函数\n3. `kubelet`会异步地对容器进行管理，调用对应容器的接口（Container Runtime Interface）","slug":"k8s-013","published":1,"updated":"2021-02-18T09:49:31.728Z","_id":"cklaograr000ca4qpcjyu67el","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解 kubelet 的运行机制</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#Run\">运行的主函数</a></li>\n<li><a href=\"#RunKubelet\">运行kubelet</a></li>\n<li><a href=\"#Kubelet\">核心数据管理Kubelet</a></li>\n<li><a href=\"#syncLoop\">同步循环</a></li>\n<li><a href=\"#handler\">处理pod的同步工作</a></li>\n<li><a href=\"#Summary\">总结</a></li>\n</ol>\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><p>从主函数找到run函数，代码较长，我精简了一下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">run</span><span class=\"params\">(ctx context.Context, s *options.KubeletServer, kubeDeps *kubelet.Dependencies, featureGate featuregate.FeatureGate)</span> <span class=\"params\">(err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 一长串的配置初始化与验证</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// done channel，用来通知运行结束</span></span><br><span class=\"line\">\tdone := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 注册到configz模块</span></span><br><span class=\"line\">\terr = initConfigz(&amp;s.KubeletConfiguration)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Errorf(<span class=\"string\">&quot;unable to register KubeletConfiguration with configz, error: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获取节点的相关信息</span></span><br><span class=\"line\">\thostName, err := nodeutil.GetHostname(s.HostnameOverride)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnodeName, err := getNodeName(kubeDeps.Cloud, hostName)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 独立运行模式</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> standaloneMode:</span><br><span class=\"line\">\t<span class=\"comment\">// 对客户端进行初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> kubeDeps.KubeClient == <span class=\"literal\">nil</span>, kubeDeps.EventClient == <span class=\"literal\">nil</span>, kubeDeps.HeartbeatClient == <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// cgroup 相关初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> cgroupRoots []<span class=\"keyword\">string</span></span><br><span class=\"line\">\tnodeAllocatableRoot := cm.NodeAllocatableRoot(s.CgroupRoot, s.CgroupsPerQOS, s.CgroupDriver)</span><br><span class=\"line\">\tcgroupRoots = <span class=\"built_in\">append</span>(cgroupRoots, nodeAllocatableRoot)</span><br><span class=\"line\">\tkubeletCgroup, err := cm.GetKubeletContainer(s.KubeletCgroups)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Warningf(<span class=\"string\">&quot;failed to get the kubelet&#x27;s cgroup: %v.  Kubelet system container metrics may be missing.&quot;</span>, err)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> kubeletCgroup != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\tcgroupRoots = <span class=\"built_in\">append</span>(cgroupRoots, kubeletCgroup)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\truntimeCgroup, err := cm.GetRuntimeContainer(s.ContainerRuntime, s.RuntimeCgroups)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Warningf(<span class=\"string\">&quot;failed to get the container runtime&#x27;s cgroup: %v. Runtime system container metrics may be missing.&quot;</span>, err)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> runtimeCgroup != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\tcgroupRoots = <span class=\"built_in\">append</span>(cgroupRoots, runtimeCgroup)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.SystemCgroups != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\tcgroupRoots = <span class=\"built_in\">append</span>(cgroupRoots, s.SystemCgroups)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 下面一大块都是对 ContainerManager 的初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kubeDeps.ContainerManager == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.CgroupsPerQOS &amp;&amp; s.CgroupRoot == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tklog.Info(<span class=\"string\">&quot;--cgroups-per-qos enabled, but --cgroup-root was not specified.  defaulting to /&quot;</span>)</span><br><span class=\"line\">\t\t\ts.CgroupRoot = <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">// cpu相关信息</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> reservedSystemCPUs cpuset.CPUSet</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ContainerManager的实例化</span></span><br><span class=\"line\">\t\tkubeDeps.ContainerManager, err = cm.NewContainerManager(</span><br><span class=\"line\">\t\t\tkubeDeps.Mounter,</span><br><span class=\"line\">\t\t\tkubeDeps.CAdvisorInterface,</span><br><span class=\"line\">      <span class=\"comment\">// Node 相关配置</span></span><br><span class=\"line\">\t\t\tcm.NodeConfig&#123;&#125;,</span><br><span class=\"line\">\t\t\ts.FailSwapOn,</span><br><span class=\"line\">\t\t\tdevicePluginEnabled,</span><br><span class=\"line\">\t\t\tkubeDeps.Recorder)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 内存OOM相关</span></span><br><span class=\"line\">\toomAdjuster := kubeDeps.OOMAdjuster</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := oomAdjuster.ApplyOOMScoreAdj(<span class=\"number\">0</span>, <span class=\"keyword\">int</span>(s.OOMScoreAdj)); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Warning(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 预初始化Runtime</span></span><br><span class=\"line\">\terr = kubelet.PreInitRuntimeService(&amp;s.KubeletConfiguration,</span><br><span class=\"line\">\t\tkubeDeps, &amp;s.ContainerRuntimeOptions,</span><br><span class=\"line\">\t\ts.ContainerRuntime,</span><br><span class=\"line\">\t\ts.RuntimeCgroups,</span><br><span class=\"line\">\t\ts.RemoteRuntimeEndpoint,</span><br><span class=\"line\">\t\ts.RemoteImageEndpoint,</span><br><span class=\"line\">\t\ts.NonMasqueradeCIDR)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 运行Kubelet</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := RunKubelet(s, kubeDeps, s.RunOnce); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 通知deamon的systemd</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> daemon.SdNotify(<span class=\"literal\">false</span>, <span class=\"string\">&quot;READY=1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> &lt;-done:</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RunKubelet\"><a href=\"#RunKubelet\" class=\"headerlink\" title=\"RunKubelet\"></a>RunKubelet</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RunKubelet</span><span class=\"params\">(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce <span class=\"keyword\">bool</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取节点信息</span></span><br><span class=\"line\">  hostname, err := nodeutil.GetHostname(kubeServer.HostnameOverride)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnodeName, err := getNodeName(kubeDeps.Cloud, hostname)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\thostnameOverridden := <span class=\"built_in\">len</span>(kubeServer.HostnameOverride) &gt; <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 创建并初始化 kubelet</span></span><br><span class=\"line\">\tk, err := createAndInitKubelet()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;failed to create kubelet: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> runOnce &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, err := k.RunOnce(podCfg.Updates()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;runonce failed: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.Info(<span class=\"string\">&quot;Started kubelet as runonce&quot;</span>)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开始kubelet</span></span><br><span class=\"line\">\t\tstartKubelet(k, podCfg, &amp;kubeServer.KubeletConfiguration, kubeDeps, kubeServer.EnableCAdvisorJSONEndpoints, kubeServer.EnableServer)</span><br><span class=\"line\">\t\tklog.Info(<span class=\"string\">&quot;Started kubelet&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始运行，都是并发的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startKubelet</span><span class=\"params\">(k kubelet.Bootstrap, podCfg *config.PodConfig, kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *kubelet.Dependencies, enableCAdvisorJSONEndpoints, enableServer <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 运行</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> k.Run(podCfg.Updates())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 开启kubelet的http服务端</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> enableServer &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> k.ListenAndServe(net.ParseIP(kubeCfg.Address), <span class=\"keyword\">uint</span>(kubeCfg.Port), kubeDeps.TLSOptions, kubeDeps.Auth,</span><br><span class=\"line\">\t\t\tenableCAdvisorJSONEndpoints, kubeCfg.EnableDebuggingHandlers, kubeCfg.EnableContentionProfiling, kubeCfg.EnableSystemLogHandler)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 只读端口</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kubeCfg.ReadOnlyPort &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> k.ListenAndServeReadOnly(net.ParseIP(kubeCfg.Address), <span class=\"keyword\">uint</span>(kubeCfg.ReadOnlyPort), enableCAdvisorJSONEndpoints)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> utilfeature.DefaultFeatureGate.Enabled(features.KubeletPodResources) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> k.ListenAndServePodResources()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Kubelet\"><a href=\"#Kubelet\" class=\"headerlink\" title=\"Kubelet\"></a>Kubelet</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里的k是一个interface定义，我们需要回头看看</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Bootstrap <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tGetConfiguration() kubeletconfiginternal.KubeletConfiguration</span><br><span class=\"line\">\tBirthCry()</span><br><span class=\"line\">\tStartGarbageCollection()</span><br><span class=\"line\">\tListenAndServe(address net.IP, port <span class=\"keyword\">uint</span>, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">\tListenAndServeReadOnly(address net.IP, port <span class=\"keyword\">uint</span>, enableCAdvisorJSONEndpoints <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">\tListenAndServePodResources()</span><br><span class=\"line\">\tRun(&lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate)</span><br><span class=\"line\">\tRunOnce(&lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate) ([]RunPodResult, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看对应的实例化函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createAndInitKubelet</span><span class=\"params\">()</span> <span class=\"params\">(k kubelet.Bootstrap, err error)</span></span> &#123;</span><br><span class=\"line\">\tk, err = kubelet.NewMainKubelet()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> k, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewMainKubelet</span><span class=\"params\">()</span> <span class=\"params\">(*Kubelet, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 参数的初始化</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// klet 的实例化结构</span></span><br><span class=\"line\">\tklet := &amp;Kubelet&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 下面是klet中各种参数的填充</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> klet, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">Run</span><span class=\"params\">(updates &lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 内部模块的初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := kl.initializeModules(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tkl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())</span><br><span class=\"line\">\t\tklog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kl.kubeClient != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 与kube-apiserver同步节点状态</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> wait.Until(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, wait.NeverStop)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> kl.fastStatusUpdateOnce()</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> kl.nodeLeaseController.Run(wait.NeverStop)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> wait.Until(kl.updateRuntimeUp, <span class=\"number\">5</span>*time.Second, wait.NeverStop)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kl.makeIPTablesUtilChains &#123;</span><br><span class=\"line\">\t\tkl.initNetworkUtil()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个kill pod的goroutine</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> wait.Until(kl.podKiller.PerformPodKillingWork, <span class=\"number\">1</span>*time.Second, wait.NeverStop)</span><br><span class=\"line\"></span><br><span class=\"line\">\tkl.statusManager.Start()</span><br><span class=\"line\">\tkl.probeManager.Start()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kl.runtimeClassManager != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tkl.runtimeClassManager.Start(wait.NeverStop)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tkl.pleg.Start()</span><br><span class=\"line\">  <span class=\"comment\">// 同步的主逻辑</span></span><br><span class=\"line\">\tkl.syncLoop(updates, kl)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"syncLoop\"><a href=\"#syncLoop\" class=\"headerlink\" title=\"syncLoop\"></a>syncLoop</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">syncLoop</span><span class=\"params\">(updates &lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 开始运行kubelet的主同步循环</span></span><br><span class=\"line\">\tklog.Info(<span class=\"string\">&quot;Starting kubelet main sync loop.&quot;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ticker每秒一次</span></span><br><span class=\"line\">\tsyncTicker := time.NewTicker(time.Second)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> syncTicker.Stop()</span><br><span class=\"line\">  <span class=\"comment\">// housekeeping 清理周期</span></span><br><span class=\"line\">\thousekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> housekeepingTicker.Stop()</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tkl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class=\"line\">    <span class=\"comment\">// 同步</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tkl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的3个channel比较重要：configCh用于配置，syncCh用于触发同步，housekeepingCh用于触发清理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">syncLoopIteration</span><span class=\"params\">(configCh &lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tsyncCh &lt;-<span class=\"keyword\">chan</span> time.Time, housekeepingCh &lt;-<span class=\"keyword\">chan</span> time.Time, plegCh &lt;-<span class=\"keyword\">chan</span> *pleg.PodLifecycleEvent)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> u, open := &lt;-configCh:</span><br><span class=\"line\">    <span class=\"comment\">// config channel关闭</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !open &#123;</span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">&quot;Update channel is closed. Exiting the sync loop.&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 对应不同的操作</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> u.Op &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.ADD:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;SyncLoop (ADD, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodAdditions(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.UPDATE:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;SyncLoop (UPDATE, %q): %q&quot;</span>, u.Source, format.PodsWithDeletionTimestamps(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodUpdates(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.REMOVE:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;SyncLoop (REMOVE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodRemoves(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.RECONCILE:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;SyncLoop (RECONCILE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodReconcile(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.DELETE:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;SyncLoop (DELETE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodUpdates(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.SET:</span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">&quot;Kubelet does not support snapshot update&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">&quot;Invalid event type received: %d.&quot;</span>, u.Op)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tkl.sourcesReady.AddSource(u.Source)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> e := &lt;-plegCh:</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> &lt;-syncCh:</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取需要同步的pod，里面的逻辑暂不细看</span></span><br><span class=\"line\">    <span class=\"comment\">// 我们在这里接收到示例中要创建的nginx pod</span></span><br><span class=\"line\">\t\tpodsToSync := kl.getPodsToSync()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(podsToSync) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;SyncLoop (SYNC): %d pods; %s&quot;</span>, <span class=\"built_in\">len</span>(podsToSync), format.Pods(podsToSync))</span><br><span class=\"line\">    <span class=\"comment\">// 开始处理</span></span><br><span class=\"line\">\t\thandler.HandlePodSyncs(podsToSync)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> &lt;-housekeepingCh:</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !kl.sourcesReady.AllReady() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 清理没有ready，直接跳过</span></span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;SyncLoop (housekeeping, skipped): sources aren&#x27;t ready yet.&quot;</span>)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 开始清理pod</span></span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;SyncLoop (housekeeping)&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := handler.HandlePodCleanups(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tklog.Errorf(<span class=\"string\">&quot;Failed cleaning pods: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"handler\"><a href=\"#handler\" class=\"headerlink\" title=\"handler\"></a>handler</h2><p>往前查找代码，handler就是Kubelet</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">HandlePodSyncs</span><span class=\"params\">(pods []*v1.Pod)</span></span> &#123;</span><br><span class=\"line\">\tstart := kl.clock.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, pod := <span class=\"keyword\">range</span> pods &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取pod，然后分发</span></span><br><span class=\"line\">\t\tmirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</span><br><span class=\"line\">\t\tkl.dispatchWork(pod, kubetypes.SyncPodSync, mirrorPod, start)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">dispatchWork</span><span class=\"params\">(pod *v1.Pod, syncType kubetypes.SyncPodType, mirrorPod *v1.Pod, start time.Time)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用UpdatePod的函数</span></span><br><span class=\"line\">\tkl.podWorkers.UpdatePod(&amp;UpdatePodOptions&#123;</span><br><span class=\"line\">\t\tPod:        pod,</span><br><span class=\"line\">\t\tMirrorPod:  mirrorPod,</span><br><span class=\"line\">\t\tUpdateType: syncType,</span><br><span class=\"line\">\t\tOnCompleteFunc: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(err error)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tmetrics.PodWorkerDuration.WithLabelValues(syncType.String()).Observe(metrics.SinceInSeconds(start))</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查到初始化的地方 \tklet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *podWorkers)</span> <span class=\"title\">UpdatePod</span><span class=\"params\">(options *UpdatePodOptions)</span></span> &#123;</span><br><span class=\"line\">\tpod := options.Pod</span><br><span class=\"line\">\tuid := pod.UID</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> podUpdates <span class=\"keyword\">chan</span> UpdatePodOptions</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> exists <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tp.podLock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.podLock.Unlock()</span><br><span class=\"line\">  <span class=\"comment\">// 当pod不存在时，满足示例，是新建的pod</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> podUpdates, exists = p.podUpdates[uid]; !exists &#123;</span><br><span class=\"line\">\t\tpodUpdates = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> UpdatePodOptions, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tp.podUpdates[uid] = podUpdates</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 并发处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> runtime.HandleCrash()</span><br><span class=\"line\">\t\t\tp.managePodLoop(podUpdates)</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !p.isWorking[pod.UID] &#123;</span><br><span class=\"line\">\t\tp.isWorking[pod.UID] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\tpodUpdates &lt;- *options</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tupdate, found := p.lastUndeliveredWorkUpdate[pod.UID]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !found || update.UpdateType != kubetypes.SyncPodKill &#123;</span><br><span class=\"line\">\t\t\tp.lastUndeliveredWorkUpdate[pod.UID] = *options</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *podWorkers)</span> <span class=\"title\">managePodLoop</span><span class=\"params\">(podUpdates &lt;-<span class=\"keyword\">chan</span> UpdatePodOptions)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> lastSyncTime time.Time</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> update := <span class=\"keyword\">range</span> podUpdates &#123;</span><br><span class=\"line\">\t\terr := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 同步pod的函数</span></span><br><span class=\"line\">\t\t\terr = p.syncPodFn(syncPodOptions&#123;</span><br><span class=\"line\">\t\t\t\tmirrorPod:      update.MirrorPod,</span><br><span class=\"line\">\t\t\t\tpod:            update.Pod,</span><br><span class=\"line\">\t\t\t\tpodStatus:      status,</span><br><span class=\"line\">\t\t\t\tkillPodOptions: update.KillPodOptions,</span><br><span class=\"line\">\t\t\t\tupdateType:     update.UpdateType,</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\tlastSyncTime = time.Now()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tp.wrapUp(update.Pod.UID, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到syncPodFn被实例化的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">syncPod</span><span class=\"params\">(o syncPodOptions)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 这里有一长串逻辑，不方便阅读，我们只关注最核心的部分</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 调用 container runtime进行创建pod，再往下就是容器相关了</span></span><br><span class=\"line\">\tresult := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)</span><br><span class=\"line\">\tkl.reasonCache.Update(pod.UID, result)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := result.Error(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> result.SyncResults &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r.Error != kubecontainer.ErrCrashLoopBackOff &amp;&amp; r.Error != images.ErrImagePullBackOff &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><ol>\n<li><p><code>kubelet</code>是kubernetes的<code>Node</code>节点上的管理者</p>\n</li>\n<li><p><code>kubelet</code>接收来自<code>kube-apiserver</code>上的pod消息，用<code>Ticker</code>这种周期性的方式触发同步函数</p>\n</li>\n<li><code>kubelet</code>会异步地对容器进行管理，调用对应容器的接口（Container Runtime Interface）</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"聚焦目标\"><a href=\"#聚焦目标\" class=\"headerlink\" title=\"聚焦目标\"></a>聚焦目标</h2><p>理解 kubelet 的运行机制</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#Run\">运行的主函数</a></li>\n<li><a href=\"#RunKubelet\">运行kubelet</a></li>\n<li><a href=\"#Kubelet\">核心数据管理Kubelet</a></li>\n<li><a href=\"#syncLoop\">同步循环</a></li>\n<li><a href=\"#handler\">处理pod的同步工作</a></li>\n<li><a href=\"#Summary\">总结</a></li>\n</ol>\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><p>从主函数找到run函数，代码较长，我精简了一下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">run</span><span class=\"params\">(ctx context.Context, s *options.KubeletServer, kubeDeps *kubelet.Dependencies, featureGate featuregate.FeatureGate)</span> <span class=\"params\">(err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 一长串的配置初始化与验证</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// done channel，用来通知运行结束</span></span><br><span class=\"line\">\tdone := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 注册到configz模块</span></span><br><span class=\"line\">\terr = initConfigz(&amp;s.KubeletConfiguration)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Errorf(<span class=\"string\">&quot;unable to register KubeletConfiguration with configz, error: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获取节点的相关信息</span></span><br><span class=\"line\">\thostName, err := nodeutil.GetHostname(s.HostnameOverride)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnodeName, err := getNodeName(kubeDeps.Cloud, hostName)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 独立运行模式</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> standaloneMode:</span><br><span class=\"line\">\t<span class=\"comment\">// 对客户端进行初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> kubeDeps.KubeClient == <span class=\"literal\">nil</span>, kubeDeps.EventClient == <span class=\"literal\">nil</span>, kubeDeps.HeartbeatClient == <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// cgroup 相关初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> cgroupRoots []<span class=\"keyword\">string</span></span><br><span class=\"line\">\tnodeAllocatableRoot := cm.NodeAllocatableRoot(s.CgroupRoot, s.CgroupsPerQOS, s.CgroupDriver)</span><br><span class=\"line\">\tcgroupRoots = <span class=\"built_in\">append</span>(cgroupRoots, nodeAllocatableRoot)</span><br><span class=\"line\">\tkubeletCgroup, err := cm.GetKubeletContainer(s.KubeletCgroups)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Warningf(<span class=\"string\">&quot;failed to get the kubelet&#x27;s cgroup: %v.  Kubelet system container metrics may be missing.&quot;</span>, err)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> kubeletCgroup != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\tcgroupRoots = <span class=\"built_in\">append</span>(cgroupRoots, kubeletCgroup)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\truntimeCgroup, err := cm.GetRuntimeContainer(s.ContainerRuntime, s.RuntimeCgroups)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Warningf(<span class=\"string\">&quot;failed to get the container runtime&#x27;s cgroup: %v. Runtime system container metrics may be missing.&quot;</span>, err)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> runtimeCgroup != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\tcgroupRoots = <span class=\"built_in\">append</span>(cgroupRoots, runtimeCgroup)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.SystemCgroups != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\tcgroupRoots = <span class=\"built_in\">append</span>(cgroupRoots, s.SystemCgroups)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 下面一大块都是对 ContainerManager 的初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kubeDeps.ContainerManager == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.CgroupsPerQOS &amp;&amp; s.CgroupRoot == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tklog.Info(<span class=\"string\">&quot;--cgroups-per-qos enabled, but --cgroup-root was not specified.  defaulting to /&quot;</span>)</span><br><span class=\"line\">\t\t\ts.CgroupRoot = <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">// cpu相关信息</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> reservedSystemCPUs cpuset.CPUSet</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ContainerManager的实例化</span></span><br><span class=\"line\">\t\tkubeDeps.ContainerManager, err = cm.NewContainerManager(</span><br><span class=\"line\">\t\t\tkubeDeps.Mounter,</span><br><span class=\"line\">\t\t\tkubeDeps.CAdvisorInterface,</span><br><span class=\"line\">      <span class=\"comment\">// Node 相关配置</span></span><br><span class=\"line\">\t\t\tcm.NodeConfig&#123;&#125;,</span><br><span class=\"line\">\t\t\ts.FailSwapOn,</span><br><span class=\"line\">\t\t\tdevicePluginEnabled,</span><br><span class=\"line\">\t\t\tkubeDeps.Recorder)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 内存OOM相关</span></span><br><span class=\"line\">\toomAdjuster := kubeDeps.OOMAdjuster</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := oomAdjuster.ApplyOOMScoreAdj(<span class=\"number\">0</span>, <span class=\"keyword\">int</span>(s.OOMScoreAdj)); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tklog.Warning(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 预初始化Runtime</span></span><br><span class=\"line\">\terr = kubelet.PreInitRuntimeService(&amp;s.KubeletConfiguration,</span><br><span class=\"line\">\t\tkubeDeps, &amp;s.ContainerRuntimeOptions,</span><br><span class=\"line\">\t\ts.ContainerRuntime,</span><br><span class=\"line\">\t\ts.RuntimeCgroups,</span><br><span class=\"line\">\t\ts.RemoteRuntimeEndpoint,</span><br><span class=\"line\">\t\ts.RemoteImageEndpoint,</span><br><span class=\"line\">\t\ts.NonMasqueradeCIDR)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 运行Kubelet</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := RunKubelet(s, kubeDeps, s.RunOnce); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 通知deamon的systemd</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> daemon.SdNotify(<span class=\"literal\">false</span>, <span class=\"string\">&quot;READY=1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> &lt;-done:</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RunKubelet\"><a href=\"#RunKubelet\" class=\"headerlink\" title=\"RunKubelet\"></a>RunKubelet</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RunKubelet</span><span class=\"params\">(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce <span class=\"keyword\">bool</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取节点信息</span></span><br><span class=\"line\">  hostname, err := nodeutil.GetHostname(kubeServer.HostnameOverride)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnodeName, err := getNodeName(kubeDeps.Cloud, hostname)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\thostnameOverridden := <span class=\"built_in\">len</span>(kubeServer.HostnameOverride) &gt; <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 创建并初始化 kubelet</span></span><br><span class=\"line\">\tk, err := createAndInitKubelet()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;failed to create kubelet: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> runOnce &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, err := k.RunOnce(podCfg.Updates()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;runonce failed: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.Info(<span class=\"string\">&quot;Started kubelet as runonce&quot;</span>)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开始kubelet</span></span><br><span class=\"line\">\t\tstartKubelet(k, podCfg, &amp;kubeServer.KubeletConfiguration, kubeDeps, kubeServer.EnableCAdvisorJSONEndpoints, kubeServer.EnableServer)</span><br><span class=\"line\">\t\tklog.Info(<span class=\"string\">&quot;Started kubelet&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始运行，都是并发的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startKubelet</span><span class=\"params\">(k kubelet.Bootstrap, podCfg *config.PodConfig, kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *kubelet.Dependencies, enableCAdvisorJSONEndpoints, enableServer <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 运行</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> k.Run(podCfg.Updates())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 开启kubelet的http服务端</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> enableServer &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> k.ListenAndServe(net.ParseIP(kubeCfg.Address), <span class=\"keyword\">uint</span>(kubeCfg.Port), kubeDeps.TLSOptions, kubeDeps.Auth,</span><br><span class=\"line\">\t\t\tenableCAdvisorJSONEndpoints, kubeCfg.EnableDebuggingHandlers, kubeCfg.EnableContentionProfiling, kubeCfg.EnableSystemLogHandler)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 只读端口</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kubeCfg.ReadOnlyPort &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> k.ListenAndServeReadOnly(net.ParseIP(kubeCfg.Address), <span class=\"keyword\">uint</span>(kubeCfg.ReadOnlyPort), enableCAdvisorJSONEndpoints)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> utilfeature.DefaultFeatureGate.Enabled(features.KubeletPodResources) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> k.ListenAndServePodResources()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Kubelet\"><a href=\"#Kubelet\" class=\"headerlink\" title=\"Kubelet\"></a>Kubelet</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里的k是一个interface定义，我们需要回头看看</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Bootstrap <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tGetConfiguration() kubeletconfiginternal.KubeletConfiguration</span><br><span class=\"line\">\tBirthCry()</span><br><span class=\"line\">\tStartGarbageCollection()</span><br><span class=\"line\">\tListenAndServe(address net.IP, port <span class=\"keyword\">uint</span>, tlsOptions *server.TLSOptions, auth server.AuthInterface, enableCAdvisorJSONEndpoints, enableDebuggingHandlers, enableContentionProfiling, enableSystemLogHandler <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">\tListenAndServeReadOnly(address net.IP, port <span class=\"keyword\">uint</span>, enableCAdvisorJSONEndpoints <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">\tListenAndServePodResources()</span><br><span class=\"line\">\tRun(&lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate)</span><br><span class=\"line\">\tRunOnce(&lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate) ([]RunPodResult, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看对应的实例化函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createAndInitKubelet</span><span class=\"params\">()</span> <span class=\"params\">(k kubelet.Bootstrap, err error)</span></span> &#123;</span><br><span class=\"line\">\tk, err = kubelet.NewMainKubelet()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> k, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewMainKubelet</span><span class=\"params\">()</span> <span class=\"params\">(*Kubelet, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 参数的初始化</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// klet 的实例化结构</span></span><br><span class=\"line\">\tklet := &amp;Kubelet&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 下面是klet中各种参数的填充</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> klet, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">Run</span><span class=\"params\">(updates &lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 内部模块的初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := kl.initializeModules(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tkl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())</span><br><span class=\"line\">\t\tklog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kl.kubeClient != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 与kube-apiserver同步节点状态</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> wait.Until(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, wait.NeverStop)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> kl.fastStatusUpdateOnce()</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> kl.nodeLeaseController.Run(wait.NeverStop)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> wait.Until(kl.updateRuntimeUp, <span class=\"number\">5</span>*time.Second, wait.NeverStop)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kl.makeIPTablesUtilChains &#123;</span><br><span class=\"line\">\t\tkl.initNetworkUtil()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个kill pod的goroutine</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> wait.Until(kl.podKiller.PerformPodKillingWork, <span class=\"number\">1</span>*time.Second, wait.NeverStop)</span><br><span class=\"line\"></span><br><span class=\"line\">\tkl.statusManager.Start()</span><br><span class=\"line\">\tkl.probeManager.Start()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> kl.runtimeClassManager != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tkl.runtimeClassManager.Start(wait.NeverStop)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tkl.pleg.Start()</span><br><span class=\"line\">  <span class=\"comment\">// 同步的主逻辑</span></span><br><span class=\"line\">\tkl.syncLoop(updates, kl)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"syncLoop\"><a href=\"#syncLoop\" class=\"headerlink\" title=\"syncLoop\"></a>syncLoop</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">syncLoop</span><span class=\"params\">(updates &lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 开始运行kubelet的主同步循环</span></span><br><span class=\"line\">\tklog.Info(<span class=\"string\">&quot;Starting kubelet main sync loop.&quot;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ticker每秒一次</span></span><br><span class=\"line\">\tsyncTicker := time.NewTicker(time.Second)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> syncTicker.Stop()</span><br><span class=\"line\">  <span class=\"comment\">// housekeeping 清理周期</span></span><br><span class=\"line\">\thousekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> housekeepingTicker.Stop()</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tkl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class=\"line\">    <span class=\"comment\">// 同步</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tkl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的3个channel比较重要：configCh用于配置，syncCh用于触发同步，housekeepingCh用于触发清理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">syncLoopIteration</span><span class=\"params\">(configCh &lt;-<span class=\"keyword\">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\tsyncCh &lt;-<span class=\"keyword\">chan</span> time.Time, housekeepingCh &lt;-<span class=\"keyword\">chan</span> time.Time, plegCh &lt;-<span class=\"keyword\">chan</span> *pleg.PodLifecycleEvent)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> u, open := &lt;-configCh:</span><br><span class=\"line\">    <span class=\"comment\">// config channel关闭</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !open &#123;</span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">&quot;Update channel is closed. Exiting the sync loop.&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 对应不同的操作</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> u.Op &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.ADD:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;SyncLoop (ADD, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodAdditions(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.UPDATE:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;SyncLoop (UPDATE, %q): %q&quot;</span>, u.Source, format.PodsWithDeletionTimestamps(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodUpdates(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.REMOVE:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;SyncLoop (REMOVE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodRemoves(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.RECONCILE:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;SyncLoop (RECONCILE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodReconcile(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.DELETE:</span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">2</span>).Infof(<span class=\"string\">&quot;SyncLoop (DELETE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class=\"line\">\t\t\thandler.HandlePodUpdates(u.Pods)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> kubetypes.SET:</span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">&quot;Kubelet does not support snapshot update&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tklog.Errorf(<span class=\"string\">&quot;Invalid event type received: %d.&quot;</span>, u.Op)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tkl.sourcesReady.AddSource(u.Source)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> e := &lt;-plegCh:</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> &lt;-syncCh:</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取需要同步的pod，里面的逻辑暂不细看</span></span><br><span class=\"line\">    <span class=\"comment\">// 我们在这里接收到示例中要创建的nginx pod</span></span><br><span class=\"line\">\t\tpodsToSync := kl.getPodsToSync()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(podsToSync) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;SyncLoop (SYNC): %d pods; %s&quot;</span>, <span class=\"built_in\">len</span>(podsToSync), format.Pods(podsToSync))</span><br><span class=\"line\">    <span class=\"comment\">// 开始处理</span></span><br><span class=\"line\">\t\thandler.HandlePodSyncs(podsToSync)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> &lt;-housekeepingCh:</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !kl.sourcesReady.AllReady() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 清理没有ready，直接跳过</span></span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;SyncLoop (housekeeping, skipped): sources aren&#x27;t ready yet.&quot;</span>)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 开始清理pod</span></span><br><span class=\"line\">\t\t\tklog.V(<span class=\"number\">4</span>).Infof(<span class=\"string\">&quot;SyncLoop (housekeeping)&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := handler.HandlePodCleanups(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tklog.Errorf(<span class=\"string\">&quot;Failed cleaning pods: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"handler\"><a href=\"#handler\" class=\"headerlink\" title=\"handler\"></a>handler</h2><p>往前查找代码，handler就是Kubelet</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">HandlePodSyncs</span><span class=\"params\">(pods []*v1.Pod)</span></span> &#123;</span><br><span class=\"line\">\tstart := kl.clock.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, pod := <span class=\"keyword\">range</span> pods &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取pod，然后分发</span></span><br><span class=\"line\">\t\tmirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</span><br><span class=\"line\">\t\tkl.dispatchWork(pod, kubetypes.SyncPodSync, mirrorPod, start)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">dispatchWork</span><span class=\"params\">(pod *v1.Pod, syncType kubetypes.SyncPodType, mirrorPod *v1.Pod, start time.Time)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用UpdatePod的函数</span></span><br><span class=\"line\">\tkl.podWorkers.UpdatePod(&amp;UpdatePodOptions&#123;</span><br><span class=\"line\">\t\tPod:        pod,</span><br><span class=\"line\">\t\tMirrorPod:  mirrorPod,</span><br><span class=\"line\">\t\tUpdateType: syncType,</span><br><span class=\"line\">\t\tOnCompleteFunc: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(err error)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tmetrics.PodWorkerDuration.WithLabelValues(syncType.String()).Observe(metrics.SinceInSeconds(start))</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查到初始化的地方 \tklet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *podWorkers)</span> <span class=\"title\">UpdatePod</span><span class=\"params\">(options *UpdatePodOptions)</span></span> &#123;</span><br><span class=\"line\">\tpod := options.Pod</span><br><span class=\"line\">\tuid := pod.UID</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> podUpdates <span class=\"keyword\">chan</span> UpdatePodOptions</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> exists <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tp.podLock.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.podLock.Unlock()</span><br><span class=\"line\">  <span class=\"comment\">// 当pod不存在时，满足示例，是新建的pod</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> podUpdates, exists = p.podUpdates[uid]; !exists &#123;</span><br><span class=\"line\">\t\tpodUpdates = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> UpdatePodOptions, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tp.podUpdates[uid] = podUpdates</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 并发处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> runtime.HandleCrash()</span><br><span class=\"line\">\t\t\tp.managePodLoop(podUpdates)</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !p.isWorking[pod.UID] &#123;</span><br><span class=\"line\">\t\tp.isWorking[pod.UID] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\tpodUpdates &lt;- *options</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tupdate, found := p.lastUndeliveredWorkUpdate[pod.UID]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !found || update.UpdateType != kubetypes.SyncPodKill &#123;</span><br><span class=\"line\">\t\t\tp.lastUndeliveredWorkUpdate[pod.UID] = *options</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *podWorkers)</span> <span class=\"title\">managePodLoop</span><span class=\"params\">(podUpdates &lt;-<span class=\"keyword\">chan</span> UpdatePodOptions)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> lastSyncTime time.Time</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> update := <span class=\"keyword\">range</span> podUpdates &#123;</span><br><span class=\"line\">\t\terr := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 同步pod的函数</span></span><br><span class=\"line\">\t\t\terr = p.syncPodFn(syncPodOptions&#123;</span><br><span class=\"line\">\t\t\t\tmirrorPod:      update.MirrorPod,</span><br><span class=\"line\">\t\t\t\tpod:            update.Pod,</span><br><span class=\"line\">\t\t\t\tpodStatus:      status,</span><br><span class=\"line\">\t\t\t\tkillPodOptions: update.KillPodOptions,</span><br><span class=\"line\">\t\t\t\tupdateType:     update.UpdateType,</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\tlastSyncTime = time.Now()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tp.wrapUp(update.Pod.UID, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到syncPodFn被实例化的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *Kubelet)</span> <span class=\"title\">syncPod</span><span class=\"params\">(o syncPodOptions)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 这里有一长串逻辑，不方便阅读，我们只关注最核心的部分</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 调用 container runtime进行创建pod，再往下就是容器相关了</span></span><br><span class=\"line\">\tresult := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)</span><br><span class=\"line\">\tkl.reasonCache.Update(pod.UID, result)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := result.Error(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> result.SyncResults &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r.Error != kubecontainer.ErrCrashLoopBackOff &amp;&amp; r.Error != images.ErrImagePullBackOff &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><ol>\n<li><p><code>kubelet</code>是kubernetes的<code>Node</code>节点上的管理者</p>\n</li>\n<li><p><code>kubelet</code>接收来自<code>kube-apiserver</code>上的pod消息，用<code>Ticker</code>这种周期性的方式触发同步函数</p>\n</li>\n<li><code>kubelet</code>会异步地对容器进行管理，调用对应容器的接口（Container Runtime Interface）</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cklaograr000ca4qpcjyu67el","category_id":"cklaonbqd000ja4qp83sb85hg","_id":"cklaonbqe000ka4qp7my8ex0h"}],"PostTag":[{"post_id":"cklaograr000ca4qpcjyu67el","tag_id":"cklaoi2hj000fa4qpbzn43v5r","_id":"cklaoi2hl000ga4qp5gyi7bzm"}],"Tag":[{"name":"111","_id":"cklaogras000da4qp84540mez"},{"name":"Kubernetes","_id":"cklaoi2hj000fa4qpbzn43v5r"}]}}